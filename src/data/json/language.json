{
  "0": {
    "label": ".QL",
    "wikipedia_pageid": 11537140,
    "inception": { "time": "+2007-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [28, 6, 13],
    "typing": [1, 11],
    "description": "**.QL** (pronounced \"dot-cue-el\") is an object-oriented query language used to retrieve data from relational database management systems. It is reminiscent of the standard query language SQL and the object-oriented programming language Java. .QL is an object-oriented variant of a logical query language called Datalog. Hierarchical data can therefore be naturally queried in .QL in a recursive manner. Queries written in .QL are optimised, compiled into SQL and can then be executed on any major relational database management system. .QL query language is being used in SemmleCode to query a relational representation of Java programs. .QL is developed at Semmle Limited and is based on the company's proprietary technology."
  },
  "1": {
    "label": "A#",
    "wikipedia_pageid": 2994340,
    "inception": { "time": "+2004-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**A#** is a port of the Ada programming language to the Microsoft .NET platform. A# is freely distributed by the Department of Computer Science at the United States Air Force Academy as a service to the Ada community under the terms of the GNU General Public License. AdaCore took over this development in 2007, and announced \"GNAT for .NET\", which is a fully supported .NET product with all of the features of A# and more. As of 2021, A# has fallen dramatically in popularity and is considered by some to be a dead language (there are no known users or implementations)."
  },
  "2": {
    "label": "A+",
    "wikipedia_pageid": 890931,
    "inception": { "time": "+1988-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [20],
    "typing": [10, 1],
    "description": "**A+** is an array programming language descended from the programming language A, which in turn was created to replace APL in 1988. Arthur Whitney developed the _A_ portion of A+, while other developers at Morgan Stanley extended it, adding a graphical user interface and other language features. A+ is a high-level, interactive, interpreted language, designed for numerically intensive applications, especially those found in financial applications. A+ runs on many Unix variants, including Linux. It is free and open source software released under a GNU General Public License. A+ provides an extended set of functions and operators, a graphical user interface with automatic synchronizing of widgets and variables, asynchronous executing of functions associated with variables and events, dynamic loading of user compiled subroutines, and other features. A newer graphical user interface has not yet been ported to all supported platforms The A+ language implements the following changes to the APL language:   * an A+ function may have up to nine formal parameters   * A+ code statements are separated by semicolons, so a single statement may be divided into two or more physical lines   * The explicit result of a function or operator is the result of the last statement executed   * A+ implements an object called a dependency, which is a global variable (the dependent variable) and an associated definition that is like a function with no arguments. Values can be explicitly set and referenced in exactly the same ways as for a global variable, but they can also be set through the associated definition. Interactive A+ development is primarily done in the Xemacs editor, through extensions to the editor. Because A+ code uses the original APL symbols, displaying A+ requires a font with those special characters; a font named _kapl_ is provided on the web site for that purpose. Arthur Whitney went on to create a proprietary array language named K. Like J, K omits the APL character set. It lacks some of the perceived complexities of A+, such as the existence of statements and two different modes of syntax."
  },
  "3": {
    "label": "A-0 System",
    "wikipedia_pageid": 60383,
    "inception": { "time": "+1952-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "The **A-0 system** (_Arithmetic Language version 0_), written by Grace Murray Hopper in 1951 and 1952 for the UNIVAC I, was an early compiler related tool developed for electronic computers. The A-0 functioned more as a loader or linker than the modern notion of a compiler. A program was specified as a sequence of subroutines and arguments. The subroutines were identified by a numeric code and the arguments to the subroutines were written directly after each subroutine code. The A-0 system converted the specification into machine code that could be fed into the computer a second time to execute the said program. The A-0 system was followed by the A-1, A-2, A-3 (released as ARITH-MATIC), AT-3 (released as MATH-MATIC) and B-0 (released as FLOW-MATIC). The A-2 system was developed at the UNIVAC division of Remington Rand in 1953 and released to customers by the end of that year. Customers were provided the source code for A-2 and invited to send their improvements back to UNIVAC. Thus, A-2 could be considered an example of the result of an early philosophy similar to free and open-source software."
  },
  "4": {
    "label": "ABAP",
    "wikipedia_pageid": 271832,
    "inception": { "time": "+1983-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 3, 36],
    "typing": [4, 1, 11],
    "description": "**ABAP** (Advanced Business Application Programming, originally _Allgemeiner Berichts-Aufbereitungs-Prozessor_, German for \"general report preparation processor\") is a high-level programming language created by the German software company SAP SE. It is extracted from the base computing languages Java, C, C++ and Python. It is currently positioned, alongside Java, as the language for programming the SAP NetWeaver Application Server, which is part of the SAP NetWeaver platform for building business applications."
  },
  "5": {
    "label": "ABC",
    "wikipedia_pageid": 147585,
    "inception": { "time": "+1975-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 36],
    "typing": [7, 1],
    "description": "**ABC** is an imperative general-purpose programming language and integrated development environment (IDE) developed at Centrum Wiskunde & Informatica (CWI), Netherlands by Leo Geurts, Lambert Meertens, and Steven Pemberton. It is interactive, structured, high-level, and intended to be used instead of BASIC, Pascal, or AWK. It is intended for teaching or prototyping, but not as a systems-programming language. ABC had a major influence on the design of the language Python, developed by Guido van Rossum, who formerly worked for several years on the ABC system in the mid-1980s."
  },
  "6": {
    "label": "ABC ALGOL",
    "wikipedia_pageid": 60450,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**ABC ALGOL** is an extension of the programming language ALGOL 60 with arbitrary data structures and user-defined operators, intended for computer algebra (symbolic mathematics). Despite its advances, it was never used as widely as Algol proper."
  },
  "7": {
    "label": "ACC",
    "wikipedia_pageid": 928669,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**ACC** is a near-C compiler for the MS-DOS operating system on the IBM PC line of computers for programs. The compiler and compiled programs will run on any Intel 80386 or above PC running MS-DOS. Included with the compiler are a 386 assembler and a linker for combining multiple object files. There are also two libraries, which are a protected mode DOS extender (based on Thomas Pytel's, AKA Tran's PMODE30B + PMODE307 DOS extenders), and a library of functions callable by C programs. Pointers are 4 bytes, and can access all available memory. All memory can be allocated too. The compiler, assembler and linker are all very small and reportedly very fast. ACC uses simple commands which place objects and change them. As such, it is very hard to make games with complicated sprites, because there is no command which can group objects. Almost every type of command is two or three letters, for example: tx=text, col=color, oct=octagon, etc. It is similar to Batch."
  },
  "8": {
    "label": "ALGOL",
    "wikipedia_pageid": 1453,
    "inception": { "time": "+1958-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 36],
    "typing": [],
    "description": "**ALGOL** (; short for \"**Algorithmic Language**\") is a family of imperative computer programming languages originally developed in 1958. ALGOL heavily influenced many other languages and was the standard method for algorithm description used by the Association for Computing Machinery (ACM) in textbooks and academic sources for more than thirty years. In the sense that the syntax of most modern languages is \"Algol-like\", it was arguably the most influential of the four high-level programming languages among which it was roughly contemporary: FORTRAN, Lisp, and COBOL. It was designed to avoid some of the perceived problems with FORTRAN and eventually gave rise to many other programming languages, including PL/I, Simula, BCPL, B, Pascal, and C. ALGOL introduced code blocks and the `begin`...`end` pairs for delimiting them. It was also the first language implementing nested function definitions with lexical scope. Moreover, it was the first programming language which gave detailed attention to formal language definition and through the _Algol 60 Report_ introduced Backus–Naur form, a principal formal grammar notation for language design. There were three major specifications, named after the years they were first published:   * ALGOL 58 – originally proposed to be called _IAL_, for _International Algebraic Language_.   * ALGOL 60 – first implemented as _X1 ALGOL 60_ in mid-1960. Revised 1963.   * ALGOL 68 – introduced new elements including flexible arrays, slices, parallelism, operator identification. Revised 1973. ALGOL 68 is substantially different from ALGOL 60 and was not well received, so in general \"Algol\" means ALGOL 60 and its dialects."
  },
  "9": {
    "label": "ALGOL 58",
    "wikipedia_pageid": 944870,
    "inception": null,
    "paradigm": [2, 3, 36],
    "typing": [1, 11],
    "description": "**ALGOL 58**, originally named **IAL**, is one of the family of ALGOL computer programming languages. It was an early compromise design soon superseded by ALGOL 60. According to John Backus > \"The Zurich ACM-GAMM Conference had two principal motives in proposing the > IAL: (a) To provide a means of communicating numerical methods and other > procedures between people, and (b) To provide a means of realizing a stated > process on a variety of machines...\" ALGOL 58 introduced the fundamental notion of the compound statement, but it was restricted to control flow only, and it was not tied to identifier scope in the way that Algol 60's blocks were."
  },
  "10": {
    "label": "ALGOL 60",
    "wikipedia_pageid": 692878,
    "inception": null,
    "paradigm": [2, 3, 36],
    "typing": [1, 11],
    "description": "**ALGOL 60** (short for _Algorithmic Language 1960_) is a member of the ALGOL family of computer programming languages. It followed on from ALGOL 58 which had introduced code blocks and the `begin` and `end` pairs for delimiting them, representing a key advance in the rise of structured programming. ALGOL 60 was the first language implementing nested function definitions with lexical scope. It gave rise to many other programming languages, including CPL, Simula, BCPL, B, Pascal, and C. Practically every computer of the era had a systems programming language based on ALGOL 60 concepts. Niklaus Wirth based his own ALGOL W on ALGOL 60 before moving to develop Pascal. Algol-W was intended to be the next generation ALGOL but the ALGOL 68 committee decided on a design that was more complex and advanced rather than a cleaned simplified ALGOL 60. The official ALGOL versions are named after the year they were first published. Algol 68 is substantially different from Algol 60 and was criticised partially for being so, so that in general \"Algol\" refers to dialects of Algol 60."
  },
  "11": {
    "label": "ALGOL 68",
    "wikipedia_pageid": 692880,
    "inception": null,
    "paradigm": [3, 16],
    "typing": [12, 1, 11],
    "description": "**ALGOL 68** (short for _Algorithmic Language 1968_) is an imperative programming language that was conceived as a successor to the ALGOL 60 programming language, designed with the goal of a much wider scope of application and more rigorously defined syntax and semantics. The complexity of the language's definition, which runs to several hundred pages filled with non-standard terminology, made compiler implementation difficult and it was said it had \"no implementations and no users\". This was only partly true; ALGOL 68 did find use in several niche markets, notably in the United Kingdom where it was popular on International Computers Limited (ICL) machines, and in teaching roles. Outside these fields, use was relatively limited. Nevertheless, the contributions of ALGOL 68 to the field of computer science have been deep, wide-ranging and enduring, although many of these contributions were only publicly identified when they had reappeared in subsequently developed programming languages. Many languages were developed specifically as a response to the perceived complexity of the language, the most notable being Pascal, or were reimplementations for specific roles, like Ada. Many languages of the 1970s trace their design specifically to ALGOL 68, selecting some features while abandoning others that were considered too complex or out-of-scope for given roles. Among these is the language C, which was directly influenced by ALGOL 68, especially by its strong typing and structures. Most modern languages trace at least some of their syntax to either C or Pascal, and thus directly or indirectly to ALGOL 68."
  },
  "12": {
    "label": "ALGOL W",
    "wikipedia_pageid": 211058,
    "inception": { "time": "+1966-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 36],
    "typing": [1, 11],
    "description": "**ALGOL W** is a programming language. It is based on a proposal for ALGOL X by Niklaus Wirth and Tony Hoare as a successor to ALGOL 60. ALGOL W is a relatively simple upgrade of the original ALGOL 60, adding string, bitstring, complex number and reference to record data types and call-by-result passing of parameters, introducing the `while` statement, replacing `switch` with the `case` statement, and generally tightening up the language. Wirth's entry was considered too little of an advance over ALGOL 60, and the more complex entry from Adriaan van Wijngaarden was selected in a highly contenrous meeting. After the selection, several members of the IFIP Working Group 2.1 quit. Wirth published his version as _A contribution to the development of ALGOL_. With a number of small additions, this became ALGOL W. Wirth supervised a high quality implementation for the IBM System/360 at Stanford University that was widely distributed. The implementation was written in PL360, an ALGOL-like assembly language designed by Wirth. The implementation includes influential debugging and profiling abilities. ALGOL W served as the basis for the Pascal language, and the syntax of ALGOL W will be immediately familiar to anyone with Pascal experience. The key differences are improvements to record handling in Pascal, and, oddly, the loss of ALGOL W's ability to define the length of an array at runtime, which is one of Pascal's most-complained-about features."
  },
  "13": {
    "label": "AMOS",
    "wikipedia_pageid": 2957,
    "inception": { "time": "+1990-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3],
    "typing": [11],
    "description": "**AMOS BASIC** is a dialect of the BASIC programming language implemented on the Amiga computer. AMOS BASIC was published by Europress Software and originally written by François Lionet with Constantin Sotiropoulos."
  },
  "14": {
    "label": "AMPL",
    "wikipedia_pageid": 1076270,
    "inception": { "time": "+1985-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3, 13],
    "typing": [],
    "description": "**AMPL** (**A Mathematical Programming Language**) is an algebraic modeling language to describe and solve high-complexity problems for large-scale mathematical computing (i.e., large-scale optimization and scheduling-type problems). It was developed by Robert Fourer, David Gay, and Brian Kernighan at Bell Laboratories. AMPL supports dozens of solvers, both open source and commercial software, including CBC, CPLEX, FortMP, Gurobi, MINOS, IPOPT, SNOPT, KNITRO, and LGO. Problems are passed to solvers as nl files. AMPL is used by more than 100 corporate clients, and by government agencies and academic institutions. One advantage of AMPL is the similarity of its syntax to the mathematical notation of optimization problems. This allows for a very concise and readable definition of problems in the domain of optimization. Many modern solvers available on the NEOS Server (formerly hosted at the Argonne National Laboratory, currently hosted at the University of Wisconsin, Madison) accept AMPL input. According to the NEOS statistics AMPL is the most popular format for representing mathematical programming problems."
  },
  "15": {
    "label": "APL",
    "wikipedia_pageid": 1451,
    "inception": { "time": "+1966-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [18, 20, 21, 36],
    "typing": [10],
    "description": "**APL** (named after the book _A Programming Language_) is a programming language developed in the 1960s by Kenneth E. Iverson. Its central datatype is the multidimensional array. It uses a large range of special graphic symbols to represent most functions and operators, leading to very concise code. It has been an important influence on the development of concept modeling, spreadsheets, functional programming, and computer math packages. It has also inspired several other programming languages."
  },
  "16": {
    "label": "Automatically Programmed Tool",
    "wikipedia_pageid": 3673047,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**APT** (**Automatically Programmed Tool**) is a high-level computer programming language most commonly used to generate instructions for numerically controlled machine tools. Douglas T. Ross is considered by many to be the father of APT: as head of the newly created Computer Applications Group of the Servomechanisms Laboratory at MIT in 1956, he led its technical effort. APT is a language and system that alleviates the tedious mathematics of writing toolpaths for numerically controlled equipment. This early language was used widely through the 1970s and is still a standard internationally. Derivatives of APT were later developed."
  },
  "17": {
    "label": "ARexx",
    "wikipedia_pageid": 1858505,
    "inception": { "time": "+1987-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**ARexx** is an implementation of the Rexx language for the Amiga, written in 1987 by William S. Hawes, with a number of Amiga-specific features beyond standard REXX facilities. Like most REXX implementations, ARexx is an interpreted language. Programs written for ARexx are called \"scripts\", or \"macros\"; several programs offer the ability to run ARexx scripts in their main interface as macros. ARexx can easily communicate with third-party software that implements an \"ARexx port\". Any Amiga application or script can define a set of commands and functions for ARexx to address, thus making the capabilities of the software available to the scripts written in ARexx. ARexx can direct commands and functions to several applications from the same script, thus offering the opportunity to mix and match functions from the different programs. For example, an ARexx script could extract data from a database, insert the data into a spreadsheet to perform calculations on it, then insert tables and charts based on the results into a word processor document."
  },
  "18": {
    "label": "AWK",
    "wikipedia_pageid": 1456,
    "inception": { "time": "+1977-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [1, 2],
    "typing": [],
    "description": "**AWK** (_awk_) is a domain-specific language designed for text processing and typically used as a data extraction and reporting tool. Like sed and grep, it is a filter, and is a standard feature of most Unix-like operating systems. The AWK language is a data-driven scripting language consisting of a set of actions to be taken against streams of textual data – either run directly on files or used as part of a pipeline – for purposes of extracting or transforming text, such as producing formatted reports. The language extensively uses the string datatype, associative arrays (that is, arrays indexed by key strings), and regular expressions. While AWK has a limited intended application domain and was especially designed to support one-liner programs, the language is Turing-complete, and even the early Bell Labs users of AWK often wrote well-structured large AWK programs. AWK was created at Bell Labs in the 1970s, and its name is derived from the surnames of its authors: Alfred Aho, Peter Weinberger, and Brian Kernighan. The acronym is pronounced the same as the bird auk, which is on the cover of _The AWK Programming Language_. When written in all lowercase letters, as `awk`, it refers to the Unix or Plan 9 program that runs scripts written in the AWK programming language."
  },
  "19": {
    "label": "Action!",
    "wikipedia_pageid": 1273369,
    "inception": { "time": "+1983-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2],
    "typing": [],
    "description": "**Action!** is a procedural programming language and integrated development environment written by Clinton Parker for the Atari 8-bit family. The language, which is similar to ALGOL, compiled to high-performance code for the MOS Technologies 6502 of the Atari computers. Action! was distributed on ROM cartridge by Optimized Systems Software starting in 1983. It was one of the company's first bank-switched \"Super Cartridges\", with a total of 16 kB of code. Working with Henry Baker, Parker had previously developed Micro-SPL, a systems programming language for the Xerox Alto. Action! was largely a port of Micro- SPL concepts to the Atari with changes to support the 6502 processor and the addition of an integrated fullscreen editor and debugger. Action! was used to develop at least two commercial products—the _HomePak_ productivity suite and _Games Computers Play_ client program—and numerous programs in _ANALOG Computing_ and _Antic_ magazines. The editor inspired the PaperClip word processor. The language was not ported to other platforms. The assembly language source code for Action! was made available under the GNU General Public License by the author in 2015."
  },
  "20": {
    "label": "ActionScript",
    "wikipedia_pageid": 519691,
    "inception": { "time": "+1998-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 3, 14, 21],
    "typing": [1, 11],
    "description": "**ActionScript** was an object-oriented programming language originally developed by Macromedia Inc. (later acquired by Adobe Systems). It is influenced by HyperTalk, the scripting language for HyperCard. It is now an implementation of ECMAScript (meaning it is a superset of the syntax and semantics of the language more widely known as JavaScript), though it originally arose as a sibling, both being influenced by HyperTalk. ActionScript was used primarily for the development of websites and software targeting the Adobe Flash Player platform, used on Web pages in the form of embedded SWF files. ActionScript 3 was also used with Adobe AIR system for the development of desktop and mobile applications. The language itself is open-source in that its specification is offered free of charge and both an open source compiler (as part of Apache Flex) and open source virtual machine (Mozilla Tamarin) are available. ActionScript was also used with Scaleform GFx for the development of 3D video game user interfaces and HUDs."
  },
  "21": {
    "label": "Actor",
    "wikipedia_pageid": 26849115,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "The **Actor** programming language was invented by Charles Duff of The Whitewater Group in 1988. It was an offshoot of some object-oriented extensions to the Forth language he had been working on. Actor is a pure object-oriented language in the style of Smalltalk. Like Smalltalk, everything is an object, including small integers. A Baker semi- space garbage collector is used, along with (in memory-constrained Windows 2.1 days) a software virtual memory system that swaps objects. A token threaded interpreter, written in 16-bit x86 assembly language, executes compiled code. Actor only was released for Microsoft Windows 2.1 and 3.0. Actor used a pure object-oriented framework over native operating system calls as its basic GUI architecture. This allows an Actor application to look and feel exactly like a Windows application written in C, but with all the advantages of an interactive Smalltalk-like development environment. Both a downside and upside to this architecture is a tight coupling to the Windows architecture, with a thin abstraction layer into objects. This allows direct use of the rich Windows OS API, but also makes it nearly impossible to support any other OS without a significant rewrite of the application framework."
  },
  "22": {
    "label": "Ada",
    "wikipedia_pageid": 1242,
    "inception": { "time": "+1980-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 3, 36],
    "typing": [1, 4, 11],
    "description": "**Ada** is a structured, statically typed, imperative, and object-oriented high-level programming language, extended from Pascal and other languages. It has built-in language support for _design by contract_ (DbC), extremely strong typing, explicit concurrency, tasks, synchronous message passing, protected objects, and non-determinism. Ada improves code safety and maintainability by using the compiler to find errors in favor of runtime errors. Ada is an international technical standard, jointly defined by the International Organization for Standardization (ISO), and the International Electrotechnical Commission (IEC). As of 2020, the standard, called Ada 2012 informally, is ISO/IEC 8652:2012. Ada was originally designed by a team led by French computer scientist Jean Ichbiah of CII Honeywell Bull under contract to the United States Department of Defense (DoD) from 1977 to 1983 to supersede over 450 programming languages used by the DoD at that time. Ada was named after Ada Lovelace (1815–1852), who has been credited as the first computer programmer."
  },
  "23": {
    "label": "AdvPL",
    "wikipedia_pageid": 41077376,
    "inception": { "time": "+1999-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**AdvPL** (_Advanced Protheus Language_) is a proprietary programming language based on xBase. It was released in 1999 and is used for development of applications in the ERP Protheus made by TOTVS."
  },
  "24": {
    "label": "Agda",
    "wikipedia_pageid": 4426773,
    "inception": { "time": "+2007-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [29],
    "typing": [0, 1, 4, 6, 11, 14],
    "description": "**Agda** is a dependently typed functional programming language originally developed by Ulf Norell at Chalmers University of Technology with implementation described in his PhD thesis. The original Agda system was developed at Chalmers by Catarina Coquand in 1999. The current version, originally known as Agda 2, is a full rewrite, which should be considered a new language that shares a name and tradition. Agda is also a proof assistant based on the propositions-as-types paradigm, but unlike Coq, has no separate tactics language, and proofs are written in a functional programming style. The language has ordinary programming constructs such as data types, pattern matching, records, let expressions and modules, and a Haskell-like syntax. The system has Emacs and Atom interfaces but can also be run in batch mode from the command line. Agda is based on Zhaohui Luo's unified theory of dependent types (UTT), a type theory similar to Martin-Löf type theory. Agda is named after the Swedish song \"Hönan Agda\", written by Cornelis Vreeswijk, which is about a hen named Agda. This alludes to the naming of Coq."
  },
  "25": {
    "label": "Aldor",
    "wikipedia_pageid": 948551,
    "inception": { "time": "+1990-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [28, 6, 3, 21],
    "typing": [0, 11],
    "description": "**Aldor** is a programming language. It is the successor of A# as the extension language of the Axiom computer algebra system. Aldor combines imperative, functional, and object-oriented features. It has an elaborate type system, allowing types to be used as first-class values. Aldor's syntax is heavily influenced by Pascal, but it is optionally indentation-sensitive, using whitespace characters and the off-side rule, like Python. In its current implementation, it is compiled, but an interactive listener is provided. Aldor is distributed as free and open-source software, under the Apache License 2.0."
  },
  "26": {
    "label": "Alef",
    "wikipedia_pageid": 1935217,
    "inception": { "time": "+1992-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [16, 36],
    "typing": [1, 11],
    "description": "**Alef** is a discontinued concurrent programming language, designed as part of the Plan 9 operating system by Phil Winterbottom of Bell Labs. It implemented the channel-based concurrency model of Newsqueak in a compiled, C-like language."
  },
  "27": {
    "label": "Algebraic Logic Functional programming language",
    "wikipedia_pageid": 11868019,
    "inception": null,
    "paradigm": [28, 21],
    "typing": [],
    "description": "**Algebraic Logic Functional programming language**, also known as **ALF**, is a programming language which combines functional and logic programming techniques. Its foundation is Horn clause logic with equality which consists of predicates and Horn clauses for logic programming, and functions and equations for functional programming. ALF was designed to be genuine integration of both programming paradigms, and thus any functional expression can be used in a goal literal and arbitrary predicates can occur in conditions of equations. ALF's operational semantics is based on the resolution rule to solve literals and narrowing to evaluate functional expressions. In order to reduce the number of possible narrowing steps, a leftmost-innermost basic narrowing strategy is used which, it is claimed, can be efficiently implemented. Terms are simplified by rewriting before a narrowing step is applied and equations are rejected if the two sides have different constructors at the top. Rewriting and rejection are supposed to result in a large reduction of the search tree and produce an operational semantics that is more efficient than Prolog's resolution strategy. Similarly to Prolog, ALF uses a backtracking strategy corresponding to a depth-first search in the derivation tree. The ALF system was designed to be an efficient implementation of the combination of resolution, narrowing, rewriting, and rejection. ALF programs are compiled into instructions of an abstract machine. The abstract machine is based on the Warren Abstract Machine (WAM) with several extensions to implement narrowing and rewriting. In the current ALF implementation programs of this abstract machine are executed by an emulator written in C. In the Carnegie Mellon University Artificial Intelligence Repository, ALF is included as an AI programming language, in particular as a functional/logic programming language Prolog implementation. A user manual describing the language and the use of the system is available. The ALF System runs under Unix and is available under a custom proprietary software license that grants the right to use for \"evaluation, research and teaching purposes\" but not commercial or military use."
  },
  "28": {
    "label": "Alice",
    "wikipedia_pageid": 30877972,
    "inception": { "time": "+2000-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3, 16, 5, 21],
    "typing": [1, 6, 11],
    "description": "**Alice ML** is a programming language designed by the Programming Systems Laboratory at Saarland University, Saarbrücken, Germany. It is a dialect of Standard ML, augmented with support for lazy evaluation, concurrency (multithreading and distributed computing via remote procedure calls) and constraint programming."
  },
  "29": {
    "label": "Alma-0",
    "wikipedia_pageid": 933674,
    "inception": { "time": "+1997-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [28, 2, 3, 5],
    "typing": [11],
    "description": "**Alma-0** is a multi-paradigm computer programming language. This language is an augmented version of the imperative Modula-2 language with logic- programming features and convenient backtracking ability. It is small, strongly typed, and combines constraint programming, a limited number of features inspired by logic programming and supports imperative paradigms. The language advocates declarative programming. The designers claim that search- oriented solutions built with it are substantially simpler than their counterparts written in purely imperative or logic programming style. Alma-0 provides natural, high-level constructs for building search trees."
  },
  "30": {
    "label": "AmbientTalk",
    "wikipedia_pageid": 12036551,
    "inception": { "time": "+2006-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [12, 6, 14, 9, 16],
    "typing": [10, 1],
    "description": "**AmbientTalk** is an experimental object-oriented distributed programming language developed at the Programming Technology Laboratory at the Vrije Universiteit Brussel, Belgium. The language is primarily targeted at writing programs deployed in mobile ad hoc networks. AmbientTalk is meant to serve as an _experimentation platform_ to experiment with new language features or programming abstractions to facilitate the construction of software that has to run in highly volatile networks exhibiting intermittent connectivity and little infrastructure. It is implemented in Java which enables interpretation on various platforms, including Android. The interpreter standard library also provides a seamless interface between Java and AmbientTalk objects, called the symbiosis. The language's concurrency features, which include support for futures and event-loop concurrency, are founded on the actor model and have been largely influenced by the E programming language. The language's object-oriented features find their influence in languages like Smalltalk (i.e. block closures, keyworded messages) and Self (prototype-based programming, traits, delegation)."
  },
  "31": {
    "label": "Amiga E",
    "wikipedia_pageid": 114313,
    "inception": { "time": "+1993-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [],
    "description": "**Amiga E**, or very often simply **E**, is a programming language created by Wouter van Oortmerssen on the Amiga. He has since moved on to develop the SHEEP programming language for the new AmigaDE platform and the CryScript language (also known as DOG) used during the development of the video game Far Cry."
  },
  "32": {
    "label": "AngelScript",
    "wikipedia_pageid": 39538319,
    "inception": { "time": "+2003-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 2, 3],
    "typing": [1, 11],
    "description": "**AngelScript** is a game-oriented compiled scripting language. AngelScript features static typing, object handles (similar to C++ pointers but garbage collected via reference counting), object-orientation, single inheritance, multiple inheritance with interfaces. Allows operators to be registered and overloaded. AngelScript can be used with any C++ IDE, such as NetBeans, Geany, and Eclipse. C and C++ functions can be called within an AngelScript environment. AngelScript's class syntax closely follows C++ classes by design: no proxy functions are required to embed AngelScript in C++ applications easing the two languages integration. There are several differences of AngelScript and C++:   * AngelScript does not support multiple inheritance. Multiple-inheritance functionality may be achieved with Interfaces.   * It is impossible to declare methods or properties outside of the class body.   * All methods (including constructors and destructors) are virtual. AngelScript is used in video game development, including _Amnesia: The Dark Descent_,_Amy_,_Dustforce_,_Gekkeiju Online_,_King Arthur's Gold_,_Legend of the Guardians: The Owls of Ga'Hoole_,_Overgrowth_,_Penumbra: Overture_,_Penumbra: Requiem_,_Puddle_,_Rigs of Rods_,_Sine Mora_,_Star Ruler_,_SuperTuxKart_,_Warhammer: Mark of Chaos_,_Warsow_,_Sven Co-op_,_Jazz Jackrabbit 2 Plus_,_Urho3D_. AngelScript is used at the University of Ulm in interactive 3D-Animation program. AngelScript is also used in robotics, for example, to program behavioral rules of robotic agents."
  },
  "33": {
    "label": "Groovy",
    "wikipedia_pageid": 508401,
    "inception": { "time": "+2003-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 3, 21],
    "typing": [13, 10, 1, 11],
    "description": "**Apache Groovy** is a Java-syntax-compatible object-oriented programming language for the Java platform. It is both a static and dynamic language with features similar to those of Python, Ruby, and Smalltalk. It can be used as both a programming language and a scripting language for the Java Platform, is compiled to Java virtual machine (JVM) bytecode, and interoperates seamlessly with other Java code and libraries. Groovy uses a curly-bracket syntax similar to Java's. Groovy supports closures, multiline strings, and expressions embedded in strings. Much of Groovy's power lies in its AST transformations, triggered through annotations. Groovy 1.0 was released on January 2, 2007, and Groovy 2.0 in July, 2012. Since version 2, Groovy can be compiled statically, offering type inference and performance near that of Java. Groovy 2.4 was the last major release under Pivotal Software's sponsorship which ended in March 2015. Groovy has since changed its governance structure to a Project Management Committee in the Apache Software Foundation."
  },
  "34": {
    "label": "App Inventor for Android",
    "wikipedia_pageid": 28015549,
    "inception": { "time": "+2010-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [10],
    "typing": [],
    "description": "**MIT App Inventor** is a web application integrated development environment originally provided by Google, and now maintained by the Massachusetts Institute of Technology (MIT). It allows newcomers to computer programming to create application software(apps) for two operating systems (OS): Android, and iOS, which, as of 8 July 2019, is in final beta testing. It is free and open- source software released under dual licensing: a Creative Commons Attribution ShareAlike 3.0 Unported license, and an Apache License 2.0 for the source code. It uses a graphical user interface (GUI) very similar to the programming languages Scratch (programming language) and the StarLogo, which allows users to drag and drop visual objects to create an application that can run on android devices, while a App-Inventor Companion (The program that allows the app to run and debug on) that works on iOS running devices are still under development. In creating App Inventor, Google drew upon significant prior research in educational computing, and work done within Google on online development environments. App Inventor and the other projects are based on and informed by constructionist learning theories, which emphasize that programming can be a vehicle for engaging powerful ideas through active learning. As such, it is part of an ongoing movement in computers and education that began with the work of Seymour Papert and the MIT Logo Group in the 1960s, and has also manifested itself with Mitchel Resnick's work on Lego Mindstorms and StarLogo. App Inventor also supports the use of cloud data via an experimental Firebase#Firebase Realtime Database component."
  },
  "35": {
    "label": "AppleScript",
    "wikipedia_pageid": 88392,
    "inception": { "time": "+1993-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [8],
    "typing": [10, 2],
    "description": "**AppleScript** is a scripting language created by Apple Inc. that facilitates automated control over scriptable Mac applications. First introduced in System 7, it is currently included in all versions of macOS as part of a package of system automation tools. The term \"AppleScript\" may refer to the language itself, to an individual script written in the language, or, informally, to the macOS Open Scripting Architecture that underlies the language."
  },
  "36": {
    "label": "Arc",
    "wikipedia_pageid": 188190,
    "inception": { "time": "+2008-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [25, 2, 21],
    "typing": [10],
    "description": "**Arc** is a programming language, a dialect of the language Lisp, developed by Paul Graham and Robert Morris. It is free and open-source software released under the Artistic License 2.0."
  },
  "37": {
    "label": "Assembly language",
    "wikipedia_pageid": 1368,
    "inception": { "time": "+1949-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "In computer programming,**assembly language** (or **assembler language**), sometimes abbreviated **asm**, is any low-level programming language in which there is a very strong correspondence between the instructions in the language and the architecture's machine code instructions. Because assembly depends on the machine code instructions, every assembly language is designed for exactly one specific computer architecture. Assembly language may also be called _symbolic machine code_. Assembly code is converted into executable machine code by a utility program referred to as an _assembler_. The conversion process is referred to as _assembly_, as in _assembling_ the source code. Assembly language usually has one statement per machine instruction (1:1), but constants, comments, assembler directives, symbolic labels of program and memory locations, and macros are generally also supported. The term \"assembler\" is generally attributed to Wilkes, Wheeler and Gill in their 1951 book _The Preparation of Programs for an Electronic Digital Computer_, who, however, used the term to mean \"a program that assembles another program consisting of several sections into a single program\". Each assembly language is specific to a particular computer architecture and sometimes to an operating system. However, some assembly languages do not provide specific syntax for operating system calls, and most assembly languages can be used universally with any operating system, as the language provides access to all the real capabilities of the processor, upon which all system call mechanisms ultimately rest. In contrast to assembly languages, most high-level programming languages are generally portable across multiple architectures but require interpreting or compiling, a much more complicated task than assembling. The computational step when an assembler is processing a program is called _assembly time_."
  },
  "38": {
    "label": "AutoIt",
    "wikipedia_pageid": 2281448,
    "inception": { "time": "+1999-01-01T00:00:00Z", "precision": 10 },
    "paradigm": [2, 3, 21, 6, 9],
    "typing": [],
    "description": "**AutoIt** is a freeware programming language for Microsoft Windows. In its earliest release, it was primarily intended to create automation scripts (sometimes called macros) for Microsoft Windows programs but has since grown to include enhancements in both programming language design and overall functionality. The scripting language in AutoIt 1 and 2 was statement-driven and designed primarily for simulating user interaction. From version 3 onward, the AutoIt syntax is similar to that found in the BASIC family of languages. In this form, AutoIt is a general-purpose, third-generation programming language with a classical data model and a variant data type that can store several types of data, including arrays. An AutoIt automation script can be converted into a compressed, stand-alone executable which can be run on computers even if they do not have the AutoIt interpreter installed. A wide range of function libraries (known as UDFs, or \"User Defined Functions\") are also included as standard or are available from the website to add specialized functionality. AutoIt is also distributed with an IDE based on the free SciTE editor. The compiler and help text are fully integrated and provide a _de facto_ standard environment for developers using AutoIt."
  },
  "39": {
    "label": "AutoLISP",
    "wikipedia_pageid": 51458,
    "inception": { "time": "+1986-01-01T00:00:00Z", "precision": 10 },
    "paradigm": [],
    "typing": [10],
    "description": "**AutoLISP** is a dialect of the programming language Lisp built specifically for use with the full version of AutoCAD and its derivatives, which include _AutoCAD Map 3D_,_AutoCAD Architecture_ and _AutoCAD Mechanical_. Neither the application programming interface (API) nor the interpreter to execute AutoLISP code are included in the AutoCAD LT product line."
  },
  "40": {
    "label": "Axum",
    "wikipedia_pageid": 22433033,
    "inception": { "time": "+2009-05-08T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [],
    "description": "**Axum** (previously codenamed **Maestro**) is a domain-specific concurrent programming language, based on the Actor model, that was under active development by Microsoft between 2009 and 2011. It is an object-oriented language based on the .NET Common Language Runtime using a C-like syntax which, being a domain-specific language, is intended for development of portions of a software application that is well-suited to concurrency. But it contains enough general-purpose constructs that one need not switch to a general-purpose programming language (like C#) for the sequential parts of the concurrent components. The main idiom of programming in Axum is an _Agent_ (or an _Actor_), which is an isolated entity that executes in parallel with other Agents. In Axum parlance, this is referred to as the agents executing in separate _isolation domains_ ; objects instantiated within a domain cannot be directly accessed from another. Agents are loosely coupled (i.e., the number of dependencies between agents is minimal) and do not share resources like memory (unlike the shared memory model of C# and similar languages); instead a message passing model is used. To co-ordinate agents or having an agent request the resources of another, an explicit message must be sent to the agent. Axum provides _Channels_ to facilitate this. _Channels_ can be regarded as a directional pathway to communicate between agent instances. The member functions of a _Channel_ object, after it has been bound to an agent instance, can be used to communicate with it. A _Channel_ contains input and output _ports_, which are queues which are used to send data to an agent or receive data from one. To co-ordinate the communication between agents, Axum allows each channel to have a user-defined _protocol_ for communication. The protocol is defined as a state machine. The data sent over a channel can be optionally restricted to conform to a certain pre-defined _schema_. The compiler and runtime will enforce the conformance with the schema. Under the hood, a _schema_ is translated into a serializable .NET class that contains only properties and side effect-free methods. The Axum project reached the state of a prototype with working Microsoft Visual Studio integration. Microsoft had made a CTP of Axum available to the public, but this has since been removed. Although Microsoft decided not to turn Axum into a project, some of the ideas behind Axum are used in TPL Dataflow in .Net 4.5."
  },
  "41": {
    "label": "B",
    "wikipedia_pageid": 4475,
    "inception": { "time": "+1969-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2],
    "typing": [],
    "description": "**B** is a programming language developed at Bell Labs circa 1969. It was developed by Ken Thompson and Dennis Ritchie. B was derived from BCPL, and its name may possibly be a contraction of BCPL. Thompson's coworker Dennis Ritchie speculated that the name might be based on Bon, an earlier, but unrelated, programming language that Thompson designed for use on Multics. B was designed for recursive, non-numeric, machine-independent applications, such as system and language software. It was a typeless language, with the only data type being the underlying machine's natural memory word format, whatever that might be. Depending on the context, the word was treated either as an integer or a memory address. As machines with ASCII processing became common, notably the DEC PDP-11 that arrived at Bell, support for character data stuffed in memory words became important. The typeless nature of the language was seen as a disadvantage, which led Thompson and Ritchie to develop an expanded version of the language supporting new internal and user-defined types, which became the C programming language."
  },
  "42": {
    "label": "BASIC",
    "wikipedia_pageid": 4015,
    "inception": { "time": "+1964-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 2, 3],
    "typing": [],
    "description": "**BASIC** (**Beginners' All-purpose Symbolic Instruction Code**) is a family of general-purpose, high-level programming languages whose design philosophy emphasizes ease of use. The original version was designed by John G. Kemeny and Thomas E. Kurtz and released at Dartmouth College in 1964. They wanted to enable students in fields other than science and mathematics to use computers. At the time, nearly all use of computers required writing custom software, which was something only scientists and mathematicians tended to learn. In addition to the language itself, Kemeny and Kurtz developed the Dartmouth Time Sharing System (DTSS), which allowed multiple users to edit and run BASIC programs at the same time. This general model became very popular on minicomputer systems like the PDP-11 and Data General Nova in the late 1960s and early 1970s. Hewlett-Packard produced an entire computer line for this method of operation, introducing the HP2000 series in the late 1960s and continuing sales into the 1980s. Many early video games trace their history to one of these versions of BASIC. The emergence of early microcomputers in the mid-1970s led to the development of a number of BASIC dialects, including Microsoft BASIC in 1975. Due to the tiny main memory available on these machines, often 4 kB, a variety of Tiny BASIC dialects was also created. BASIC was available for almost any system of the era, and naturally became the _de facto_ programming language for the home computer systems that emerged in the late 1970s. These machines almost always had a BASIC interpreter installed by default, often in the machine's firmware or sometimes on a ROM cartridge. BASIC fell from use in the early 1990s, as newer machines with far greater capabilities came to market and other programming languages (such as Pascal and C) became tenable. In 1991, Microsoft released Visual Basic, combining a greatly updated version of BASIC with a visual forms builder. This reignited use of the language and \"VB\" remains a major programming language in the form of VB.NET."
  },
  "43": {
    "label": "BCPL",
    "wikipedia_pageid": 4052,
    "inception": { "time": "+1967-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 36],
    "typing": [],
    "description": "**BCPL** (\"**Basic Combined Programming Language**\") is a procedural, imperative, and structured programming language. Originally intended for writing compilers for other languages, BCPL is no longer in common use. However, its influence is still felt because a stripped down and syntactically changed version of BCPL, called B, was the language on which the C programming language was based. BCPL introduced several features of many modern programming languages, including using curly braces to delimit code blocks. BCPL was first implemented by Martin Richards of the University of Cambridge in 1967."
  },
  "44": {
    "label": "BETA",
    "wikipedia_pageid": 135868,
    "inception": { "time": "+1992-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [11],
    "description": "**BETA** is a pure object-oriented language originating within the \"Scandinavian School\" in object-orientation where the first object-oriented language Simula was developed. Among its notable features, it introduced nested classes, and unified classes with procedures into so called patterns. The project is inactive as of October 2020."
  },
  "45": {
    "label": "BLISS",
    "wikipedia_pageid": 390261,
    "inception": { "time": "+1970-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 36],
    "typing": [],
    "description": "**BLISS** is a system programming language developed at Carnegie Mellon University by W. A. Wulf, D. B. Russell, and A. N. Habermann around 1970. It was perhaps the best known systems programming language right up until C made its debut a few years later. Since then, C took off and BLISS faded into obscurity. When C was in its infancy, a few projects within Bell Labs were debating the merits of BLISS vs. C. BLISS is a typeless block-structured language based on expressions rather than statements, and includes constructs for exception handling, coroutines, and macros. It does not include a goto statement. The name is variously said to be short for \"Basic Language for Implementation of System Software\" or \"System Software Implementation Language, Backwards\". It was sometimes called \"Bill's Language for Implementing System Software\", after Bill Wulf. The original Carnegie Mellon compiler was notable for its extensive use of optimizations, and formed the basis of the classic book _The Design of an Optimizing Compiler_. DEC developed and maintained BLISS compilers for the PDP-10, PDP-11, VAX, DEC PRISM, MIPS, DEC Alpha, and Intel IA-32, The language did not become popular among customers and few had the compiler, but DEC used it heavily in-house into the 1980s; most of the utility programs for the VMS operating system were written in BLISS-32. After its acquisition of DEC, Compaq developed and maintained a BLISS compiler for Intel IA-64."
  },
  "46": {
    "label": "Babbage",
    "wikipedia_pageid": 22848897,
    "inception": { "time": "+1971-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 36],
    "typing": [],
    "description": "**Babbage** is the high level assembly language for the GEC 4000 series minicomputers. It was named after Charles Babbage, an English computing pioneer."
  },
  "47": {
    "label": "Ballerina",
    "wikipedia_pageid": 57629994,
    "inception": { "time": "+2017-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [16],
    "typing": [1, 12, 6, 11],
    "description": "**Ballerina** is an open source general-purpose programming language and platform designed by WSO2 for cloud-era application programmers. It is easy to write and modify and is suitable for application programmers. It is an open source project started in 2015 by architects from WSO2 as a code-based alternative to the configuration-based integration tools such as EAI, ESB, and workflow products. It has various constructs geared toward cloud-native development including support for modern data formats and protocols, reliability, distributed transactions, APIs, and event streams."
  },
  "48": {
    "label": "BeanShell",
    "wikipedia_pageid": 1565435,
    "inception": { "time": "+1999-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [10, 1],
    "description": "**BeanShell** is a small, free, embeddable Java source interpreter with object scripting language features, written in Java. It runs in the Java Runtime Environment (JRE), dynamically executes standard Java syntax and extends it with common scripting conveniences such as loose types, commands, and method closures, like those in Perl and JavaScript."
  },
  "49": {
    "label": "Blockly",
    "wikipedia_pageid": 44494473,
    "inception": { "time": "+2012-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**Blockly** is a client-side library for the programming language JavaScript for creating block-based visual programming languages (VPLs) and editors. A project of Google, it is free and open-source software released under the Apache License 2.0. It typically runs in a web browser, and visually resembles the language Scratch. It is also being implemented for the mobile operating systems Android and iOS, though not all of its browser-based features will be available on those platforms. Blockly uses visual blocks that link together to make writing code easier, and can generate code in JavaScript, Lua, Dart, Python, or PHP. It can also be customized to generate code in any textual programming language."
  },
  "50": {
    "label": "Boo",
    "wikipedia_pageid": 1147624,
    "inception": { "time": "+2003-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [6, 13, 1, 11],
    "description": "**Boo** is an object-oriented, statically typed, general-purpose programming language that seeks to make use of the Common Language Infrastructure's support for Unicode, internationalization, and web applications, while using a Python-inspired syntax and a special focus on language and compiler extensibility. Some features of note include type inference, generators, multimethods, optional duck typing, macros, true closures, currying, and first-class functions. Boo was one of the three scripting languages for the Unity game engine (Unity Technologies employed De Oliveira, its designer), until it was dropped in 2014 due to the small userbase. Despite official support for Boo ending, the language could still be used in Unity, until the Boo compiler was removed from the engine in 2017. Boo is free software released under the BSD 3-Clause license. It is compatible with the Microsoft .NET and Mono frameworks."
  },
  "51": {
    "label": "Boomerang",
    "wikipedia_pageid": 21008097,
    "inception": { "time": "+2008-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**Boomerang** is a programming language for writing lenses—well-behaved bidirectional transformations —that operate on ad-hoc, textual data formats. Boomerang grew out of the Harmony generic data synchronizer, which grew out of the Unison file synchronization project."
  },
  "52": {
    "label": "Bosque",
    "wikipedia_pageid": 60532073,
    "inception": { "time": "+2019-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [21],
    "typing": [11],
    "description": "**Bosque** is a free and open-source programming language developed by Microsoft that was inspired by the syntax and types of TypeScript and the semantics of ML and Node/JavaScript. Design goals for the language include better software quality and improved developer productivity."
  },
  "53": {
    "label": "C",
    "wikipedia_pageid": 6021,
    "inception": { "time": "+1972-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 36],
    "typing": [14, 2],
    "description": "**C** (, as in the letter _c_) is a general-purpose, procedural computer programming language supporting structured programming, lexical variable scope, and recursion, with a static type system. By design, C provides constructs that map efficiently to typical machine instructions. It has found lasting use in applications previously coded in assembly language. Such applications include operating systems and various application software for computer architectures that range from supercomputers to PLCs and embedded systems. A successor to the programming language _B_, C was originally developed at Bell Labs by Dennis Ritchie between 1972 and 1973 to construct utilities running on Unix. It was applied to re-implementing the kernel of the Unix operating system. During the 1980s, C gradually gained popularity. It has become one of the most widely used programming languages, with C compilers from various vendors available for the majority of existing computer architectures and operating systems. C has been standardized by ANSI since 1989 (ANSI C) and by the International Organization for Standardization (ISO). C is an imperative procedural language. It was designed to be compiled to provide low-level access to memory and language constructs that map efficiently to machine instructions, all with minimal runtime support. Despite its low-level capabilities, the language was designed to encourage cross- platform programming. A standards-compliant C program written with portability in mind can be compiled for a wide variety of computer platforms and operating systems with few changes to its source code. As of January 2021, C was ranked first in the TIOBE index, a measure of the popularity of programming languages, moving up from the no. 2 spot the previous year."
  },
  "54": {
    "label": "C#",
    "wikipedia_pageid": 2356196,
    "inception": { "time": "+2001-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [0, 12, 3, 21, 6, 26, 9, 16, 36],
    "typing": [10, 4, 6],
    "description": "**C#** (_see sharp_) is a general-purpose, multi-paradigm programming language encompassing static typing, strong typing, lexically scoped, imperative, declarative, functional, generic, object-oriented (class-based), and component-oriented programming disciplines. C# was developed around 2000 by Microsoft as part of its .NET initiative and later approved as an international standard by Ecma (ECMA-334) in 2002 and ISO (ISO/IEC 23270) in 2003. It was designed by Anders Hejlsberg, and its development team is currently led by Mads Torgersen, being one of the programming languages designed for the Common Language Infrastructure (CLI). The most recent version is 9.0, which was released in 2020 in .NET 5.0 and included in Visual Studio 2019 version 16.8. Mono is a free and open-source project to develop a cross-platform compiler and runtime environment (i.e. virtual machine) for the language."
  },
  "55": {
    "label": "C*",
    "wikipedia_pageid": 1064175,
    "inception": { "time": "+1987-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 3, 7],
    "typing": [11, 14, 2],
    "description": "**C*** (or C-star) is an object-oriented, data-parallel superset of ANSI C with synchronous semantics."
  },
  "56": {
    "label": "C++",
    "wikipedia_pageid": 72038,
    "inception": { "time": "+1983-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 2, 26, 21],
    "typing": [8, 4, 11],
    "description": "**C++** () is a general-purpose programming language created by Bjarne Stroustrup as an extension of the C programming language, or \"C with Classes\". The language has expanded significantly over time, and modern C++ now has object-oriented, generic, and functional features in addition to facilities for low-level memory manipulation. It is almost always implemented as a compiled language, and many vendors provide C++ compilers, including the Free Software Foundation, LLVM, Microsoft, Intel, Oracle, and IBM, so it is available on many platforms. C++ was designed with an orientation toward system programming and embedded, resource-constrained software and large systems, with performance, efficiency, and flexibility of use as its design highlights. C++ has also been found useful in many other contexts, with key strengths being software infrastructure and resource-constrained applications, including desktop applications, video games, servers (e.g. e-commerce, web search, or databases), and performance-critical applications (e.g. telephone switches or space probes). C++ is standardized by the International Organization for Standardization (ISO), with the latest standard version ratified and published by ISO in December 2020 as _ISO/IEC 14882:2020_ (informally known as C++20). The C++ programming language was initially standardized in 1998 as _ISO/IEC 14882:1998_, which was then amended by the C++03, C++11, C++14, and C++17 standards. The current C++20 standard supersedes these with new features and an enlarged standard library. Before the initial standardization in 1998, C++ was developed by Danish computer scientist Bjarne Stroustrup at Bell Labs since 1979 as an extension of the C language; he wanted an efficient and flexible language similar to C that also provided high-level features for program organization. Since 2012, C++ has been on a three-year release schedule with C++23 as the next planned standard."
  },
  "57": {
    "label": "C--",
    "wikipedia_pageid": 1422467,
    "inception": { "time": "+1997-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3],
    "typing": [11, 2],
    "description": "**C--** (pronounced _C minus minus_) is a C-like programming language. Its creators, functional programming researchers Simon Peyton Jones and Norman Ramsey, designed it to be generated mainly by compilers for very high-level languages rather than written by human programmers. Unlike many other intermediate languages, its representation is plain ASCII text, not bytecode or another binary format. There are two main branches:   * C--, the original branch, with the final version 2.0 released in May 2005   * Cmm, the fork actively used as the intermediate representation (IR) in the Glasgow Haskell Compiler (GHC)"
  },
  "58": {
    "label": "C/AL",
    "wikipedia_pageid": 13281075,
    "inception": null,
    "paradigm": [3],
    "typing": [],
    "description": "**C/AL** (**C** lient **/** server **A** pplication **L** anguage) was the programming language used within C/SIDE the **C** lient **/S** erver **I** ntegrated **D** evelopment **E** nvironment in Microsoft Dynamics NAV (Formerly known as Navision Attain) and Microsoft Dynamics 365 Business Central up until (and including) version 14. It has been replaced by AL. C/AL is a Database specific programming language, and is primarily used for retrieving, inserting and modifying records in a Navision database. C/AL resembles the Pascal language on which it is based. The original C/AL compiler was written by Michael Nielsen."
  },
  "59": {
    "label": "CDuce",
    "wikipedia_pageid": 5763798,
    "inception": null,
    "paradigm": [21],
    "typing": [],
    "description": "**CDuce** is an XML-oriented functional language, which extends XDuce in a few directions. It features XML regular expression types, XML regular expression patterns, XML iterators. CDuce is not strictly speaking an XML transformation language since it can be used for general-purpose programming. CDuce conforms to basic standards: Unicode, XML, DTD, Namespaces are fully supported, XML Schema is partially supported."
  },
  "60": {
    "label": "CHILL",
    "wikipedia_pageid": 765313,
    "inception": { "time": "+1980-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2],
    "typing": [1, 11],
    "description": "In computing,**CHILL** (an acronym for **CCITT High Level Language**) is a procedural programming language designed for use in telecommunication switches (the hardware used inside telephone exchanges). The language is still used for legacy systems in some telecommunication companies and for signal box programming. The CHILL language is similar in size and complexity to the original Ada language. The first specification of the CHILL language was published in 1980, a few years before Ada. ITU provides a standard CHILL compiler. A free CHILL compiler was bundled with GCC up to version 2.95, however, was removed from later versions. An object- oriented version, called Object CHILL, was developed also. ITU is responsible for the CHILL standard, known as ITU-T Rec. Z.200. The equivalent ISO standard is ISO/IEC 9496:2003. (The text of the two documents is the same). In late 1999 CCITT stopped maintaining the CHILL standard. CHILL was used in systems of Alcatel System 12 and Siemens EWSD, for example."
  },
  "61": {
    "label": "CHIP-8",
    "wikipedia_pageid": 1119698,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**CHIP-8** is an interpreted programming language, developed by Joseph Weisbecker. It was initially used on the COSMAC VIP and Telmac 1800 8-bit microcomputers in the mid-1970s. CHIP-8 programs are run on a CHIP-8 virtual machine. It was made to allow video games to be more easily programmed for these computers. Roughly fifteen years after CHIP-8 was introduced, derived interpreters appeared for some models of graphing calculators (from the late 1980s onward, these handheld devices in many ways have more computing power than most mid-1970s microcomputers for hobbyists). An active community of users and developers existed in the late 1970s, beginning with ARESCO's \"VIPer\" newsletter whose first three issues revealed the machine code behind the CHIP-8 interpreter."
  },
  "62": {
    "label": "CLIPS",
    "wikipedia_pageid": 418603,
    "inception": { "time": "+1985-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [],
    "description": "**CLIPS** is a public domain software tool for building expert systems. The name is an acronym for \"C Language Integrated Production System.\" The syntax and name were inspired by Charles Forgy's OPS5. The first versions of CLIPS were developed starting in 1985 at NASA-Johnson Space Center (as an alternative for existing system ART*Inference) until the mid-1990s when the development group's responsibilities ceased to focus on expert system technology. The original name of the project was _NASA's AI Language_ (_NAIL_). CLIPS is probably the most widely used expert system tool. CLIPS itself is written in C, extensions can be written in C, and CLIPS can be called from C. Its syntax resembles that of the programming language Lisp. CLIPS incorporates a complete object-oriented language for writing expert systems. COOL combines the programming paradigms of procedural, object oriented and logical (theorem proving) languages."
  },
  "63": {
    "label": "CLIST",
    "wikipedia_pageid": 391542,
    "inception": null,
    "paradigm": [2],
    "typing": [],
    "description": "**CLIST (Command List)** (pronounced \"C-List\") is a procedural programming language for TSO in MVS systems. It originated in OS/360 Release 20 and has assumed a secondary role since the availability of Rexx in TSO/E Version 2. The term CLIST is also used for command lists written by users of NetView. In its basic form, a CLIST program (or \"CLIST\" for short) can take the form of a simple list of commands to be executed in strict sequence (like a DOS batch file (*.bat) file). However, CLIST also features If-Then-Else logic as well as loop constructs. CLIST is an interpreted language. That is, the computer must translate a CLIST every time the program is executed. CLISTs therefore tend to be slower than programs written in compiled languages such as COBOL, FORTRAN, or PL/1. (A program written in a compiled language is translated once to create a \"load module\" or executable.) CLIST can read/write MVS files and read/write from/to a TSO terminal. It can read parameters from the caller and also features a function to hold global variables and pass them between CLISTs. A CLIST can also call an MVS application program (written in COBOL or PL/I, for example). CLISTs can be run in background (by running JCL which executes the TSO control program (IKJEFT01)). TSO I/O screens and menus using ISPF dialog services can be displayed by CLISTs. Compare the function of CLIST with that provided by REXX."
  },
  "64": {
    "label": "CLU",
    "wikipedia_pageid": 7575,
    "inception": { "time": "+1975-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 2],
    "typing": [1],
    "description": "**CLU** is a programming language created at the Massachusetts Institute of Technology (MIT) by Barbara Liskov and her students between 1974 and 1975. While it did not find extensive use, it introduced many features that are used widely now, and is seen as a step in the development of object-oriented programming (OOP). Key contributions include abstract data types, call-by-sharing, iterators, multiple return values (a form of parallel assignment), type-safe parameterized types, and type-safe variant types. It is also notable for its use of classes with constructors and methods, but without inheritance."
  },
  "65": {
    "label": "CMS-2",
    "wikipedia_pageid": 1181779,
    "inception": { "time": "+1968-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3],
    "typing": [],
    "description": "**CMS-2** is an embedded systems programming language used by the United States Navy. It was an early attempt to develop a standardized high-level computer programming language intended to improve code portability and reusability. CMS-2 was developed primarily for the US Navy’s tactical data systems (NTDS). CMS-2 was developed by RAND Corporation in the early 1970s and stands for \"Compiler Monitor System\". The name \"CMS-2\" is followed in literature by a letter designating the type of target system. For example, CMS-2M targets Navy 16-bit processors, such as the AN/AYK-14."
  },
  "66": {
    "label": "COBOL",
    "wikipedia_pageid": 6799,
    "inception": { "time": "+1959-05-28T00:00:00Z", "precision": 11 },
    "paradigm": [6, 2, 3],
    "typing": [11, 2],
    "description": "**COBOL** (; an acronym for \"common business-oriented language\") is a compiled English-like computer programming language designed for business use. It is an imperative, procedural and, since 2002, object-oriented language. COBOL is primarily used in business, finance, and administrative systems for companies and governments. COBOL is still widely used in applications deployed on mainframe computers, such as large-scale batch and transaction processing jobs. However, due to its declining popularity and the retirement of experienced COBOL programmers, programs are being migrated to new platforms, rewritten in modern languages or replaced with software packages. Most programming in COBOL is now purely to maintain existing applications; however, many large financial institutions were still developing new systems in COBOL as late as 2006. COBOL was designed in 1959 by CODASYL and was partly based on the programming language FLOW-MATIC designed by Grace Hopper. It was created as part of a US Department of Defense effort to create a portable programming language for data processing. It was originally seen as a stopgap, but the Department of Defense promptly forced computer manufacturers to provide it, resulting in its widespread adoption. It was standardized in 1968 and has since been revised four times. Expansions include support for structured and object-oriented programming. The current standard is _ISO/IEC 1989:2014_. COBOL statements have an English-like syntax, which was designed to be self- documenting and highly readable. However, it is verbose and uses over 300 reserved words. In contrast with modern, succinct syntax like `y = x;`, COBOL has a more English-like syntax (in this case, `MOVE x TO y`). COBOL code is split into four _divisions_ (identification, environment, data, and procedure) containing a rigid hierarchy of sections, paragraphs and sentences. Lacking a large standard library, the standard specifies 43 statements, 87 functions and just one class. Academic computer scientists were generally uninterested in business applications when COBOL was created and were not involved in its design; it was (effectively) designed from the ground up as a computer language for business, with an emphasis on inputs and outputs, whose only data types were numbers and strings of text. COBOL has been criticized throughout its life for its verbosity, design process, and poor support for structured programming. These weaknesses result in monolithic, verbose (intended to be English-like) programs that are not easily comprehensible."
  },
  "67": {
    "label": "COMAL",
    "wikipedia_pageid": 197700,
    "inception": { "time": "+1975-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 36],
    "typing": [1],
    "description": "**COMAL** (_Common Algorithmic Language_) is a computer programming language developed in Denmark by Børge R. Christensen and Benedict Løfstedt and originally released in 1975. COMAL was one of the few structured programming languages that was available for and comfortably usable on 8-bit home computers. It was based on the seminal BASIC programming language, adding multi-line statements and well-defined subroutines among other additions. \"COMAL Kernel Syntax & Semantics\" contains the formal definition of the language. Further extensions are common to many implementations."
  },
  "68": {
    "label": "COMIT",
    "wikipedia_pageid": 1012894,
    "inception": { "time": "+1957-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**COMIT** was the first string processing language (compare SNOBOL, TRAC, and Perl), developed on the IBM 700/7000 series computers by Dr. Victor Yngve and collaborators at MIT from 1957 to 1965. Yngve created the language for supporting computerized research in the field of linguistics, and more specifically, the area of machine translation for natural language processing. The creation of COMIT led to the creation of SNOBOL."
  },
  "69": {
    "label": "COMTRAN",
    "wikipedia_pageid": 4292196,
    "inception": { "time": "+1957-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2],
    "typing": [],
    "description": "**COMTRAN** (COMmercial TRANslator) is an early programming language developed at IBM. It was intended as the business programming equivalent of the scientific programming language FORTRAN (FORmula TRANslator). It served as one of the forerunners to the COBOL language. Developed by Bob Bemer, in 1957, the language was the first to feature the programming language element known as a picture clause."
  },
  "70": {
    "label": "COWSEL",
    "wikipedia_pageid": 94451,
    "inception": { "time": "+1964-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**COWSEL** (_COntrolled Working SpacE Language_) is a programming language designed between 1964 and 1966 by Robin Popplestone. It was based on an RPN form of Lisp combined with some ideas from CPL. COWSEL was initially implemented on a Ferranti Pegasus computer at the University of Leeds and on a Stantec Zebra at the Bradford Institute of Technology; later, Rod Burstall implemented it on an Elliot 4120 at the University of Edinburgh. COWSEL was renamed **POP-1** during the summer of 1966 and development continued under that name from then on."
  },
  "71": {
    "label": "CPL",
    "wikipedia_pageid": 828614,
    "inception": { "time": "+1963-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 21, 36],
    "typing": [],
    "description": "**CPL** (**Combined Programming Language**) is a multi-paradigm programming language, that was developed in the early 1960s. It is an early ancestor of the C language via the BCPL and B languages."
  },
  "72": {
    "label": "Caché ObjectScript",
    "wikipedia_pageid": 2242790,
    "inception": { "time": "+1997-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [],
    "description": "**Caché ObjectScript** is a part of the Caché database system sold by InterSystems. The language is a functional superset of the ANSI-standard MUMPS programming language. Since Caché is at its core a MUMPS implementation, it can run ANSI MUMPS routines with no change. To appeal as a commercial product, Caché implements support for object-oriented programming, a macro preprocessing language, embedded SQL for ANSI-standard SQL access to M's built-in database, procedure and control blocks using C-like brace syntax, procedure-scoped variables, and relaxed whitespace syntax limitations. The language has private and public variables and globals. Global has a different meaning in this language than in most; such variables are global across routines, processes, and sessions. Thus, editing a global variable is making permanent and immediate changes to a system-universal database (which survives reboots, etc.). The scope of a private variable is the local function, the scope of a public variable is the entire process. Variables, private and public, may be single elements or complete multi-dimensional arrays. The great majority of Caché's feature-set is inherited from the ANSI MUMPS standard. See that article for details on how data is represented and the different ways a programmer can think about the data during development."
  },
  "73": {
    "label": "Caml",
    "wikipedia_pageid": 2362118,
    "inception": { "time": "+1985-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3, 21],
    "typing": [1, 6, 11],
    "description": "**Caml** (originally an acronym for **Categorical Abstract Machine Language**) is a multi-paradigm, general-purpose programming language which is a dialect of the ML programming language family. Caml was developed in France at INRIA and ENS. Caml is statically typed, strictly evaluated, and uses automatic memory management. OCaml, the main descendant of Caml, adds many features to the language, including an object layer."
  },
  "74": {
    "label": "Cecil",
    "wikipedia_pageid": 527946,
    "inception": { "time": "+1992-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [10, 11],
    "description": "**Cecil** is a pure object-oriented programming language that was developed by Craig Chambers at the University of Washington in 1992 to be part of the Vortex project there. Cecil has many similarities to other object-oriented languages, most notably Objective-C, Modula-3, and Self. The main goals of the project were extensibility, orthogonality, efficiency, and ease-of-use. The language supports multiple dispatch and multimethods, dynamic inheritance, and optional static type checking. Unlike most other OOP systems, Cecil allows subtyping and code inheritance to be used separately, allowing run-time or external extension of object classes or instances. Like Objective-C, all object services in Cecil are invoked by message passing, and the language supports run-time class identification. These features allow Cecil to support dynamic, exploratory programming styles. Parameterized types and methods (generics, polymorphism), garbage collection, and delegation are also supported. Cecil also supports a module mechanism for isolating independent libraries or packages. Cecil does not presently support threads or any other form of concurrency. A standard library for Cecil is also available and includes various collection, utility, system, I/O, and GUI classes. The Diesel language was the successor of Cecil. There was also an assembler type language known as CESIL (Computer Education in Schools Instructional Language) used in the late-1970s developed by ICL. It was quite similar to the later language MASM."
  },
  "75": {
    "label": "Ceylon",
    "wikipedia_pageid": 31483631,
    "inception": { "time": "+2011-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 3, 21],
    "typing": [1, 11],
    "description": "**Ceylon** is an object-oriented, strongly statically typed programming language with an emphasis on immutability, created by Red Hat. Ceylon programs run on the Java virtual machine (JVM), and could be compiled to JavaScript. The language design focuses on source code readability, predictability, toolability, modularity, and metaprogrammability. Important features of Ceylon include:   * A type system enforcing null safety and list element existence at compile time   * Regular syntax and semantics, avoiding special cases and primitively-defined constructs in favor of syntactic sugar   * Support for generic programming and metaprogramming, with reified generics   * Modularity built into the language, based on JBoss modules, interoperable with OSGi and Maven   * powerful tools, including an Eclipse-based IDE The name \"Ceylon\" is an oblique reference to Java, in that Java and Sri Lanka, formerly known as Ceylon, are islands known for growth and export of coffee and tea. In August 2017, Ceylon was donated to the Eclipse Foundation."
  },
  "76": {
    "label": "Chapel",
    "wikipedia_pageid": 6776794,
    "inception": { "time": "+2009-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 20, 7],
    "typing": [6, 11],
    "description": "**Chapel**, the **Cascade High Productivity Language**, is a parallel programming language developed by Cray. It is being developed as part of the Cray Cascade project, a participant in DARPA's High Productivity Computing Systems (HPCS) program, which had the goal of increasing supercomputer productivity by the year 2010. It is being developed as an open source project, under version 2 of the Apache license."
  },
  "77": {
    "label": "Charm",
    "wikipedia_pageid": 31915190,
    "inception": { "time": "+1996-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [36],
    "typing": [1, 11],
    "description": "**Charm** is a computer programming language devised in the early 1990s with similarities to the RTL/2, Pascal and C languages in addition to containing some unique features of its own. The Charm language is defined by a context- free grammar amenable to being processed by recursive descent parser as described in seminal books on compiler design. A set of Charm tools including a compiler, assembler and linker released for the Acorn market has been reviewed in Acorn User magazine under the category of programming software. Charm reworked for RISC OS platforms has subsequently been reviewed in Archive magazine. Charm is further described in the e-book _Programming in Charm on the Raspberry Pi_."
  },
  "78": {
    "label": "ChucK",
    "wikipedia_pageid": 478750,
    "inception": { "time": "+2002-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 16],
    "typing": [1],
    "description": "**ChucK** is a concurrent, strongly timed audio programming language for real- time synthesis, composition, and performance, which runs on Linux, Mac OS X, Microsoft Windows, and iOS. It is designed to favor readability and flexibility for the programmer over other considerations such as raw performance. It natively supports deterministic concurrency and multiple, simultaneous, dynamic control rates. Another key feature is the ability to live code; adding, removing, and modifying code on the fly, while the program is running, without stopping or restarting. It has a highly precise timing/concurrency model, allowing for arbitrarily fine granularity. It offers composers and researchers a powerful and flexible programming tool for building and experimenting with complex audio synthesis programs, and real- time interactive control. ChucK was created and chiefly designed by Ge Wang as a graduate student working with Perry R. Cook. ChucK is distributed freely under the terms of the GNU General Public License on Mac OS X, Linux and Microsoft Windows. On iPhone and iPad, ChiP (ChucK for iPhone) is distributed under a limited, closed source license, and is not currently licensed to the public. However, the core team has stated that it would like to explore \"ways to open ChiP by creating a beneficial environment for everyone\"."
  },
  "79": {
    "label": "Cilk",
    "wikipedia_pageid": 945803,
    "inception": { "time": "+1994-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 7, 36],
    "typing": [2, 14, 11],
    "description": "**Cilk**,**Cilk++** and **Cilk Plus** are general-purpose programming languages designed for multithreaded parallel computing. They are based on the C and C++ programming languages, which they extend with constructs to express parallel loops and the fork–join idiom. Originally developed in the 1990s at the Massachusetts Institute of Technology (MIT) in the group of Charles E. Leiserson, Cilk was later commercialized as Cilk++ by a spinoff company, Cilk Arts. That company was subsequently acquired by Intel, which increased compatibility with existing C and C++ code, calling the result Cilk Plus."
  },
  "80": {
    "label": "Claire",
    "wikipedia_pageid": 930956,
    "inception": { "time": "+1994-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 0, 9, 21],
    "typing": [10, 1, 11],
    "description": "**Claire** is a high-level functional and object-oriented programming language with rule processing abilities. It was designed by Yves Caseau at Bouygues' e-Lab research laboratory, and received its final definition in 2004. Claire provides:   * a simple object system with parametric classes and methods   * polymorphic and parametric functional programming   * production rules triggered by events   * versioned snapshots of the state of the whole system, or any part, supporting rollback and easy exploration of search spaces   * explicit relations between entities; for example, two entities might be declared inverses of one another   * first-class sets with convenient syntax for set-based programming   * an expressive set-based type system allowing both second-order static and dynamic typing Claire's reference implementation, consisting of an interpreter and compiler, was fully open-sourced with the release of version 3.3.46 in February 2009. Another implementation, WebClaire, is commercially supported."
  },
  "81": {
    "label": "Clarion",
    "wikipedia_pageid": 508614,
    "inception": { "time": "+1986-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 3, 36],
    "typing": [],
    "description": "**Clarion** is a commercial, proprietary, fourth-generation programming language (4GL), multi-paradigm, programming language and integrated development environment (IDE) from SoftVelocity used to program database applications. It is compatible with _indexed sequential access method_ (ISAM),_Structured Query Language_ (SQL), and _ActiveX Data Objects_ (ADO) data access methods, reads and writes several flat file desktop database formats including ASCII, comma-separated values (CSV), DOS (binary), FoxPro, Clipper, dBase, and some relational databases via ODBC, Microsoft SQL Server, Sybase SQL Anywhere, and Oracle Database through the use of accelerated native database drivers, and XML, Clarion can be used to output to HTML, XML, plain text, and Portable Document Format (PDF), among others. The Clarion development environment (IDE) runs on the Clarion language. The IDE provides code generation facilities via a system of templates which allow programmers to describe the program from an abstract level higher than code statements. The generator then turns this higher level into code, which in turn is then compiled and linked using a normal compiler and linker. This generation layer is sometimes referred to as 4GL programming. Using the generation layer is optional. It is possible to create programs fully at the code level (the so-called 3GL layer), bypassing all code generation facilities. If the templates are used to generate code, then programmers are able to inject their own code into the generated code to alter, or extend, the functions offered by the template layer. This process of embedding code can be done while viewing the surrounding generated code. This mixing of template code and generated code allows the template settings to be updated, and the code regenerated, without loss of the embedded code. The templates (from which the code is generated) are provided in source form and developers are free to create their own templates. Many templates have been written by various developers: some are offered as commercial add-ons, and some are free. Three main Clarion products exist: Professional Edition, Enterprise Edition, and .NET."
  },
  "82": {
    "label": "Clean",
    "wikipedia_pageid": 161878,
    "inception": { "time": "+1987-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [29, 21],
    "typing": [10, 1],
    "description": "**Clean** is a general-purpose purely functional computer programming language. For much of the language's active development history it was called **Concurrent Clean**, but this was dropped at some point. Clean is being developed by a group of researchers from the Radboud University in Nijmegen since 1987."
  },
  "83": {
    "label": "Clipper",
    "wikipedia_pageid": 246367,
    "inception": { "time": "+1985-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**Clipper** is an xBase compiler that implements a variant of the _xBase_ computer programming language. It is used to create or extend software programs that originally operated primarily under MS-DOS. Although it is a powerful general-purpose programming language, it was primarily used to create database/business programs. One major dBase feature not implemented in Clipper is the dot-prompt (. prompt) interactive command set, which was an important part of the original dBase implementation. Clipper, from Nantucket Corp and later Computer Associates, started out as a native code compiler for dBase III databases, and later evolved."
  },
  "84": {
    "label": "Clojure",
    "wikipedia_pageid": 16561990,
    "inception": { "time": "+2007-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [28, 19, 16, 21],
    "typing": [10, 1],
    "description": "**Clojure** (, like _closure_) is a dynamic and functional dialect of the Lisp programming language on the Java platform. Like other Lisp dialects, Clojure treats code as data and has a Lisp macro system. The current development process is community-driven, overseen by Rich Hickey as its benevolent dictator for life (BDFL). Clojure advocates immutability and immutable data structures and encourages programmers to be explicit about managing identity and its states. This focus on programming with immutable values and explicit progression-of-time constructs is intended to facilitate developing more robust, especially concurrent, programs that are simple and fast. While its type system is entirely dynamic, recent efforts have also sought the implementation of gradual typing. Commercial support for Clojure is provided by Cognitect. Clojure conferences are organized every year across the globe, the most famous of them being Clojure/conj."
  },
  "85": {
    "label": "Cobra",
    "wikipedia_pageid": 13862555,
    "inception": { "time": "+2006-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 21],
    "typing": [6, 10, 1, 11],
    "description": "**Cobra** is a discontinued general-purpose, object-oriented programming language. Cobra is designed by Charles Esterbrook, and runs on the Microsoft .NET and Mono platforms. It is strongly influenced by Python, C#, Eiffel, Objective-C, and other programming languages. It supports both static and dynamic typing. It has support for unit tests and contracts. It has lambda expressions, closures, list comprehensions, and generators. Cobra is an open-source project; it was released under the MIT License on February 29, 2008."
  },
  "86": {
    "label": "CoffeeScript",
    "wikipedia_pageid": 27403236,
    "inception": { "time": "+2009-12-13T00:00:00Z", "precision": 11 },
    "paradigm": [3, 14, 21],
    "typing": [10],
    "description": "**CoffeeScript** is a programming language that compiles to JavaScript. It adds syntactic sugar inspired by Ruby, Python and Haskell in an effort to enhance JavaScript's brevity and readability. Specific additional features include list comprehension and destructuring assignment. CoffeeScript support is included in Ruby on Rails version 3.1 and Play Framework. In 2011, Brendan Eich referenced CoffeeScript as an influence on his thoughts about the future of JavaScript."
  },
  "87": {
    "label": "CPL",
    "wikipedia_pageid": 828614,
    "inception": { "time": "+1963-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 21, 36],
    "typing": [],
    "description": "**CPL** (**Combined Programming Language**) is a multi-paradigm programming language, that was developed in the early 1960s. It is an early ancestor of the C language via the BCPL and B languages."
  },
  "88": {
    "label": "Common Intermediate Language",
    "wikipedia_pageid": 46004,
    "inception": { "time": "+2000-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [],
    "description": "**Common Intermediate Language** (**CIL**), formerly called **Microsoft Intermediate Language** (**MSIL**) or **Intermediate Language** (**IL**), is the intermediate language binary instruction set defined within the Common Language Infrastructure (CLI) specification. CIL instructions are executed by a CLI-compatible runtime environment such as the Common Language Runtime. Languages which target the CLI compile to CIL. CIL is object-oriented, stack- based bytecode. Runtimes typically just-in-time compile CIL instructions into native code. CIL was originally known as Microsoft Intermediate Language (MSIL) during the beta releases of the .NET languages. Due to standardization of C# and the CLI, the bytecode is now officially known as CIL. Windows Defender virus definitions continue to refer to binaries compiled with it as MSIL."
  },
  "89": {
    "label": "Common Lisp",
    "wikipedia_pageid": 6068,
    "inception": { "time": "+1984-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 21, 6, 26, 25, 9],
    "typing": [10, 1],
    "description": "**Common Lisp** (**CL**) is a dialect of the Lisp programming language, published in ANSI standard document _ANSI INCITS 226-1994 (S20018)_ (formerly _X3.226-1994 (R1999)_). The Common Lisp HyperSpec, a hyperlinked HTML version, has been derived from the ANSI Common Lisp standard. The Common Lisp language was developed as a standardized and improved successor of Maclisp. By the early 1980s several groups were already at work on diverse successors to MacLisp: Lisp Machine Lisp (aka ZetaLisp), Spice Lisp, NIL and S-1 Lisp. Common Lisp sought to unify, standardise, and extend the features of these MacLisp dialects. Common Lisp is not an implementation, but rather a language specification. Several implementations of the Common Lisp standard are available, including free and open-source software and proprietary products. Common Lisp is a general-purpose, multi-paradigm programming language. It supports a combination of procedural, functional, and object-oriented programming paradigms. As a dynamic programming language, it facilitates evolutionary and incremental software development, with iterative compilation into efficient run-time programs. This incremental development is often done interactively without interrupting the running application. It also supports optional type annotation and casting, which can be added as necessary at the later profiling and optimization stages, to permit the compiler to generate more efficient code. For instance, `fixnum` can hold an unboxed integer in a range supported by the hardware and implementation, permitting more efficient arithmetic than on big integers or arbitrary precision types. Similarly, the compiler can be told on a per-module or per- function basis which type of safety level is wanted, using _optimize_ declarations. Common Lisp includes CLOS, an object system that supports multimethods and method combinations. It is often implemented with a Metaobject Protocol. Common Lisp is extensible through standard features such as _Lisp macros_ (code transformations) and _reader macros_ (input parsers for characters). Common Lisp provides partial backwards compatibility with Maclisp and John McCarthy's original Lisp. This allows older Lisp software to be ported to Common Lisp."
  },
  "90": {
    "label": "Component Pascal",
    "wikipedia_pageid": 357599,
    "inception": { "time": "+1997-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 18, 3, 36],
    "typing": [1, 11],
    "description": "**Component Pascal** is a programming language in the tradition of Niklaus Wirth's Pascal, Modula-2, Oberon and Oberon-2. It bears the name of the language Pascal and preserves its heritage, but is incompatible with Pascal. Instead, it is a minor variant and refinement of Oberon-2 with a more expressive type system and built-in string support. Component Pascal was originally named Oberon/L, and was designed and supported by a small ETH Zürich spin-off company named Oberon microsystems. They developed an integrated development environment (IDE) named BlackBox Component Builder. Since 2014, development and support has been taken over by a small group of volunteers. The first version of the IDE was released in 1994, as _Oberon/F_. At the time, it presented a novel approach to graphical user interface (GUI) construction based on editable forms, where fields and command buttons are linked to exported variables and executable procedures. This approach bears some similarity to the code-behind way used in Microsoft's .NET 3.0 to access code in Extensible Application Markup Language (XAML), which was released in 2008. An open-source software implementation of Component Pascal exists for the .NET and Java virtual machine (JVM) platforms, from the Gardens Point team around John Gough at Queensland University of Technology in Australia. On 23 June 2004 Oberon microsystems announced that the BlackBox Component Builder was made available as a free download and that an open-source version was planned. The beta open-source version was initially released in December 2004 and updated to a final v1.5 release in December 2005. It includes the complete source code of the IDE, compiler, debugger, source analyser, profiler, and interfacing libraries, and can also be downloaded from their website. Several release candidates for v1.6 appeared in the years 2009–2011, the latest one (1.6rc6) appeared on Oberon microsystems web pages in 2011. At the end of 2013, Oberon microsystems released the final release 1.6. It is probably the last release bundled by them. A small community took over the ongoing development. BlackBox Component Pascal uses the extensions .odc (**O** beron **d** o **c** ument) for document files, such as source files for example, and .osf (**O** beron **s** ymbol **f** ile) for symbol files while Gardens Point Component Pascal uses .cp for source and .cps for symbol files. BlackBox Component Pascal has its own executable and loadable object format .ocf (**O** beron **c** ode **f** ile); it includes a runtime linking loader for this format. The document format (.odc) is a rich text binary format, which allows nice formatting, supports conditional folding, and allows active content to be embedded in the source text. It also handles user interface elements in editable forms. This is in tradition of the Oberon Text format."
  },
  "91": {
    "label": "Constraint Handling Rules",
    "wikipedia_pageid": 1753362,
    "inception": { "time": "+1991-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [13, 11],
    "typing": [],
    "description": "**Constraint Handling Rules** (**CHR**) is a declarative, rule-based programming language, introduced in 1991 by Thom Frühwirth at the time with European Computer-Industry Research Centre (ECRC) in Munich, Germany. Originally intended for constraint programming, CHR finds applications in grammar induction, type systems, abductive reasoning, multi-agent systems, natural language processing, compilation, scheduling, spatial-temporal reasoning, testing, and verification. A CHR program, sometimes called a _constraint handler_, is a set of rules that maintain a _constraint store_, a multi-set of logical formulas. Execution of rules may add or remove formulas from the store, thus changing the state of the program. The order in which rules \"fire\" on a given constraint store is non-deterministic, according to its _abstract semantics_ and deterministic (top-down rule application), according to its _refined semantics_. Although CHR is Turing complete, it is not commonly used as a programming language in its own right. Rather, it is used to extend a _host language_ with constraints. Prolog is by far the most popular host language and CHR is included in several Prolog implementations, including _SICStus_ and _SWI- Prolog_, although CHR implementations also exist for Haskell, Java, C, SQL, and JavaScript. In contrast to Prolog, CHR rules are multi-headed and are executed in a committed-choice manner using a forward chaining algorithm."
  },
  "92": {
    "label": "Cool",
    "wikipedia_pageid": 14782123,
    "inception": { "time": "+1996-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [1, 14, 11],
    "description": "**Cool**, an acronym for **Classroom Object Oriented Language**, is a computer programming language designed by Alexander Aiken for use in an undergraduate compiler course project. While small enough for a one term project, Cool still has many of the features of modern programming languages, including objects, automatic memory management, strong static typing and simple reflection. The reference Cool compiler is written in C++, built fully on the public domain tools. It generates code for a MIPS simulator, SPIM. Thus, the language should port easily to other platforms. It has been used for teaching compilers at many institutions (such as the University of California at Berkeley, where it was first used or Shahid Beheshti University of Iran) and the software is stable. This language is unrelated to the COOL language included in CLIPS."
  },
  "93": {
    "label": "Coq",
    "wikipedia_pageid": 581974,
    "inception": { "time": "+1984-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [29],
    "typing": [],
    "description": "**Coq** is an interactive theorem prover first released in 1989. It allows for expressing mathematical assertions, mechanically checks proofs of these assertions, helps find formal proofs, and extracts a certified program from the constructive proof of its formal specification. Coq works within the theory of the calculus of inductive constructions, a derivative of the calculus of constructions. Coq is not an automated theorem prover but includes automatic theorem proving tactics (procedures) and various decision procedures. The Association for Computing Machinery awarded Thierry Coquand, Gérard Huet, Christine Paulin-Mohring, Bruno Barras, Jean-Christophe Filliâtre, Hugo Herbelin, Chetan Murthy, Yves Bertot, and Pierre Castéran with the 2013 ACM Software System Award for Coq. Coq is named after its principal developer, Thierry Coquand."
  },
  "94": {
    "label": "CorVision",
    "wikipedia_pageid": 4891630,
    "inception": { "time": "+1986-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**CorVision** is a fourth generation programming tool (4GL) currently owned by Attunity, Inc. CorVision was developed by Cortex Corporation for the VAX/VMS ISAM environment. Although Cortex beta tested CorVision-10 which was generated for PCs but CorVision itself stayed anchored on VMS. CorVision-10 proved more difficult than hoped, and was never released."
  },
  "95": {
    "label": "Coral 66",
    "wikipedia_pageid": 7262,
    "inception": { "time": "+1964-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 36],
    "typing": [1, 11],
    "description": "**CORAL**, short for **Computer On-line Real-time Applications Language** is a programming language originally developed in 1964 at the Royal Radar Establishment (RRE), Malvern, Worcestershire, in the United Kingdom. The R was originally for \"radar\", not \"real-time\". It was influenced primarily by JOVIAL, and thus ALGOL, but is not a subset of either. The most widely-known version,**CORAL 66**, was subsequently developed by I. F. Currie and M. Griffiths under the auspices of the _Inter-Establishment Committee for Computer Applications_ (IECCA). Its official definition, edited by Woodward, Wetherall, and Gorman, was first published in 1970. In 1971, CORAL was selected by the Ministry of Defence as the language for future military applications and to support this, a standardization program was introduced to ensure CORAL compilers met the specifications. This process was later adopted by the US Department of Defense while defining Ada."
  },
  "96": {
    "label": "Crystal",
    "wikipedia_pageid": 48972626,
    "inception": { "time": "+2014-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 16],
    "typing": [4, 13, 6, 11],
    "description": "**Crystal** is a general-purpose, object-oriented programming language, designed and developed by Ary Borenszweig, Juan Wajnerman, Brian Cardiff and more than 300 contributors. With syntax inspired by the language Ruby, it is a compiled language with static type-checking, but specifying the types of variables or method arguments is generally unneeded. Types are resolved by an advanced global type inference algorithm. Crystal is currently in active development. It is released as free and open-source software under the Apache License version 2.0."
  },
  "97": {
    "label": "Csound",
    "wikipedia_pageid": 149998,
    "inception": { "time": "+1986-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**Csound** is a domain-specific computer programming language for audio programming. It is called Csound because it is written in C, as opposed to some of its predecessors. It is free software, available under the LGPL-2.1-or-later. Csound was originally written at MIT by Barry Vercoe in 1985, based on his earlier system called Music 11, which in its turn followed the MUSIC-N model initiated by Max Mathews at the Bell Labs. Its development continued throughout the 1990s and 2000s, led by John Fitch at the University of Bath. The first documented version 5 release is version 5.01 on March 18, 2006. Many developers have contributed to it, most notably Istvan Varga, Gabriel Maldonado, Robin Whittle, Richard Karpen, Iain McCurdy, Michael Gogins, Matt Ingalls, Steven Yi, Richard Boulanger, Victor Lazzarini and Joachim Heintz. Developed over many years, it currently has nearly 1700 unit generators. One of its greatest strengths is that it is completely modular and extensible by the user. Csound is closely related to the underlying language for the Structured Audio extensions to MPEG-4, SAOL."
  },
  "98": {
    "label": "Cuneiform",
    "wikipedia_pageid": 51797637,
    "inception": { "time": "+2013-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [21],
    "typing": [11],
    "description": "**Cuneiform** is an open-source workflow language for large-scale scientific data analysis. It is a statically typed functional programming language promoting parallel computing. It features a versatile foreign function interface allowing users to integrate software from many external programming languages. At the organizational level Cuneiform provides facilities like conditional branching and general recursion making it Turing-complete. In this, Cuneiform is the attempt to close the gap between scientific workflow systems like Taverna, KNIME, or Galaxy and large-scale data analysis programming models like MapReduce or Pig Latin while offering the generality of a functional programming language. Cuneiform is implemented in distributed Erlang. If run in distributed mode it drives a POSIX-compliant distributed file system like Gluster or Ceph (or a FUSE integration of some other file system, e.g., HDFS). Alternatively, Cuneiform scripts can be executed on top of HTCondor or Hadoop. Cuneiform is influenced by the work of Peter Kelly who proposes functional programming as a model for scientific workflow execution. In this, Cuneiform is distinct from related workflow languages based on dataflow programming like Swift."
  },
  "99": {
    "label": "Curl",
    "wikipedia_pageid": 42537,
    "inception": { "time": "+1998-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 9, 13, 21],
    "typing": [1],
    "description": "**Curl** is a reflective object-oriented programming language for interactive web applications whose goal is to provide a smoother transition between formatting and programming. It makes it possible to embed complex objects in simple documents without needing to switch between programming languages or development platforms. The Curl implementation initially consisted of just an interpreter, but a compiler was added later. Curl combines text markup (as in HTML), scripting (as in JavaScript), and heavy-duty computing (as in Java, C#, or C++) within one unified framework. It is used in a range of internal enterprise, B2B, and B2C applications. Curl programs may be compiled into Curl applets, that are viewed using the Curl RTE, a runtime environment with a plugin for web browsers. Currently, it is supported on Microsoft Windows. Linux, and macOS was dropped on March 25, 2019 (starting with version 8.0.8). Curl supports \"detached applets\", which is a web deployed applet which runs on the user's desktop independent of a browser window much as in Silverlight 3 and Adobe AIR."
  },
  "100": {
    "label": "Curry",
    "wikipedia_pageid": 302187,
    "inception": null,
    "paradigm": [28, 29, 21],
    "typing": [1, 6, 11],
    "description": "**Curry** is an experimental functional logic programming language, based on the Haskell language. It merges elements of functional and logic programming, including constraint programming integration. It is nearly a superset of Haskell, lacking support mostly for overloading using type classes, which some implementations provide anyway as a language extension, such as the Münster Curry Compiler."
  },
  "101": {
    "label": "Cyclone",
    "wikipedia_pageid": 7645,
    "inception": { "time": "+2002-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [1, 11],
    "description": "The **Cyclone** programming language is intended to be a safe dialect of the C language. Cyclone is designed to avoid buffer overflows and other vulnerabilities that are possible in C programs, without losing the power and convenience of C as a tool for system programming. Cyclone development was started as a joint project of AT&T Labs Research and Greg Morrisett's group at Cornell in 2001. Version 1.0 was released on May 8, 2006."
  },
  "102": {
    "label": "Cython",
    "wikipedia_pageid": 18384111,
    "inception": { "time": "+2007-07-28T00:00:00Z", "precision": 11 },
    "paradigm": [],
    "typing": [],
    "description": "**Cython** is a programming language that aims to be a superset of the Python programming language, designed to give C-like performance with code that is written mostly in Python with optional additional C-inspired syntax. Cython is a compiled language that is typically used to generate CPython extension modules. Annotated Python-like code is compiled to C or C++ then automatically wrapped in interface code, producing extension modules that can be loaded and used by regular Python code using the import statement, but with significantly less computational overhead at run time. Cython also facilitates wrapping independent C or C++ code into python-importable modules. Cython is written in Python and C and works on Windows, macOS, and Linux, producing source files compatible with CPython 2.6, 2.7, and 3.3 and later versions. Cython 3.0.0 is in development."
  },
  "103": {
    "label": "D",
    "wikipedia_pageid": 243881,
    "inception": { "time": "+2001-12-08T00:00:00Z", "precision": 11 },
    "paradigm": [6, 3, 21],
    "typing": [1, 6, 11],
    "description": "**D**, also known as **Dlang**, is a multi-paradigm system programming language created by Walter Bright at Digital Mars and released in 2001. Andrei Alexandrescu joined the design and development effort in 2007. Though it originated as a re-engineering of C++, D is a distinct language. It has redesigned some core C++ features, while also sharing characteristics of other languages, notably Java, Python, Ruby, C#, and Eiffel. The design goals of the language attempted to combine the performance and safety of compiled languages with the expressive power of modern dynamic languages. Idiomatic D code is commonly as fast as equivalent C++ code, while also being shorter. The language as a whole is not memory-safe but does include optional attributes designed to check memory safety. Type inference, automatic memory management and syntactic sugar for common types allow faster development, while bounds checking, design by contract features and a concurrency-aware type system help reduce the occurrence of bugs."
  },
  "104": {
    "label": "DIBOL",
    "wikipedia_pageid": 598142,
    "inception": { "time": "+1970-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 36],
    "typing": [11],
    "description": "**DIBOL** or **Digital's Business Oriented Language** is a general-purpose, procedural, imperative programming language, designed for use in Management Information Systems (MIS) software development. It has a syntax similar to FORTRAN and BASIC, along with BCD arithmetic. It shares the COBOL program structure of separate data and procedure divisions. Unlike Fortran's numeric labels (for GOTO), DIBOL's were alphanumeric; the language supported a counterpart to computed goto."
  },
  "105": {
    "label": "DRAKON",
    "wikipedia_pageid": 9912359,
    "inception": { "time": "+1996-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [10],
    "typing": [],
    "description": "**DRAKON** is an algorithmic visual programming and modeling language developed within the Buran space project following ergonomic design principles. The language provides a uniform way to represent flowcharts of any complexity that are easy to read and understand. The name DRAKON is the Russian acronym for \"Дружелюбный Русский Алгоритмический [язык], Который Обеспечивает Наглядность\", which translates to \"Friendly Russian algorithmic [language] that illustrates (or provides clarity)\". The word \"наглядность\" (pronounced approximately as \"naa-glya-dno- st-th\") refers to a concept or idea being easy to imagine and understand, and may be translated as \"clarity\". The DRAKON language can be used both as a modelling/\"markup\" language (which is considered a standalone \"pure DRAKON\" program) and as a programming language (as part of a hybrid language). Integration of a stricter, \"academic\", variant of a markup language into programming, such as provided by DRAKON, adds syntactic sugar allowing users of different programming languages to easily understand the contributions of others and provide commentary if needed."
  },
  "106": {
    "label": "DYNAMO",
    "wikipedia_pageid": 26064582,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**DYNAMO** (**DYNAmic MOdels**) is a historically important simulation language and accompanying graphical notation developed within the system dynamics analytical framework. It was originally for industrial dynamics but was soon extended to other applications, including population and resource studies and urban planning. DYNAMO was initially developed under the direction of Jay Wright Forrester in the late 1950s, by Dr. Phyllis Fox, Alexander L. Pugh III, Grace Duren, and others at the M.I.T. Computation Center. DYNAMO was used for the system dynamics simulations of global resource- depletion reported in the Club of Rome's Limits to Growth, but has since fallen into disuse."
  },
  "107": {
    "label": "Dart",
    "wikipedia_pageid": 33033735,
    "inception": { "time": "+2011-10-10T00:00:00Z", "precision": 11 },
    "paradigm": [6, 3, 9, 21],
    "typing": [1, 6, 11],
    "description": "**Dart** is a programming language designed for client development, such as for the web and mobile apps. It is developed by Google and can also be used to build server and desktop applications. Dart is an object-oriented, class-based, garbage-collected language with C-style syntax. Dart can compile to either native code or JavaScript. It supports interfaces, mixins, abstract classes, reified generics, and type inference."
  },
  "108": {
    "label": "Darwin",
    "wikipedia_pageid": 12794721,
    "inception": { "time": "+1991-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 3, 36],
    "typing": [10, 1],
    "description": "**Darwin** is a closed source programming language developed by Gaston Gonnet and colleagues at ETH Zurich. It is used to develop the OMA orthology inference software, which was also initially developed by Gonnet. The language backend consists of the kernel, responsible for performing simple mathematical calculations, for transporting and storing data and for interpreting the user's commands, and the library, a set of programs which can perform more complicated calculations. The target audience for the language is the biosciences, so the library consisted of routines such as those to compute pairwise alignments, phylogenetic trees, multiple sequence alignments, and to make secondary structure predictions."
  },
  "109": {
    "label": "Data analysis expressions",
    "wikipedia_pageid": 37774833,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**Data Analysis Expressions** (**DAX**) is the native formula and query language for Microsoft PowerPivot, Power BI Desktop and SQL Server Analysis Services (SSAS) Tabular models. DAX includes some of the functions that are used in Excel formulas with additional functions that are designed to work with relational data and perform dynamic aggregation. It is, in part, an evolution of the Multidimensional Expression (MDX) language developed by Microsoft for Analysis Services multidimensional models (often called cubes) combined with Excel formula functions. It is designed to be simple and easy to learn, while exposing the power and flexibility of PowerPivot and SSAS tabular models."
  },
  "110": {
    "label": "DataFlex",
    "wikipedia_pageid": 742526,
    "inception": { "time": "+1982-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 3, 36],
    "typing": [],
    "description": "**DataFlex** is an object-oriented high-level programming language and a fourth generation visual tool 4GL for developing Windows, web and mobile software applications on one framework-based platform. It was introduced and developed by _Data Access Corporation_ beginning in 1982."
  },
  "111": {
    "label": "Datalog",
    "wikipedia_pageid": 968357,
    "inception": { "time": "+1986-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [28, 13],
    "typing": [2],
    "description": "**Datalog** is a declarative logic programming language that syntactically is a subset of Prolog. It is often used as a query language for deductive databases. In recent years, Datalog has found new application in data integration, information extraction, networking, program analysis, security, cloud computing and machine learning. Its origins date back to the beginning of logic programming, but it became prominent as a separate area around 1977 when Hervé Gallaire and Jack Minker organized a workshop on logic and databases. David Maier is credited with coining the term Datalog."
  },
  "112": {
    "label": "Delphi",
    "wikipedia_pageid": 349208,
    "inception": { "time": "+1995-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**Delphi** is a software product that uses the Delphi dialect of the Object Pascal programming language and provides an integrated development environment (IDE) for rapid application development of desktop, mobile, web, and console software, currently developed and maintained by Embarcadero Technologies. Delphi's compilers generate native code for Microsoft Windows, macOS, iOS, Android and Linux (x64). Delphi includes a code editor, a visual designer, an integrated debugger, a source code control component, and support for third-party plugins. The code editor features Code Insight (code completion), Error Insight (real-time error-checking), and refactoring. The visual forms designer has the option of using either the Visual Component Library (VCL) for pure Windows development or the FireMonkey (FMX) framework for cross-platform development. Database support is a key feature and is provided by FireDAC (Database Access Components). Delphi is known for its fast compilation speed, native code, and developer productivity. Delphi was originally developed by Borland as a rapid application development tool for Windows as the successor of Turbo Pascal. Delphi added full object- oriented programming to the existing language, and the language has grown to support generics, anonymous methods, closures, and native Component Object Model (COM) support. Delphi and its C++ counterpart, C++Builder, are interoperable and jointly sold under the name RAD Studio. There are Professional, Enterprise, and Architect editions, with the higher editions having more features at a higher price. There is also a free-of-charge Community edition, with most of the features of Professional, but restricted to users and companies with low revenue."
  },
  "113": {
    "label": "Distributed Application Specification Language",
    "wikipedia_pageid": 9216093,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "The **DASL Programming Language** (Distributed Application Specification Language) is a high-level, strongly typed programming language originally developed at Sun Microsystems Laboratories between 1999 and 2003 as part of the Ace Project. The goals of the project were to enable rapid development of web-based applications based on Sun's J2EE architecture, and to eliminate the steep learning curve of platform-specific details. DASL defines an application as a domain model with one or more logical presentation models, where a logical presentation model consists of a choreography of the domain model objects described in a set of forms with attached actions. DASL generates the graphical user interface directly from the logical presentation. DASL is unique among modern application programming languages in its ability to generate a modern graphic user interface for an application without requiring the programmer to define the user interface explicitly, while allowing the programmer to control the look and feel of the generated graphic user interface. The DASL language is partially declarative and partially procedural. Description of object/data structures and persistence, and the description of the logical presentation, are declarative. Basic object constraints and behavior are declarative, while additional object behaviors are specified procedurally as methods. Queries can be defined either declaratively or by writing methods. The language and development environment are a practical realization of the model-driven architecture (MDA) approach. The programmer uses DASL to produce the platform-independent model or PIM, and the language code generators automatically produce and deploy the platform-specific model or PSM. New PSMs may be introduced by writing new code generators."
  },
  "114": {
    "label": "Draco",
    "wikipedia_pageid": 507348,
    "inception": null,
    "paradigm": [2, 3, 36],
    "typing": [1, 14, 11],
    "description": "**Draco** was a shareware programming language created by Chris Gray. First developed for CP/M systems, Amiga version followed in 1987. Although Draco, a blend of Pascal and C, was well suited for general purpose programming, its uniqueness as a language was its main weak point. Gray used Draco for the Amiga to create a port of Peter Langston's game _Empire_."
  },
  "115": {
    "label": "Dylan",
    "wikipedia_pageid": 8741,
    "inception": { "time": "+1992-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 21],
    "typing": [10, 1],
    "description": "**Dylan** is a multi-paradigm programming language that includes support for functional and object-oriented programming (OOP), and is dynamic and reflective while providing a programming model designed to support generating efficient machine code, including fine-grained control over dynamic and static behaviors. It was created in the early 1990s by a group led by Apple Computer. A concise and thorough overview of the language may be found in the Dylan Reference Manual. Dylan derives from Scheme and Common Lisp and adds an integrated object system derived from the Common Lisp Object System (CLOS). In Dylan, all values (including numbers, characters, functions, and classes) are first-class objects. Dylan supports multiple inheritance, polymorphism, multiple dispatch, keyword arguments, object introspection, pattern-based syntax extension macros, and many other advanced features. Programs can express fine-grained control over dynamism, admitting programs that occupy a continuum between dynamic and static programming and supporting evolutionary development (allowing for rapid prototyping followed by incremental refinement and optimization). Dylan's main design goal is to be a dynamic language well-suited for developing commercial software. Dylan attempts to address potential performance issues by introducing \"natural\" limits to the full flexibility of Lisp systems, allowing the compiler to clearly understand compilable units, such as libraries. Dylan derives much of its semantics from Scheme and other Lisps; some Dylan implementations were initially built within extant Lisp systems. However, Dylan has an ALGOL-like syntax instead of a Lisp-like prefix syntax."
  },
  "116": {
    "label": "E",
    "wikipedia_pageid": 1377046,
    "inception": { "time": "+1997-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [10, 1],
    "description": "**E** is an object-oriented programming language for secure distributed computing, created by Mark S. Miller, Dan Bornstein, Douglas Crockford, Chip Morningstar and others at Electric Communities in 1997. E is mainly descended from the concurrent language Joule and from Original-E, a set of extensions to Java for secure distributed programming. E combines message-based computation with Java-like syntax. A concurrency model based on event loops and promises ensures that deadlock can never occur."
  },
  "117": {
    "label": "eC",
    "wikipedia_pageid": 48971282,
    "inception": { "time": "+2004-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 2, 3, 26],
    "typing": [8, 4, 11],
    "description": "**eC** (**Ecere C**) is an object-oriented programming language, defined as a super-set of the C language. eC was initially developed as part of the Ecere cross-platform software development kit (SDK) project. The goals of the language are to provide object-oriented constructs, reflection, properties and dynamic modules on top of the C language while maintaining C compatibility and optimal native performance. eC currently relies on GCC or Clang to perform the final steps of compilation, using C as an intermediate language. There are, however, plans to integrate directly with LLVM to skip the intermediate C files. eC is available as part of the `ecere-sdk` package in Debian/Ubuntu and other derived Linux distributions. A Windows installer also bundling MinGW-w64 is available from the main website. The free and open-source SDK including the eC compiler can also be built for a number of other platforms, including OS X, FreeBSD and Android. It is also possible to deploy eC applications to the web by compiling them to JavaScript through Emscripten, or to WebAssembly through Binaryen."
  },
  "118": {
    "label": "ECMAScript",
    "wikipedia_pageid": 188515,
    "inception": { "time": "+1997-06-00T00:00:00Z", "precision": 10 },
    "paradigm": [3, 14, 21],
    "typing": [10, 2],
    "description": "**ECMAScript** () (or **ES**) is a general-purpose programming language, standardised by Ecma International according to the document ECMA-262. It is a JavaScript standard meant to ensure the interoperability of web pages across different web browsers. ECMAScript is commonly used for client-side scripting on the World Wide Web, and it is increasingly being used for writing server applications and services using Node.js."
  },
  "119": {
    "label": "ELAN",
    "wikipedia_pageid": 1179492,
    "inception": { "time": "+1974-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**ELAN** is an educational programming language for learning and teaching systematic programming. It was developed in 1974 by C.H.A. Koster and a group at the Technical University of Berlin as an alternative to BASIC in teaching, and approved for use in secondary schools in Germany by the \"Arbeitskreis Schulsprache\". It was in use until the late 1980s in a number of schools in Germany, Belgium, the Netherlands, and Hungary for informatics teaching in secondary education, and used at the Radboud University Nijmegen in the Netherlands for teaching systematic programming to students from various disciplines and in teacher courses. The language design focuses strongly on structured programming, and has a special construction for stepwise refinement, allowing students to focus on top-down design, and bottom-up coding."
  },
  "120": {
    "label": "Ease",
    "wikipedia_pageid": 1968693,
    "inception": { "time": "+1991-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [16, 7],
    "typing": [1],
    "description": "**Ease** is a general purpose parallel programming language. It is designed by Steven Ericsson-Zenith, a researcher at Yale University, the Institute for Advanced Science & Engineering in Silicon Valley, California, the Ecole Nationale Supérieure des Mines de Paris, and the Pierre and Marie Curie University, the science department of the Sorbonne. The book _Process Interaction Models_ is the Ease language specification. Ease combines the process constructs of communicating sequential processes (CSP) with logically shared data structures called _contexts_. Contexts are parallel data types that are constructed by processes and provide a way for processes to interact. The language includes two process constructors. A _cooperation_ includes an explicit barrier synchronization and is written:           ∥ P ( ) ∥ Q ( ) ; {\\displaystyle \\parallel P()\\parallel Q();} If one process finishes before the other, then it will wait until the other processes are finished. A _subordination_ creates a process that shares the _contexts_ that are in scope when created and finishes when complete (it does not wait for other processes) and is written:           / / P ( ) ; {\\displaystyle {\\big /}\\\\!\\\\!/P();} Subordinate processes stop if they attempt to interact with a _context_ that has completed because the parent process has stopped. This enables speculative processes to be created that will finish if their result is not needed. Powerful _replication_ syntax allows multiple processes to be created. For example,           ∥ i f o r n : P ( i ) ; {\\displaystyle \\parallel {i}\\;\\mathrm {for} \\;{n}:P(i);} creates _n_ synchronized processes each with a local constant _i_. Processes cannot share _local_ variables and cooperate in the construction of shared _contexts._ Certain context types, called _resources_, ensure call- reply semantics. There are four functions upon contexts:   * _read_ (context, variable) – copies a value from the shared _context_ to the _variable_.   * _write_ (context, expression) – copies the value of _expression_ to the shared _context_.   * _put_ (context, name) – moves the value bound to _name_ to the shared _context_. The value of _name_ is subsequently _undefined_.   * _get_ (context, name) – moves a value from _context_ and binds it to _name_. The value is removed from the context. Context types are _Singletons_,_Bags_ or _Streams_ and can be subscripted arrays. Ease has a _semiotic definition_. This means that it accounts for the effect the language has on the programmer and how they develop algorithms. The language was designed to _ease_ the developing of parallel programs."
  },
  "121": {
    "label": "Easy Programming Language",
    "wikipedia_pageid": 42016798,
    "inception": { "time": "+2004-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 2, 3, 21],
    "typing": [],
    "description": "**Easy Programming Language** (**EPL**, Chinese: 易语言) is a visual compiled multilingual proprietary programming language. EPL is somewhat popular in China because it features a full Chinese environment. (The language has traditional Chinese, simplified Chinese, English and Japanese variants.) In addition, it is cross-platform, as it currently supports both Microsoft Windows and Linux. It is object-oriented and structured."
  },
  "122": {
    "label": "Edinburgh IMP",
    "wikipedia_pageid": 953419,
    "inception": { "time": "+1966-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 36],
    "typing": [1, 11],
    "description": "**Edinburgh IMP** is a development of Atlas Autocode, initially developed around 1966-1969 at the University of Edinburgh, Scotland. It is a general- purpose programming language which was used heavily for systems programming. Expressively, IMP is highly similar to ALGOL and includes all the ALGOL-style block structure, reserved words (keywords), and data types such as arrays, and records. It adds to ALGOL-style languages a string type (an array of characters, although these have a predeclared size) and built-in operators for string manipulation and character handling. IMP provides significant control over the storage mapping of data, plus commands for addressing within parts of words. Most IMP compilers offer compiler-generated runtime checks and a stack trace (backtrace) facility by default, even in production code. IMP allows inline assembler machine language instructions in source code. Early IMP compilers were developed for the English Electric KDF9, ICL System 4, UNIVAC 1108, IBM System/360, DEC PDP-9, DEC PDP-15 and CTL Modular One computers. IMP was used to implement the Edinburgh Multiple Access System (EMAS) operating system, and a compiler was written for the ICL 2900 series to allow porting of EMAS to that platform. In later years, a version of IMP named IMP77 was developed by Peter Robertson within the Computer Science department at Edinburgh which was a portable compiler that brought IMP to even more platforms. In 2002, the IMP77 language was resurrected by the Edinburgh Computer History Project for Intel x86 hardware running DOS, Windows, and Linux, and is once again in use by Edinburgh graduates and ex-pats. The diverged IMP and IMP77 were later consolidated into one language with the introduction of the IMP80 standard, supported by implementations from the Edinburgh Regional Computer Centre. IMP80 has also been ported to several platforms including Intel and was actively in use into the 1990s. Edinburgh IMP is unrelated to the later IMP syntax-extensible programming language developed by Edgar T. Irons, for the CDC 6600, which was the main language used by the National Security Agency (NSA) for many years."
  },
  "123": {
    "label": "Eiffel",
    "wikipedia_pageid": 9838,
    "inception": { "time": "+1986-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 0, 16, 26],
    "typing": [11],
    "description": "**Eiffel** is an object-oriented programming language designed by Bertrand Meyer (an object-orientation proponent and author of _Object-Oriented Software Construction_) and Eiffel Software. Meyer conceived the language in 1985 with the goal of increasing the reliability of commercial software development; the first version becoming available in 1986. In 2005, Eiffel became an ISO- standardized language. The design of the language is closely connected with the Eiffel programming method. Both are based on a set of principles, including design by contract, command–query separation, the uniform-access principle, the single-choice principle, the open–closed principle, and option–operand separation. Many concepts initially introduced by Eiffel later found their way into Java, C#, and other languages. New language design ideas, particularly through the Ecma/ISO standardization process, continue to be incorporated into the Eiffel language."
  },
  "124": {
    "label": "Elixir",
    "wikipedia_pageid": 38202780,
    "inception": { "time": "+2011-01-09T00:00:00Z", "precision": 11 },
    "paradigm": [30, 16, 21],
    "typing": [10, 1, 13],
    "description": "**Elixir** is a functional, concurrent, general-purpose programming language that runs on the BEAM virtual machine used to implement the Erlang programming language. Elixir builds on top of Erlang and shares the same abstractions for building distributed, fault-tolerant applications. Elixir also provides productive tooling and an extensible design. The latter is supported by compile-time metaprogramming with macros and polymorphism via protocols. Elixir is used by companies such as PagerDuty, Discord, Brex, E-MetroTel, Pinterest, Moz, Bleacher Report, The Outline, Inverse, Divvy, FarmBot and for building embedded systems. The community organizes yearly events in the United States, Europe and Japan as well as minor local events and conferences."
  },
  "125": {
    "label": "Elm",
    "wikipedia_pageid": 37552825,
    "inception": { "time": "+2012-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [24, 15, 29, 21],
    "typing": [6, 1, 11],
    "description": "**Elm** is a domain-specific programming language for declaratively creating web browser-based graphical user interfaces. Elm is purely functional, and is developed with emphasis on usability, performance, and robustness. It advertises \"no runtime exceptions in practice\", made possible by the Elm compiler's static type checking."
  },
  "126": {
    "label": "Emacs Lisp",
    "wikipedia_pageid": 10392,
    "inception": { "time": "+1985-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [25, 9, 21],
    "typing": [10, 1],
    "description": "**Emacs Lisp** is a dialect of the Lisp programming language used as a scripting language by Emacs (a text editor family most commonly associated with GNU Emacs and XEmacs). It is used for implementing most of the editing functionality built into Emacs, the remainder being written in C, as is the Lisp interpreter. Emacs Lisp is also termed **Elisp**, although there is also an older, unrelated Lisp dialect with that name. Users of Emacs commonly write Emacs Lisp code to customize and extend Emacs. Other options include the _Customize_ feature that's been in GNU Emacs since version 20. Itself written in Emacs Lisp, Customize provides a set of preferences pages allowing the user to set options and preview their effect in the running Emacs session. When the user saves their changes, Customize simply writes the necessary Emacs Lisp code to the user's config file, which can be set to a special file that only Customize uses, to avoid the possibility of altering the user's own file. Emacs Lisp can also function as a scripting language, much like the Unix Bourne shell or Perl, by calling Emacs in _batch mode_. In this way it may be called from the command line or via an executable file, and its editing functions, such as buffers and movement commands are available to the program just as in the normal mode. No user interface is presented when Emacs is started in batch mode; it simply executes the passed-in script and exits, displaying any output from the script."
  },
  "127": {
    "label": "Emerald",
    "wikipedia_pageid": 32529580,
    "inception": { "time": "+1980-01-01T00:00:00Z", "precision": 8 },
    "paradigm": [6],
    "typing": [1, 11],
    "description": "**Emerald** is a distributed, object-oriented programming language developed in the 1980s by Andrew P. Black, Norman C. Hutchinson, Eric B. Jul, and Henry M. Levy, in the Department of Computer Science at the University of Washington. A simple Emerald program can create an object and move it around the system:               **const** Kilroy ←  **object** Kilroy       **process**       **const** origin ←  **locate self**       **const** up ← origin.getActiveNodes       **for** e **in** up        **const** there ← e.getTheNode        **move self to** there       **end for**       **move self to** origin       **end** process     **end** Kilroy      Emerald was designed to support high performance distribution, location, and high performance of objects, to simplify distributed programming, to exploit information hiding, and to be a small language."
  },
  "128": {
    "label": "Epigram",
    "wikipedia_pageid": 1933143,
    "inception": { "time": "+2004-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [21],
    "typing": [0, 1, 11],
    "description": "**Epigram** is a functional programming language with dependent types, and the integrated development environment (IDE) usually packaged with the language. Epigram's type system is strong enough to express program specifications. The goal is to support a smooth transition from ordinary programming to integrated programs and proofs whose correctness can be checked and certified by the compiler. Epigram exploits the _Curry–Howard correspondence_, also termed the _propositions as types principle_, and is based on intuitionistic type theory. The Epigram prototype was implemented by Conor McBride based on joint work with James McKinna. Its development is continued by the Epigram group in Nottingham, Durham, St Andrews, and Royal Holloway, University of London in the United Kingdom (UK). The current experimental implementation of the Epigram system is freely available together with a user manual, a tutorial and some background material. The system has been used under Linux, Windows, and macOS. It is currently unmaintained, and version 2, which was intended to implement Observational Type Theory, was never officially released but exists in GitHub."
  },
  "129": {
    "label": "Erlang",
    "wikipedia_pageid": 9646,
    "inception": { "time": "+1986-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [16, 13, 21],
    "typing": [10, 1],
    "description": "**Erlang** (_UR -lang_) is a general-purpose, concurrent, functional programming language, and a garbage-collected runtime system. The term Erlang is used interchangeably with Erlang/OTP, or Open Telecom Platform (OTP), which consists of the Erlang runtime system, several ready-to-use components (OTP) mainly written in Erlang, and a set of design principles for Erlang programs. The Erlang runtime system is designed for systems with these traits:   * Distributed   * Fault-tolerant   * Soft real-time   * Highly available, non-stop applications   * Hot swapping, where code can be changed without stopping a system. The Erlang programming language has immutable data, pattern matching, and functional programming. The sequential subset of the Erlang language supports eager evaluation, single assignment, and dynamic typing. A normal Erlang application is built out of hundreds of small Erlang processes. It was originally proprietary software within Ericsson, developed by Joe Armstrong, Robert Virding, and Mike Williams in 1986, but was released as free and open-source software in 1998. Erlang/OTP is supported and maintained by the Open Telecom Platform (OTP) product unit at Ericsson."
  },
  "130": {
    "label": "Escher",
    "wikipedia_pageid": 15127666,
    "inception": { "time": "+1990-01-01T00:00:00Z", "precision": 8 },
    "paradigm": [28, 13, 21],
    "typing": [14, 11],
    "description": "**Escher** (named for M. C. Escher, \"a master of endless loops\") is a declarative programming language that supports both functional programming and logic programming models, developed by J.W. Lloyd in the mid-1990s. It was designed mostly as a research and teaching vehicle. The basic view of programming exhibited by Escher and related languages is that a program is a representation of a theory in some logic framework, and the program's execution (computation) is a deduction from the theory. The logic framework for Escher is Alonzo Church's simple theory of types. Escher, notably, supports I/O through a monadic type representing the 'outside world', in the style of Haskell. One of the goals of Escher's designers was to support meta-programming, and so the language has comprehensive support for generating and transforming programs."
  },
  "131": {
    "label": "Esterel",
    "wikipedia_pageid": 1285078,
    "inception": { "time": "+1980-01-01T00:00:00Z", "precision": 8 },
    "paradigm": [3, 16],
    "typing": [],
    "description": "**Esterel** is a synchronous programming language for the development of complex reactive systems. The imperative programming style of **Esterel** allows the simple expression of parallelism and preemption. As a consequence, it is well suited for control-dominated model designs. The development of the language started in the early 1980s, and was mainly carried out by a team of Ecole des Mines de Paris and INRIA led by Gérard Berry in France. Current compilers take Esterel programs and generate C code or hardware (RTL) implementations (VHDL or Verilog). The language is still under development, with several compilers out. The commercial version of **Esterel** is the development environment Esterel Studio. The company that commercialize it (Synfora) initiated a normalization process with the IEEE in April 2007 however the working group (P1778) dissolved March 2011. The Esterel v7 Reference Manual Version v7 30 – initial IEEE standardization proposal is publicly available."
  },
  "132": {
    "label": "Etoys",
    "wikipedia_pageid": 4052771,
    "inception": { "time": "+1996-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 14],
    "typing": [10],
    "description": "**Etoys** is a child-friendly computer environment and object-oriented prototype-based programming language for use in education. Etoys is a media-rich authoring environment with a scripted object model for many different objects that runs on different platforms and is free and open source."
  },
  "133": {
    "label": "Euclid",
    "wikipedia_pageid": 827385,
    "inception": { "time": "+1977-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 21, 36],
    "typing": [1, 11],
    "description": "**Euclid** is an imperative programming language for writing verifiable programs. It was designed by Butler Lampson and associates at the Xerox PARC lab in the mid-1970s. The implementation was led by Ric Holt at the University of Toronto and James Cordy was the principal programmer for the first implementation of the compiler. It was originally designed for the Motorola 6809 microprocessor. It was considered innovative for the time; the compiler development team had a $2 million budget over 2 years and was commissioned by the Defense Advanced Research Projects Agency of the U.S. Department of Defense and the Canadian Department of National Defence. It was used for a few years at I. P. Sharp Associates, MITRE Corporation, SRI International and various other international institutes for research in systems programming and secure software systems. Euclid is descended from the Pascal programming language. Functions in Euclid are closed scopes, may not have side effects, and must explicitly declare imports. Euclid also disallows gotos, floating point numbers, global assignments, nested functions and aliases, and none of the actual parameters to a function can refer to the same thing. Euclid implements modules as types. Descendants of Euclid include the Mesa programming language, the Concurrent Euclid programming language and the Turing programming language."
  },
  "134": {
    "label": "Euler",
    "wikipedia_pageid": 908540,
    "inception": { "time": "+1965-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 36],
    "typing": [10],
    "description": "**Euler** is a programming language created by Niklaus Wirth and Helmut Weber, conceived as an extension and generalization of ALGOL 60. The designers' goals were to create a language that is:   * Simpler, yet more flexible, than ALGOL 60   * Useful and processed with reasonable efficiency   * Definable with rigorous formality Available sources indicate that Euler was operational by 1965."
  },
  "135": {
    "label": "Euphoria",
    "wikipedia_pageid": 9647,
    "inception": { "time": "+1993-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3],
    "typing": [10, 11],
    "description": "**Euphoria** is a programming language created by Robert Craig of Rapid Deployment Software in Toronto, Ontario, Canada. Initially developed (though not publicly released) on the Atari ST, the first commercial release was for the 16-bit DOS platform and was proprietary. In 2006, with the release of version 3, Euphoria became open-source software. The openEuphoria Group continues to administer and develop the project. In December 2010, the openEuphoria Group released version 4 of openEuphoria along with a new identity and mascot for the project. OpenEuphoria is currently available for Windows, Linux, macOS and three flavors of *BSD. Euphoria is a general-purpose high-level imperative-procedural interpreted language. A translator generates C source code and the GNU compiler collection (GCC) and Open Watcom compilers are supported. Alternatively, Euphoria programs may be bound with the interpreter to create stand-alone executables. A number of graphical user interface (GUI) libraries are supported including Win32lib and wrappers for wxWidgets, GTK+ and IUP. Euphoria has a simple built-in database and wrappers for a variety of other databases."
  },
  "136": {
    "label": "Executive Systems Problem Oriented Language",
    "wikipedia_pageid": 949062,
    "inception": { "time": "+1966-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 36],
    "typing": [1, 11],
    "description": "The **Executive Systems Problem Oriented Language** (**ESPOL**) is a programming language, a superset of ALGOL 60, that provides abilities of what would later be termed a _system programming language_ or _machine oriented high order language_ (mohol), such as interrupting a processor on a multiprocessing system (the Burroughs large systems were multiprocessor systems). ESPOL was used to write the _Master Control Program_ (MCP) on Burroughs computer systems from the B5000 to the B6700. The single-pass compiler for ESPOL could compile over 250 lines per second. ESPOL was superseded by NEWP."
  },
  "137": {
    "label": "Ezhil",
    "wikipedia_pageid": 39845825,
    "inception": { "time": "+2007-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 36],
    "typing": [10, 1],
    "description": "**Ezhil**, in Tamil language script (Tamil: எழில், romanized: _Eḻil_, lit. 'beauty', Tamil pronunciation: [eɻil̪]), is a compact, open source, interpreted, programming language, originally designed to enable native-Tamil speaking students, K-12 age-group to learn computer programming, and enable learning numeracy and computing, outside of linguistic expertise in predominately English language-based computer systems. In the Ezhil programming language, Tamil keywords and language-grammar are chosen to easily enable the native Tamil speaker write programs in the Ezhil system. Ezhil allows easy representation of computer program closer to the Tamil language logical constructs equivalent to the conditional, branch and loop statements in modern English based programming languages. Ezhil is the first freely available programming language in the Tamil language and one of many known non-English-based programming languages. The language was officially announced in July 2009, while it has been developed since late 2007."
  },
  "138": {
    "label": "F",
    "wikipedia_pageid": 1283488,
    "inception": null,
    "paradigm": [2, 20, 18],
    "typing": [14, 11],
    "description": "**F** is a modular, compiled, numeric programming language, designed for scientific programming and scientific computation. F was developed as a modern Fortran, thus making it a subset of Fortran 95. It combines both numerical and data abstraction features from these languages. F is also backwards compatible with Fortran 77, allowing calls to Fortran 77 programs. F was first included in the g95 compiler."
  },
  "139": {
    "label": "FSharp",
    "wikipedia_pageid": 239964,
    "inception": { "time": "+2005-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3, 21, 6, 25, 9, 16],
    "typing": [6, 1, 11],
    "description": "**F#** (pronounced **F sharp**) is a functional-first, general purpose, strongly typed, multi-paradigm programming language that encompasses functional, imperative, and object-oriented programming methods. F# is most often used as a cross-platform Common Language Infrastructure (CLI) language on .NET, but it can also generate JavaScript and graphics processing unit (GPU) code. F# is developed by the F# Software Foundation, Microsoft and open contributors. An open source, cross-platform compiler for F# is available from the F# Software Foundation. F# is a fully supported language in Visual Studio and JetBrains Rider. Plug-ins supporting F# exist for many widely used editors, most notably the Ionide extension for Visual Studio Code, and integrations for other editors such as Vim, and Emacs. F# is a member of the ML language family and originated as a .NET Framework implementation of a core of the programming language OCaml. It has also been influenced by C#, Python, Haskell, Scala, and Erlang."
  },
  "140": {
    "label": "F*",
    "wikipedia_pageid": 38420593,
    "inception": null,
    "paradigm": [3, 21],
    "typing": [1, 0, 6, 11],
    "description": "**F*** (pronounced _F star_) is a functional programming language inspired by ML and aimed at program verification. Its type system includes dependent types, monadic effects, and refinement types. This allows expressing precise specifications for programs, including functional correctness and security properties. The F* type-checker aims to prove that programs meet their specifications using a combination of SMT solving and manual proofs. Programs written in F* can be translated to OCaml, F#, and C for execution. Previous versions of F* could also be translated to JavaScript. The latest version of F* is written entirely in a common subset of F* and F#, and bootstraps in both OCaml and F#. It is open source (under the Apache License 2.0) and is under active development on GitHub."
  },
  "141": {
    "label": "F-Script",
    "wikipedia_pageid": 899874,
    "inception": { "time": "+2009-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 20],
    "typing": [10],
    "description": "**F-Script** is an object-oriented scripting programming language for Apple's macOS operating system developed by Philippe Mougin. F-Script is an interactive language based on Smalltalk, using macOS's native Cocoa API."
  },
  "142": {
    "label": "FAUST",
    "wikipedia_pageid": 4532356,
    "inception": { "time": "+2002-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [29],
    "typing": [],
    "description": "**FAUST** (Functional AUdio STream) is a domain-specific purely functional programming language for implementing signal processing algorithms in the form of libraries, audio plug-ins, or standalone applications. A FAUST program denotes a signal processor: a mathematical function that is applied to some input signal and then fed out."
  },
  "143": {
    "label": "FP",
    "wikipedia_pageid": 899253,
    "inception": { "time": "+1977-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [32],
    "typing": [],
    "description": "**FP** (short for _functional programming_) is a programming language created by John Backus to support the function-level programming paradigm. It allows building programs from a set of generally useful primitives and avoiding named variables (a style also called tacit programming or \"point free\"). It was heavily influenced by APL which was developed by Kenneth E. Iverson in the early 1960s. The FP language was introduced in Backus's 1977 Turing Award paper, \"Can Programming Be Liberated from the von Neumann Style?\", subtitled \"a functional style and its algebra of programs.\" The paper sparked interest in functional programming research, eventually leading to modern functional languages (which are largely founded on the lambda calculus paradigm), and not the function- level paradigm Backus had hoped. In his Turing award paper, Backus described how the FP style is different: > An FP system is based on the use of a fixed set of combining forms called > functional forms. These, plus simple definitions, are the only means of > building new functions from existing ones; they use no variables or > substitutions rules, and they become the operations of an associated algebra > of programs. All the functions of an FP system are of one type: they map > objects onto objects and always take a single argument. FP itself never found much use outside of academia. In the 1980s Backus created a successor language, FL, which was an internal project at IBM Research."
  },
  "144": {
    "label": "FL",
    "wikipedia_pageid": 2857297,
    "inception": { "time": "+1989-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [32, 21],
    "typing": [10],
    "description": "**FL** (short for \"Function Level\") is a programming language created at the IBM Almaden Research Center by John Backus, John Williams, and Edward Wimmers in the 1980s and documented in a report from 1989. FL was designed as a successor of Backus' earlier FP language, providing specific support for what Backus termed function-level programming. FL is a dynamically typed strict functional programming language with throw and catch exception semantics much like in ML. Each function has an implicit history argument which is used for doing things like strictly functional input/output (I/O), but is also used for linking to C code. For doing optimization, there exists a type-system which is an extension of Hindley–Milner type inference."
  },
  "145": {
    "label": "FLOW-MATIC",
    "wikipedia_pageid": 82760,
    "inception": { "time": "+1955-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3],
    "typing": [],
    "description": "**FLOW-MATIC**, originally known as **B-0** (**Business Language version 0**), was the first English-like data processing language. It was developed for the UNIVAC I at Remington Rand under Grace Hopper from 1955 to 1959, and helped shape the development of COBOL."
  },
  "146": {
    "label": "FOCAL",
    "wikipedia_pageid": 1170592,
    "inception": { "time": "+1968-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**FOCAL** is an interactive interpreted programming language based on JOSS and primarily used on Digital Equipment Corporation (DEC) PDP-series machines. The name is an acronym for **F** ormulating **O** n-Line **C** alculations in **A** lgebraic **L** anguage, or for **FO** rmula **CAL** culator. FOCAL is very similar to JOSS in terms of the commands it supports and the general syntax of the language. It differs in that many of JOSS' advanced features like ranges and user-defined functions were removed to simplify the parser. Some of the keywords were renamed so that they all start with a unique first letter. This allows users to type in programs using single-character statements, further reducing memory needs. This was an important consideration on the PDP-8, which was often limited to a few kilobytes (KB). Like JOSS, and later BASICs, FOCAL on the PDP-8 was a complete environment that included a line editor, the interpreter, and input/output routines. The package as a whole was called **FOCAL-8**, which also ran on the PDP-5 and PDP-12. When ported to the PDP-11, the resulting **FOCAL-11** relied on the underlying operating system, RT-11, to provide file support and editing. The language definition was updated twice, to **FOCAL-69** and a very slightly modified **FOCAL-71**. A port to the Intel 8080 was also available. FOCAL is notable as the language in which the original versions of the early video games _Hamurabi_ and _Lunar Lander_ were written. Both were later ported to BASIC, where they became much better known. FOCAL was not popular outside the PDP platform and largely disappeared during the move to the VAX-11. It had a strong revival in the Soviet Union where PDP-11 clones were used as educational and home computers."
  },
  "147": {
    "label": "FORMAC",
    "wikipedia_pageid": 2667822,
    "inception": { "time": "+1964-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**FORMAC**, the **FOR** mula **MA** nipulation **C** ompiler, was the first computer algebra system to have significant use. It was developed by Jean E. Sammet and her team, as an extension of FORTRAN IV. The compiler was implemented as a preprocessor taking the FORMAC program and converting it to a FORTRAN IV program which was in turn compiled without further user intervention. Initial development started in 1962 and was complete by April 1964. In November it was released to IBM customers. FORMAC supported computation, manipulation, and use of symbolic expressions. In addition it supported rational arithmetic."
  },
  "148": {
    "label": "FP",
    "wikipedia_pageid": 899253,
    "inception": { "time": "+1977-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [32],
    "typing": [],
    "description": "**FP** (short for _functional programming_) is a programming language created by John Backus to support the function-level programming paradigm. It allows building programs from a set of generally useful primitives and avoiding named variables (a style also called tacit programming or \"point free\"). It was heavily influenced by APL which was developed by Kenneth E. Iverson in the early 1960s. The FP language was introduced in Backus's 1977 Turing Award paper, \"Can Programming Be Liberated from the von Neumann Style?\", subtitled \"a functional style and its algebra of programs.\" The paper sparked interest in functional programming research, eventually leading to modern functional languages (which are largely founded on the lambda calculus paradigm), and not the function- level paradigm Backus had hoped. In his Turing award paper, Backus described how the FP style is different: > An FP system is based on the use of a fixed set of combining forms called > functional forms. These, plus simple definitions, are the only means of > building new functions from existing ones; they use no variables or > substitutions rules, and they become the operations of an associated algebra > of programs. All the functions of an FP system are of one type: they map > objects onto objects and always take a single argument. FP itself never found much use outside of academia. In the 1980s Backus created a successor language, FL, which was an internal project at IBM Research."
  },
  "149": {
    "label": "Factor",
    "wikipedia_pageid": 891398,
    "inception": { "time": "+2003-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [33, 23, 21],
    "typing": [10, 1],
    "description": "**Factor** is a stack-oriented programming language created by Slava Pestov. Factor is dynamically typed and has automatic memory management, as well as powerful metaprogramming features. The language has a single implementation featuring a self-hosted optimizing compiler and an interactive development environment. The Factor distribution includes a large standard library."
  },
  "150": {
    "label": "Fantom",
    "wikipedia_pageid": 18969637,
    "inception": { "time": "+2005-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [10, 11],
    "description": "**Fantom** is a general purpose object-oriented programming language created by Brian and Andy Frank that runs on the Java Runtime Environment (JRE), JavaScript, and the .NET Common Language Runtime (CLR) (.NET support is considered \"prototype\" status). Its primary design goal is to provide a standard library API that abstracts away the question of whether the code will ultimately run on the JRE or CLR. Like C# and Java, Fantom uses a curly brace syntax. The language supports functional programming through closures and concurrency through the Actor model. Fantom takes a \"middle of the road\" approach to its type system, blending together aspects of both static and dynamic typing."
  },
  "151": {
    "label": "Fjölnir",
    "wikipedia_pageid": 3236625,
    "inception": { "time": "+1980-01-01T00:00:00Z", "precision": 8 },
    "paradigm": [6, 2],
    "typing": [10, 1],
    "description": "**Fjölnir** (also **Fjolnir** or **Fjoelnir**) is a programming language developed by professor Snorri Agnarsson of computer science at Háskóli Íslands (University of Iceland) that was mostly used in the 1980s. The source files usually have the extension `fjo` or `sma`."
  },
  "152": {
    "label": "Flavors",
    "wikipedia_pageid": 1332640,
    "inception": { "time": "+1982-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [],
    "description": "**Flavors**, an early object-oriented extension to Lisp developed by Howard Cannon at the MIT Artificial Intelligence Laboratory for the Lisp machine and its programming language Lisp Machine Lisp, was the first programming language to include mixins. Symbolics used it for its Lisp machines, and eventually developed it into **New Flavors** ; both the original and new Flavors were message passing OO models. It was hugely influential in the development of the Common Lisp Object System (CLOS). Implementations of Flavors are also available for Common Lisp. New Flavors replaced message sending with calling generic functions. Flavors offers `:before` and `:after` daemons with the default method combination (called `:daemon`)."
  },
  "153": {
    "label": "Flix",
    "wikipedia_pageid": 65082743,
    "inception": { "time": "+2016-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [28, 3, 21],
    "typing": [1, 12, 6, 11],
    "description": "**Flix** is a functional, imperative, and logic programming language developed at Aarhus University, with funding from the Independent Research Fund Denmark, and by a community of open source contributors. The Flix language supports algebraic data types, pattern matching, parametric polymorphism, currying, higher-order functions, extensible records, channel and process-based concurrency, and tail call elimination. Two notable features of Flix are its type and effect system and its support for first-class Datalog constraints. The Flix type and effect system supports Hindley-Milner-style type inference. The system separates pure and impure code: if an expression is typed as pure then it cannot produce an effect at run-time. Higher-order functions can enforce that they are given pure (or impure) function arguments. The type and effect system supports effect polymorphism which means that the effect of a higher-order function may depend on the effect(s) of its argument(s). Flix supports Datalog programs as first-class values. A Datalog program value, i.e. a collection of Datalog facts and rules, can be passed to and returned from functions, stored in data structures, and composed with other Datalog program values. The minimal model of a Datalog program value can be computed and is itself a Datalog program value. In this way, Flix can be viewed as a meta programming language for Datalog. Flix supports stratified negation and the Flix compiler ensures stratification at compile-time. Flix also supports an enriched form of Datalog constraints where predicates are given lattice semantics."
  },
  "154": {
    "label": "Forth",
    "wikipedia_pageid": 11012,
    "inception": { "time": "+1970-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 9, 23, 33],
    "typing": [],
    "description": "**Forth** is a procedural, stack-based programming language and interactive environment designed by Charles H. \"Chuck\" Moore and first used by other programmers in 1970. Although not an acronym, the language's name in its early years was often spelled in all capital letters as _FORTH_, but _Forth_ is more common. Forth combines a compiler with an integrated command shell, where the user interacts via subroutines called _words_. Words can be defined, tested, redefined, and debugged without recompiling or restarting the whole program. All syntactic elements, including variables and basic operators, are defined as words. A stack is used to pass parameters between words, leading to a Reverse Polish Notation style. For much of Forth's existence, the standard technique was to compile to threaded code, which can be interpreted faster than bytecode. One of the early benefits of Forth was size: an entire development environment—including compiler, editor, and user programs—could fit in memory on an 8-bit or similarly limited system. No longer constrained by space, there are modern implementations that generate optimized machine code like other language compilers. Forth is used in the Open Firmware boot loader, in space applications such as the Philae spacecraft, and in other embedded systems which involve interaction with hardware. The relative simplicity of creating a basic Forth system has led to many personal and proprietary variants, such as the custom Forth used to implement the bestselling 1986 video game _Starflight_ from Electronic Arts. The free software Gforth implementation is actively maintained, as are several commercially supported systems. Moore later developed a series of microprocessors for executing compiled Forth-like code directly and experimented with smaller languages based on Forth concepts, including cmForth and colorForth."
  },
  "155": {
    "label": "Fortran",
    "wikipedia_pageid": 11168,
    "inception": { "time": "+1957-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 20, 6, 26, 36],
    "typing": [1, 14, 11],
    "description": "**Fortran** (; formerly **FORTRAN**, derived from _Formula Translation_) is a general-purpose, compiled imperative programming language that is especially suited to numeric computation and scientific computing. Originally developed by IBM in the 1950s for scientific and engineering applications, FORTRAN came to subsequently dominate scientific computing. It has been in use for over six decades in computationally intensive areas such as numerical weather prediction, finite element analysis, computational fluid dynamics, geophysics, computational physics, crystallography and computational chemistry. It is a popular language for high-performance computing and is used for programs that benchmark and rank the world's fastest supercomputers. Fortran has had multiple versions, each adding extensions while largely retaining compatibility with prior versions. Successive versions have added support for structured programming and processing of character-based data (FORTRAN 77), array programming, modular programming and generic programming (Fortran 90), high performance Fortran (Fortran 95), object-oriented programming (Fortran 2003), concurrent programming (Fortran 2008), and native parallel computing capabilities (Coarray Fortran 2008/2018). Fortran's design was the basis for many other programming languages. Among the better-known is BASIC, which is based on FORTRAN II with a number of syntax cleanups, notably better logical structures, and other changes to work more easily in an interactive environment. As of July 2021, Fortran was ranked 14th in the TIOBE index, a measure of the popularity of programming languages, climbing 20 positions from its ranking of 34th in January 2020."
  },
  "156": {
    "label": "Fortress",
    "wikipedia_pageid": 1822171,
    "inception": { "time": "+2006-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [11],
    "description": "**Fortress** is a discontinued experimental programming language for high- performance computing, created by Sun Microsystems with funding from DARPA's High Productivity Computing Systems project. One of the language designers was Guy L. Steele Jr., whose previous work includes Scheme, Common Lisp, and Java."
  },
  "157": {
    "label": "FoxPro",
    "wikipedia_pageid": 7419372,
    "inception": { "time": "+1991-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 2],
    "typing": [],
    "description": "**FoxPro** was a text-based procedurally oriented programming language and database management system (DBMS), and it was also an object-oriented programming language, originally published by Fox Software and later by Microsoft, for MS-DOS, Windows, Macintosh, and UNIX. The final published release of FoxPro was 2.6. Development continued under the Visual FoxPro label, which in turn was discontinued in 2007. FoxPro was derived from FoxBase (Fox Software, Perrysburg, Ohio), which was in turn derived from dBase III (Ashton-Tate) and dBase II. dBase II was the first commercial version of a database program written by Wayne Ratliff, called Vulcan, running on CP/M, as does dBase II. FoxPro was both a DBMS and a relational database management system (RDBMS), since it extensively supported multiple relationships between multiple DBF files (tables). However, it lacked transactional processing. FoxPro was sold and supported by Microsoft after they acquired Fox Software in its entirety in 1992. At that time there was an active worldwide community of FoxPro users and programmers. FoxPro 2.6 for UNIX (FPU26) has even been successfully installed on Linux and FreeBSD using the Intel Binary Compatibility Standard (ibcs2) support library."
  },
  "158": {
    "label": "Franz Lisp",
    "wikipedia_pageid": 2188401,
    "inception": { "time": "+1980-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [25, 2, 9, 21],
    "typing": [10, 1],
    "description": "In computer programming,**Franz Lisp** is a discontinued Lisp programming language system written at the University of California, Berkeley (UC Berkeley, UCB) by Professor Richard Fateman and several students, based largely on Maclisp and distributed with the Berkeley Software Distribution (BSD) for the Digital Equipment Corporation (DEC) VAX minicomputer. Piggybacking on the popularity of the BSD package, Franz Lisp was probably the most widely distributed and used Lisp system of the 1970s and 1980s. The name is a pun on the composer and pianist Franz Liszt. It was written specifically to be a host for running the Macsyma computer algebra system on VAX. The project began at the end of 1978, soon after UC Berkeley took delivery of their first VAX 11/780 (named Ernie CoVax, after Ernie Kovacs, the first of many systems with pun names at UCB). Franz Lisp was available free of charge to educational sites, and was also distributed on Eunice, a Berkeley Unix emulator that ran on VAX VMS."
  },
  "159": {
    "label": "friendly interactive shell",
    "wikipedia_pageid": 1889847,
    "inception": { "time": "+2005-02-13T00:00:00Z", "precision": 11 },
    "paradigm": [],
    "typing": [],
    "description": "**fish** is a Unix shell with a focus on interactivity and usability. Fish is designed to give the user features by default, rather than by configuration. Fish is considered an exotic shell since it does not rigorously adhere to POSIX shell standards, at the discretion of the maintainers."
  },
  "160": {
    "label": "Futhark",
    "wikipedia_pageid": 62334821,
    "inception": { "time": "+2014-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [29, 20],
    "typing": [1, 11],
    "description": "**Futhark** is a functional data parallel array programming language originally developed at DIKU as part of the HIPERFIT project. It focuses on enabling data parallel programs written in a functional style to be executed with high performance on massively parallel hardware, in particular on GPUs. Futhark is strongly inspired by NESL, but imposes constraints on how parallelism can be expressed in order to enable more aggressive compiler optimisations. In particular, irregular nested data parallelism is not supported."
  },
  "161": {
    "label": "G-code",
    "wikipedia_pageid": 1027403,
    "inception": { "time": "+1950-01-01T00:00:00Z", "precision": 8 },
    "paradigm": [2, 3],
    "typing": [],
    "description": "**G-code** (also **RS-274**) is the most widely used computer numerical control (CNC) programming language. It is used mainly in computer-aided manufacturing to control automated machine tools, and has many variants. G-code instructions are provided to a machine controller (industrial computer) that tells the motors where to move, how fast to move, and what path to follow. The two most common situations are that, within a machine tool such as a lathe or mill, a cutting tool is moved according to these instructions through a toolpath cutting away material to leave only the finished workpiece and/or, an unfinished workpiece is precisely positioned in any of up to nine axes around the three dimensions relative to a toolpath and, either or both can move relative to each other. The same concept also extends to noncutting tools such as forming or burnishing tools, photoplotting, additive methods such as 3D printing, and measuring instruments."
  },
  "162": {
    "label": "GAP",
    "wikipedia_pageid": 262144,
    "inception": { "time": "+1986-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**GAP** (Groups, Algorithms and Programming) is a computer algebra system for computational discrete algebra with particular emphasis on computational group theory."
  },
  "163": {
    "label": "GEORGE",
    "wikipedia_pageid": 36133392,
    "inception": { "time": "+1957-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**GEORGE** (General Order Generator) is a programming language invented by Charles Leonard Hamblin in 1957. It was designed around a push-down pop-up stack for arithmetic operations, and employed reverse Polish notation. The language included loops, subroutines, conditionals, vectors, and matrices. Algebraic expressions were written in reverse Polish notation; thus,  a + b {\\displaystyle a+b} was written `a b +`, and similarly for the other arithmetic operations of subtraction, multiplication, and division. The algebraic expression  a x 2 + b x + c {\\displaystyle ax^{2}+bx+c} was written `a x dup × × b x × + c +`, where '`dup`' meant 'duplicate the value'. Following the reverse Polish form, an assignment statement to evaluate the formula  y = a x 2 + b x + c {\\displaystyle y=ax^{2}+bx+c} was written as `a x dup × × b x × + c + (y)`. The computer evaluated the expression as follows: the values of `a`, then `x`, were pushed onto the top of the accumulator stack; '`dup`' caused a copy of the top-most value (`x`) to be pushed onto the top of the accumulator stack; Multiply (`×`) caused the top two values, namely, `x` and `x`, to be removed (popped) and multiplied, returning the product to the top of the accumulator stack. The second multiply (`×`) then caused the top two values on the stack (namely, `a` and `x**2`) to be popped and multiplied, and the product (`a×x**2`) to be pushed onto the top of the accumulator stack. And so on the remaining components of the expression. The final operation, namely (`y`), returned the value of the expression to storage without changing the status of the accumulator stack. Assuming that the value on the top of the accumulator stack was not required immediately, it would be removed (cleared) by using the operator (`;`). The following program reads in eight values and forms their sum:               0,     1, 8 rep (j)        R +     ]     (P)          The first line initialises the sum by pushing the value zero onto the top of the accumulator stack.     The second line introduces a loop, is spoken as \"for 1 to 8 repeat for j\", and is terminated by the square bracket.     In the third line, R causes one number to be read in and pushed onto the top of the accumulator stack, and the plus sign (+) causes that value to be added to the (partial) sum, leaving only the partial sum on the top of the accumulator stack.     After the loop terminates, the (P) causes the final sum to be punched on a card. Manipulation of vectors and matrices requires subscript notation. In GEORGE, the subscript(s) preceded the vector or matrix name. Thus A(j) was written `j | A`. The following program reads in vector _a_ of 10 values, then forms the squares of those values, and finally prints those values.               1, 10 R1 (a)     1, 10 rep (j)        j | a dup * j | (a) ;     ]     1, 10 P1 (a)          In the program, the first line is a vector read that reads in the ten values into a(1) through a(10).     The second line introduces a loop to run through the ten values of j.     The third line fetches a(j), duplicates it, multiplies those two values giving the square, and then stores it in a(j). Note the semicolon (;), which clears (or cancels) the top entry in the accumulator stack. Were this not done, the accumulator would gradually fill up with the squares of the values.     The final line is a vector punch (i.e., print) to write out the ten squares. The above GEORGE coding table assisted in transcribing a program onto punch cards. Conditional operations were written as jumps, as follows: if a > 0 go to 5 (which transfers to label 5 if a is greater than zero) would be written               0 a > 5 ↑  Label 5 was indicated by including *5 elsewhere in the program. Unconditional transfers were written 5↑ Subroutine calls were made with the down arrow, .g., to call subroutine labelled 17, write 17↓, where the label 17 was encoded using column 3 of the above table."
  },
  "164": {
    "label": "GNU E",
    "wikipedia_pageid": 30196706,
    "inception": { "time": "+1991-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [1],
    "description": "**GNU E** is an extension of C++ designed for writing software systems to support persistent applications. It was designed as part of the Exodus project."
  },
  "165": {
    "label": "GNU Guile",
    "wikipedia_pageid": 1436948,
    "inception": { "time": "+1993-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**GNU Ubiquitous Intelligent Language for Extensions** (**GNU Guile**) is the preferred extension language system for the GNU Project and features an implementation of the programming language Scheme. Its first version was released in 1993. In addition to large parts of Scheme standards, Guile Scheme includes modularized extensions for many different programming tasks. For extending programs, Guile offers _libguile_ which allows the language to be embedded in other programs, and integrated closely through the C language application programming interface (API); similarly, new data types and subroutines defined through the C API can be made available as extensions to Guile. Guile is used in programs such as GnuCash, LilyPond, GNU Guix, GNU Debugger, GNU TeXmacs and Google's schism."
  },
  "166": {
    "label": "GNU Octave",
    "wikipedia_pageid": 48707,
    "inception": { "time": "+1988-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [20],
    "typing": [],
    "description": "**GNU Octave** is software featuring a high-level programming language, primarily intended for numerical computations. Octave helps in solving linear and nonlinear problems numerically, and for performing other numerical experiments using a language that is mostly compatible with MATLAB. It may also be used as a batch-oriented language. Since it is part of the GNU Project, it is free software under the terms of the GNU General Public License. Other free alternatives to MATLAB include Scilab and FreeMat. Octave is more compatible with MATLAB than Scilab is, and FreeMat has not been updated since June 2013."
  },
  "167": {
    "label": "GPSS",
    "wikipedia_pageid": 577078,
    "inception": { "time": "+1960-01-01T00:00:00Z", "precision": 8 },
    "paradigm": [],
    "typing": [],
    "description": "**General Purpose Simulation System** (**GPSS**) is a discrete time simulation general-purpose programming language, where a simulation clock advances in discrete steps. A system is modelled as transactions enter the system and are passed from one service (represented by blocks) to another. It is used primarily as a process flow oriented simulation language; this is particularly well-suited for problems such as a factory."
  },
  "168": {
    "label": "GRASS",
    "wikipedia_pageid": 144766,
    "inception": { "time": "+1974-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2],
    "typing": [],
    "description": "**GRASS** (_GRAphics Symbiosis System_) is a programming language created to script 2D vector graphics animations. GRASS was similar to BASIC in syntax, but added numerous instructions for specifying 2D object animation, including scaling, translation and rotation over time. These functions were directly supported by the Vector General 3D graphics terminal GRASS was written for. It quickly became a hit with the artistic community who were experimenting with the new medium of computer graphics, and is most famous for its use by Larry Cuba to create the original \"attacking the Death Star will not be easy\" animation in _Star Wars_ (1977). As part of a later partnership with Midway Games, the language was ported to the Midway's Z-80-based Z Box. This machine used raster graphics and a form of sprites, which required extensive changes to support, along with animating color changes. This version was known as **ZGrass**."
  },
  "169": {
    "label": "GameMaker Studio",
    "wikipedia_pageid": 555154,
    "inception": { "time": "+1999-11-15T00:00:00Z", "precision": 11 },
    "paradigm": [],
    "typing": [],
    "description": "**GameMaker** (originally **Animo** and later **Game Maker** until 2011) is a series of cross-platform game engines created by Mark Overmars in 1999 and developed by YoYo Games since 2007. The latest iteration is GameMaker Studio 2, first released in 2017. GameMaker accommodates the creation of cross-platform and multi-genre video games using a custom drag-and-drop visual programming language or a scripting language known as Game Maker Language, which can be used to develop more advanced games that could not be created just by using the drag and drop features. GameMaker was originally designed to allow novice computer programmers to be able to make computer games without much programming knowledge by use of these actions. Recent versions of software also focus on appealing to advanced developers."
  },
  "170": {
    "label": "Game Oriented Assembly Lisp",
    "wikipedia_pageid": 4993415,
    "inception": { "time": "+2001-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 3],
    "typing": [10, 1],
    "description": "**Game Oriented Assembly Lisp** (**GOAL**) is a programming language, a dialect of the language Lisp, made for video games developed by Andy Gavin and the _Jak and Daxter_ team at the company Naughty Dog. It was written using Allegro Common Lisp and used in the development of the entire _Jak and Daxter_ series of games."
  },
  "171": {
    "label": "General Algebraic Modeling System",
    "wikipedia_pageid": 1438314,
    "inception": { "time": "+1976-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "The **General Algebraic Modeling System** (**GAMS**) is a high-level modeling system for mathematical optimization. GAMS is designed for modeling and solving linear, nonlinear, and mixed-integer optimization problems. The system is tailored for complex, large-scale modeling applications and allows the user to build large maintainable models that can be adapted to new situations. The system is available for use on various computer platforms. Models are portable from one platform to another. GAMS was the first algebraic modeling language (AML) and is formally similar to commonly used fourth-generation programming languages. GAMS contains an integrated development environment (IDE) and is connected to a group of third- party optimization solvers. Among these solvers are BARON, COIN-OR solvers, CONOPT, CPLEX, DICOPT, Gurobi, MOSEK, SNOPT, SULUM, and XPRESS. GAMS allows the users to implement a sort of hybrid algorithm combining different solvers. Models are described in concise, human-readable algebraic statements. GAMS is among the most popular input formats for the NEOS Server. Although initially designed for applications related to economics and management science, it has a community of users from various backgrounds of engineering and science."
  },
  "172": {
    "label": "Genie",
    "wikipedia_pageid": 25291443,
    "inception": { "time": "+2008-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 3, 36],
    "typing": [1, 11],
    "description": "**Genie** is a modern, general-purpose high-level programming language in development since 2008. It was designed as an alternative, simpler and cleaner dialect for the Vala compiler, while preserving the same functionality of the Vala language. Genie uses the same compiler and libraries as Vala; the two can indeed be used alongside each other. The differences are only syntactic. Genie's syntax is derived from numerous modern languages like Python, Boo, D and Delphi. In the vein of Pascal and Python, Genie uses indentation rather than curly brackets to delimit blocks. Like Vala, Genie uses the GObject type system to create classes and interfaces declared in Genie source code, without imposing additional runtime requirements (i.e., unlike Python, Java or C#, it does not require a virtual machine). Genie allows access to C libraries, especially those based in GObject (like GTK), without using a different application binary interface (ABI). During compilation, the code is first translated to C source and header files, which are then compiled to platform-specific machine code using any available C compiler like GCC, thus allowing cross-platform software development. Programs developed in Vala and Genie do not depend on the GNOME Desktop Environment, usually requiring only GLib."
  },
  "173": {
    "label": "Go",
    "wikipedia_pageid": 25039021,
    "inception": { "time": "+2009-11-10T00:00:00Z", "precision": 11 },
    "paradigm": [2, 3, 21, 6, 16, 36],
    "typing": [6, 12, 11, 13, 1],
    "description": "**Go** is a statically typed, compiled programming language designed at Google by Robert Griesemer, Rob Pike, and Ken Thompson. Go is syntactically similar to C, but with memory safety, garbage collection, structural typing, and CSP- style concurrency. The language is often referred to as **Golang** because of its domain name, `golang.org`, but the proper name is Go. There are two major implementations:   * Google's self-hosting compiler toolchain targeting multiple operating systems, and WebAssembly.   * gccgo, a GCC frontend. A third-party source-to-source compiler, GopherJS, compiles Go to JavaScript for front-end web development."
  },
  "174": {
    "label": "Go!",
    "wikipedia_pageid": 25045328,
    "inception": { "time": "+2003-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [28, 3, 16, 21],
    "typing": [1],
    "description": "**Go!** is an agent-based programming language in the tradition of logic-based programming languages like Prolog. It was introduced in a 2003 paper by Francis McCabe and Keith Clark."
  },
  "175": {
    "label": "Godot",
    "wikipedia_pageid": 42097999,
    "inception": { "time": "+2007-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**Godot** (/ɡəˈdoʊ/ ) is a cross-platform, free and open-source game engine released under the MIT license. It was initially developed by Argentine software developers Juan Linietsky and Ariel Manzur for several companies in Latin America prior to its public release. The development environment runs on multiple operating systems including Linux, BSDs, macOS, and Microsoft Windows. It is designed to create both 2D and 3D games targeting PC, mobile, and web platforms."
  },
  "176": {
    "label": "Golo",
    "wikipedia_pageid": 47051765,
    "inception": { "time": "+2012-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [10, 2],
    "description": "**Golo** is computer software, a programming language for the Java virtual machine (JVM). It is simple, with dynamic, weak typing. It was created in 2012 as part of the research activities of the DynaMid group of the Centre of Innovation in Telecommunications and Integration of service (CITI) Laboratory at Institut national des sciences appliquées de Lyon (INSA). It is distributed as free and open-source software under the Eclipse Public License 2.0."
  },
  "177": {
    "label": "Gosu",
    "wikipedia_pageid": 29539307,
    "inception": { "time": "+2002-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [11],
    "description": "**Gosu** is a statically-typed general-purpose programming language that runs on the Java Virtual Machine. Its influences include Java, C#, and ECMAScript. Development of Gosu began in 2002 internally for Guidewire Software, and the language saw its first community release in 2010 under the Apache 2 license. Gosu can serve as a scripting language, having free-form Program types (.gsp files) for scripting as well as statically verified Template files (.gst files). Gosu can optionally execute these and all other types directly from source without precompilation, which also distinguishes it from other static languages."
  },
  "178": {
    "label": "Grasshopper 3d",
    "wikipedia_pageid": 30776767,
    "inception": { "time": "+2007-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [10],
    "typing": [],
    "description": "**Grasshopper** is a visual programming language and environment that runs within the Rhinoceros 3D computer-aided design (CAD) application. The program was created by David Rutten at Robert McNeel & Associates. Programs are created by dragging components onto a canvas. The outputs to these components are then connected to the inputs of subsequent components."
  },
  "179": {
    "label": "Gödel",
    "wikipedia_pageid": 936719,
    "inception": { "time": "+1992-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [28, 13],
    "typing": [1],
    "description": "**Gödel** is a declarative, general-purpose programming language that adheres to the logic programming paradigm. It is a strongly typed language, the type system being based on many-sorted logic with parametric polymorphism. It is named after logician Kurt Gödel."
  },
  "180": {
    "label": "Haggis",
    "wikipedia_pageid": 52222071,
    "inception": null,
    "paradigm": [6, 3, 21],
    "typing": [12, 6],
    "description": "**Haggis** is a high-level reference programming language used primarily to examine computing science for Scottish pupils taking SQA courses on the subject. Haggis is used as a tool to bridge the gap between pseudocode and typical computer programming. Haggis is not based on any one language but a mixture that is intended to allow a pupil familiar with any of the many languages used in classrooms to easily understand the syntactic construct being used in an example. It has multiple programming paradigms of functional, imperative and object-oriented to suit this purpose. There are three separate language definitions, one for each level at which computing is assessed by the SQA; these are proper subsets of each other, so for example any program contained by the National 5 level language is also well-defined at Higher and Advanced Higher levels. Higher includes the definition of procedures and functions and the use of record types and files, while Advanced Higher includes object-orientation. Online Haggis interpreters have been developed to provide a way for examiners and teachers to check their programs are correctly defined and behave as expected."
  },
  "181": {
    "label": "HAL/S",
    "wikipedia_pageid": 267538,
    "inception": { "time": "+1978-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**HAL/S** (_ **H** igh-order **A** ssembly **L** anguage **/S** huttle_) is a real-time aerospace programming language compiler and cross-compiler for avionics applications used by NASA and associated agencies (JPL, etc.). It has been used in many U.S. space projects since 1973 and its most significant use was in the Space Shuttle program (approximately 85% of the Shuttle software is coded in HAL/S). It was designed by Intermetrics in 1972 for NASA and delivered in 1973. HAL/S is written in XPL, a dialect of PL/I. Although HAL/S is designed primarily for programming on-board computers, it is general enough to meet nearly all the needs in the production, verification, and support of aerospace and other real-time applications. According to documentation from 2005, it was being maintained by the HAL/S project of United Space Alliance."
  },
  "182": {
    "label": "Hack",
    "wikipedia_pageid": 42257880,
    "inception": { "time": "+2014-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [2, 6, 5, 10, 11],
    "description": "**Hack** is a programming language for the HipHop Virtual Machine (HHVM), created by Facebook as a dialect of PHP. The language implementation is open- source, licensed under the MIT License. Hack allows programmers to use both dynamic typing and static typing. This kind of a type system is called gradual typing, which is also implemented in other programming languages such as ActionScript. Hack's type system allows types to be specified for function arguments, function return values, and class properties; however, types of local variables are always inferred and cannot be specified."
  },
  "183": {
    "label": "Halide",
    "wikipedia_pageid": 40586943,
    "inception": { "time": "+2012-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [7, 21],
    "typing": [11],
    "description": "**Halide** is a computer programming language designed for writing digital image processing code that takes advantage of memory locality, vectorized computation and multi-core CPUs and GPUs. Halide is implemented as an internal domain-specific language (DSL) in C++."
  },
  "184": {
    "label": "Harbour",
    "wikipedia_pageid": 1882856,
    "inception": { "time": "+1999-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 13, 21, 6, 9],
    "typing": [13, 1, 10],
    "description": "**Harbour** is a computer programming language, primarily used to create database/business programs. It is a modernized, open sourced and cross- platform version of the older Clipper system, which in turn developed from the dBase database market of the 1980s and 1990s. Harbour code using the same databases can be compiled under a wide variety of platforms, including Microsoft Windows, Linux, Unix variants, several BSD descendants, Mac OS X, MINIX 3, Windows CE, Pocket PC, Symbian, iOS, Android, QNX, VxWorks, OS/2 (including eComStation and ArcaOS), BeOS/Haiku, AIX and MS- DOS."
  },
  "185": {
    "label": "Hartmann pipeline",
    "wikipedia_pageid": 692211,
    "inception": { "time": "+1986-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [22, 32, 23, 21],
    "typing": [],
    "description": "**CMS Pipelines** implements the pipeline concept under the VM/CMS operating system. The programs in a pipeline operate on a sequential stream of records. A program writes records that are read by the next program in the pipeline. Any program can be combined with any other because reading and writing is done through a device independent interface."
  },
  "186": {
    "label": "Haskell",
    "wikipedia_pageid": 27404990,
    "inception": { "time": "+1990-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [29, 21],
    "typing": [1, 6, 11],
    "description": "**Haskell** () is a general-purpose, statically typed, purely functional programming language with type inference and lazy evaluation. Designed for teaching, research and industrial application, Haskell has pioneered a number of advanced programming language features such as type classes, which enable type-safe operator overloading. Haskell's main implementation is the Glasgow Haskell Compiler (GHC). It is named after logician Haskell Curry. Haskell's semantics are historically based on those of the Miranda programming language, which served to focus the efforts of the initial Haskell working group. The last formal specification of the language was made in July 2010, while the development of GHC has expanded Haskell via language extensions. The next formal specification was planned for 2020. Haskell is used in academia and industry. As of May 2021, Haskell was the 28th most popular programming language in terms of Google searches for tutorials and made up less than 1% of active users on the GitHub source code repository."
  },
  "187": {
    "label": "Haxe",
    "wikipedia_pageid": 5404706,
    "inception": { "time": "+2005-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 21, 26],
    "typing": [6, 10, 4, 11],
    "description": "**Haxe** is an open source high-level cross-platform programming language and compiler that can produce applications and source code, for many different computing platforms from one code-base. It is free and open-source software, released under the MIT License. The compiler, written in OCaml, is released under the GNU General Public License (GPL) version 2. Haxe includes a set of features and a standard library supported across all platforms, like numeric data types, strings, arrays, maps, binary, reflection, math, http, file system and common file formats. Haxe also includes platform- specific API's for each compiler target. Kha, OpenFL and Heaps.io are popular Haxe frameworks that enable creating multi-platform content from one codebase. Haxe originated with the idea of supporting client-side and server-side programming in one language, and simplifying the communication logic between them. Code written in the Haxe language can be compiled into JavaScript, C++, Java, JVM, PHP, C#, Python, Lua and Node.js. Haxe can also directly compile SWF, HashLink and Neko bytecode and also runs in interpreted mode. Haxe supports externs (definition files) that can contain type information of existing libraries to describe target-specific interaction in a type-safe manner, like C++ header files can describe the structure of existing object files. This enables to use the values defined in the files as if they were statically typed Haxe entities. Beside externs, other solutions exist to access each platform's native capabilities. Many popular IDEs and source code editors have support available for Haxe development. No particular development environment or tool set is officially recommended by the Haxe Foundation, although VS Code, IntelliJ IDEA and HaxeDevelop have most support for Haxe development. The core functionalities of syntax highlighting, code completion, refactoring, debugging, etc. are available in various degrees."
  },
  "188": {
    "label": "High Level Assembly",
    "wikipedia_pageid": 723581,
    "inception": null,
    "paradigm": [6],
    "typing": [],
    "description": "**High Level Assembly** (**HLA**) is a high-level assembly language developed by Randall Hyde. It allows the use of higher-level language constructs to aid both beginners and advanced assembly developers. It fully supports advanced data types and object-oriented programming. It uses a syntax loosely based on several high-level programming languages (HLLs), such as Pascal, Ada, Modula-2, and C++, to allow creating readable assembly language programs, and to allow HLL programmers to learn HLA as fast as possible."
  },
  "189": {
    "label": "Hollywood",
    "wikipedia_pageid": 27421416,
    "inception": { "time": "+2002-11-01T00:00:00Z", "precision": 10 },
    "paradigm": [2],
    "typing": [],
    "description": "**Hollywood** is a commercially distributed programming language developed by Andreas Falkenhahn (Airsoft Softwair) which mainly focuses on the creation of multimedia-oriented applications. Hollywood is available for AmigaOS, MorphOS, WarpOS, AROS, Windows, macOS, Linux, Android, and iOS. Hollywood has an inbuilt cross compiler that can automatically save executables for all platforms supported by the software. The generated executables are completely stand-alone and do not have any external dependencies, so they can also be started from a USB flash drive. An optional add-on also allows users to compile projects into APK files. The Hollywood Designer is an add-on for Hollywood with which it is possible to use Hollywood also as a presentation software and an authoring system."
  },
  "190": {
    "label": "Hop",
    "wikipedia_pageid": 13433106,
    "inception": { "time": "+2006-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [21],
    "typing": [10, 1],
    "description": "**Hop** is a Lisp-like programming language by Manuel Serrano for web 2.0 and also the name of the web broker (server and proxy) that implements this language. It is written in Bigloo Scheme. It is a project funded by INRIA."
  },
  "191": {
    "label": "Hope",
    "wikipedia_pageid": 933188,
    "inception": { "time": "+1970-01-01T00:00:00Z", "precision": 8 },
    "paradigm": [21],
    "typing": [11],
    "description": "**Hope** is a small functional programming language developed in the 1970s at the University of Edinburgh. It predates Miranda and Haskell and is contemporaneous with ML, also developed at the University. Hope was derived from NPL, a simple functional language developed by Rod Burstall and John Darlington in their work on program transformation. NPL and Hope are notable for being the first languages with call-by-pattern evaluation and algebraic data types. Hope was named for Sir Thomas Hope (c. 1681–1771), a Scottish agricultural reformer, after whom _Hope Park Square_ in Edinburgh, the location of the Department of Artificial Intelligence at the time of the development of Hope, was also named."
  },
  "192": {
    "label": "Hopscotch",
    "wikipedia_pageid": 39338454,
    "inception": null,
    "paradigm": [10],
    "typing": [],
    "description": "**Hopscotch** is a visual programming language developed by Hopscotch Technologies, designed to allow young or beginner programmers to develop simple projects. Its simple UI allows its users to drag and drop blocks to create scripts that can be played when activated. Although the language is easy to use for simple programming, it lacks the power to be used for more complex programs. The use of the language is through an iPad or iPhone supporting Hopscotch."
  },
  "193": {
    "label": "Hume",
    "wikipedia_pageid": 6328175,
    "inception": { "time": "+2000-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [21],
    "typing": [],
    "description": "**Hume** is a functionally based programming language developed at the University of St Andrews and Heriot-Watt University in Scotland since the year 2000. The language name is both an acronym meaning 'Higher-order Unified Meta- Environment' and an honorific to the 18th Century philosopher David Hume. It targets real-time embedded systems, aiming to produce a design that is both highly abstract, yet which will still allow precise extraction of time and space execution costs. This allows programmers to guarantee the bounded time and space demands of executing programs. Hume combines functional programming ideas with ideas from finite state automata. Automata are used to structure communicating programs into a series of \"boxes\", where each box maps inputs to outputs in a purely functional way using high-level pattern-matching. It is structured as a series of levels, each of which exposes different machine properties."
  },
  "194": {
    "label": "HyperTalk",
    "wikipedia_pageid": 78136,
    "inception": { "time": "+1987-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [12, 2],
    "typing": [2],
    "description": "**HyperTalk** is a discontinued high-level, procedural programming language created in 1987 by Dan Winkler and used in conjunction with Apple Computer's HyperCard hypermedia program by Bill Atkinson. Because the main target audience of HyperTalk was beginning programmers, HyperTalk programmers were usually called \"authors\" and the process of writing programs was known as \"scripting\". HyperTalk scripts resembled written English and used a logical structure similar to that of the Pascal programming language. HyperTalk supported the basic control structures of procedural languages: repeat for/while/until, if/then/else, as well as function and message \"handler\" calls (a function handler was a subroutine and a message handler a procedure). Data types usually did not need to be specified by the programmer; conversion happened transparently in the background between strings and numbers. There were no classes or data structures in the traditional sense; in their place were special string literals, or \"lists\" of \"items\" delimited by commas (in later versions the \"itemDelimiter\" property allowed choosing an arbitrary character). Code execution typically began as a response to an event such as a mouse click on a UI widget. In the late 1980s Apple considered using HyperCard's HyperTalk scripting language as the standard language across the company and within its classic Mac OS operating system, as well as for interprocess communication between Apple and non-Apple products. The company did not oppose the development of imitations like SuperCard, but it created the HyperTalk Standards Committee to avoid incompatibility between language variants. The case-insensitive language was initially interpreted, but gained just-in-time compilation with HyperCard 2.0."
  },
  "195": {
    "label": "IBM 1401 Symbolic Programming System",
    "wikipedia_pageid": 14654906,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "The **IBM 1401 Symbolic Programming System** (**SPS**) was an assembler that was developed by Gary Mokotoff, IBM Applied Programming Department, for the IBM 1401 computer, the first of the IBM 1400 series. One source indicates that \"This programming system was announced by IBM with the machine.\" SPS-1 could run on a low-end machine with 1.4K memory, SPS-2 required at least 4K memory.     SPS-1 punched one card for each input instruction in its first pass and this deck had to be read during pass 2. At the University of Chicago and many other locations, SPS-1 was replaced by assemblers taking advantage of the commonly available 4K memory configuration to pack the output of pass one into several instructions per card. Other assemblers were written which placed the pass one output into memory for small programs. As the 1400 series matured additional assemblers, programming languages and report generators became available, replacing SPS in most sites."
  },
  "196": {
    "label": "IBM Basic assembly language",
    "wikipedia_pageid": 4321536,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**Basic Assembly Language** (**BAL**) is the commonly used term for a low- level programming language used on IBM System/360 and successor mainframes. Originally, \"Basic Assembly Language\" applied only to an extremely restricted dialect designed to run under control of IBM Basic Programming Support (BPS/360) on systems with only 8 KB of main memory, and only a card reader, a card punch, and a printer for input/output — thus the word \"Basic\". However, the full name and the initialism \"BAL\" almost immediately attached themselves in popular use to all assembly-language dialects on the System/360 and its descendants. BAL for BPS/360 was introduced with the System/360 in 1964. Assemblers on other System/360 operating systems through System/370, System/390, and System z, as well as the UNIVAC Series 90 mainframes made by Sperry Corporation, and the BS2000 Mainframes currently made by Fujitsu, inherited and extended its syntax. The latest derived language is known as the IBM High-Level Assembler (HLASM). Programmers utilizing this family of assemblers also refer to them as ALC, (for Assembly Language Coding), or simply \"assembler\". BAL is also the mnemonic of the \"Branch And Link\" instruction."
  },
  "197": {
    "label": "IBM HAScript",
    "wikipedia_pageid": 1205430,
    "inception": { "time": "+1990-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**HAScript**, or Host Access Script, is an IBM-developed macro language with an XML syntax designed for programmatic interaction with terminal-based applications. HAScript is based on a state machine principle. The first commercial implementation appeared in IBM's Host On-Demand in the late 1990s. IBM software products that use HAScript include WebSphere Host On-Demand (HOD), Personal Communications, and WebSphere Host Access Transformation Services (HATS). When accessing the IBM Mainframe the HAScript API allows for Host emulation whereby information from the host screen can be retrieved and reformatted within a webpage, or other software application. There has been limited adoption of HAScript as it requires an intense amount of system resources, general process overhead and Java virtual machine resources. To date, the implementation of HAScript by other software companies has been mild as the language used for communication is not universally standardized."
  },
  "198": {
    "label": "IBM Informix-4GL",
    "wikipedia_pageid": 252830,
    "inception": { "time": "+1986-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**Informix-4GL** is a 4GL programming language developed by Informix during the mid-1980s. At the time of its initial release in 1986, supported platforms included Microsoft Xenix (on IBM PC AT), DEC Ultrix (running on Microvax II, VAX-11/750, VAX-11/785, VAX 8600), Altos 2086, AT&T 3B2, AT&T 3B5, AT&T 3B20 and AT&T Unix PC."
  },
  "199": {
    "label": "Report Program Generator",
    "wikipedia_pageid": 632241,
    "inception": { "time": "+1959-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2],
    "typing": [1, 11],
    "description": "**RPG** is a high-level programming language for business applications, introduced in 1959 for the IBM 1401. It is most well known as the primary programming language of IBM's midrange computer product line, including the IBM i operating system. RPG has traditionally featured a number of distinctive concepts, such as the program cycle, and the column-oriented syntax. The most recent version is **RPG IV**, which includes a number of modernization features, including free-form syntax."
  },
  "200": {
    "label": "Interactive Data Language",
    "wikipedia_pageid": 512587,
    "inception": { "time": "+1977-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [20],
    "typing": [10],
    "description": "**IDL**, short for **Interactive Data Language**, is a programming language used for data analysis. It is popular in particular areas of science, such as astronomy, atmospheric physics and medical imaging. IDL shares a common syntax with PV-Wave and originated from the same codebase, though the languages have subsequently diverged in detail. There are also free or costless implementations, such as GNU Data Language (GDL) and Fawlty Language (FL)."
  },
  "201": {
    "label": "ISLISP",
    "wikipedia_pageid": 6976849,
    "inception": { "time": "+1997-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 21, 6, 25, 9],
    "typing": [],
    "description": "**ISLISP** (also capitalized as **ISLisp**) is a programming language in the Lisp family standardized by the International Organization for Standardization (ISO) and International Electrotechnical Commission (IEC) joint working group ISO/IEC JTC 1/SC 22/WG 16 (commonly termed simply SC22/WG16 or WG16). The primary output of this working group was an international standard, published by ISO. The standard was updated in 2007 and republished as ISO/IEC 13816:2007(E). Although official publication was through ISO, versions of the ISLISP language specification are available that are believed to be in the public domain. The goal of this standards effort was to define a small, core language to help bridge the gap between differing dialects of Lisp. It attempted to accomplish this goal by studying primarily Common Lisp, EuLisp, Le Lisp, and Scheme and standardizing only those features shared between them."
  },
  "202": {
    "label": "Icon",
    "wikipedia_pageid": 14801,
    "inception": { "time": "+1977-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [36],
    "typing": [10],
    "description": "**Icon** is a very high-level programming language based on the concept of \"goal-directed execution\" in which code returns a \"success\" along with valid values, or a \"failure\", indicating that there is no valid data to return. The success and failure of a given block of code is used to direct further processing, whereas conventional languages would typically use boolean logic written by the programmer to achieve the same ends. Because the logic for basic control structures is often implicit in Icon, common tasks can be completed with less explicit code. Icon was designed by Ralph Griswold after leaving Bell Labs where he was a major contributor to the SNOBOL language. SNOBOL was a string-processing language with what would be considered dated syntax by the standards of the early 1970s. After moving to the University of Arizona, he further developed the underlying SNOBOL concepts in SL5, but considered the result to be a failure. This led to the significantly updated Icon, which blends the short but conceptually dense code of SNOBOL-like languages with the more familiar syntax of ALGOL-inspired languages like C or Pascal. Like the languages that inspired it, the primary area of use of Icon is managing strings and textual patterns. String operations often fail, for instance, finding \"the\" in \"world\". In most languages, this requires testing and branching to avoid using a non-valid result. In Icon most of these sorts of tests are simply not required, reducing the amount of code written by the programmer. Complex pattern handling can be accomplished in a few lines of terse code, similar to more dedicated languages like Perl but retaining a more function-oriented syntax familiar to users of other ALGOL-like languages. Icon is not object-oriented, but an object-oriented extension called Idol was developed in 1996 which eventually became Unicon. It also inspired other languages, with its simple generators being especially influential; Icon's generators were a major inspirtation for the Python programming language."
  },
  "203": {
    "label": "Idris",
    "wikipedia_pageid": 39035048,
    "inception": { "time": "+2007-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [29, 21],
    "typing": [0, 11],
    "description": "**Idris** is a purely-functional programming language with dependent types, optional lazy evaluation, and features such as a totality checker. Idris may be used as a proof assistant, but it is designed to be a general-purpose programming language similar to Haskell. The Idris type system is similar to Agda's, and proofs are similar to Coq's, including tactics (theorem proving functions/procedures) via elaborator reflection. Compared to Agda and Coq, Idris prioritizes management of side effects and support for embedded domain-specific languages. Idris compiles to C (relying on a custom copying garbage collector using Cheney's algorithm) and JavaScript (both browser- and Node.js-based). There are third-party code generators for other platforms, including JVM, CIL, and LLVM. Idris is named after a singing dragon from the 1970s UK children's television program _Ivor the Engine_."
  },
  "204": {
    "label": "Inform",
    "wikipedia_pageid": 227989,
    "inception": { "time": "+1993-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 2, 13],
    "typing": [6],
    "description": "**Inform** is a programming language and design system for interactive fiction originally created in 1993 by Graham Nelson. Inform can generate programs designed for the Z-code or Glulx virtual machines. Versions 1 through 5 were released between 1993 and 1996. Around 1996, Nelson rewrote Inform from first principles to create version 6 (or **Inform 6**). Over the following decade, version 6 became reasonably stable and a popular language for writing interactive fiction. In 2006, Nelson released **Inform 7** (briefly known as **Natural Inform**), a completely new language based on principles of natural language and a new set of tools based around a book-publishing metaphor."
  },
  "205": {
    "label": "Io",
    "wikipedia_pageid": 323340,
    "inception": { "time": "+2002-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 14],
    "typing": [10, 1],
    "description": "**Io** is a pure object-oriented programming language inspired by Smalltalk, Self, Lua, Lisp, Act1, and NewtonScript. Io has a prototype-based object model similar to the ones in Self and NewtonScript, eliminating the distinction between instance and class. Like Smalltalk, everything is an object and it uses dynamic typing. Like Lisp, programs are just data trees. Io uses actors for concurrency. Remarkable features of Io are its minimal size and openness to using external code resources. Io is executed by a small, portable virtual machine."
  },
  "206": {
    "label": "J",
    "wikipedia_pageid": 73227,
    "inception": { "time": "+1990-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [20, 21, 6, 32, 35],
    "typing": [10],
    "description": "The **J** programming language, developed in the early 1990s by Kenneth E. Iverson and Roger Hui, is an array programming language based primarily on APL (also by Iverson). To avoid repeating the APL special-character problem, J uses only the basic ASCII character set, resorting to the use of the dot and colon as _inflections_ to form short words similar to _digraphs_. Most such _primary_ (or _primitive_) J words serve as mathematical symbols, with the dot or colon extending the meaning of the basic characters available. Also, many characters which in other languages often must be paired (such as `[] {} \"\" ``` or `<>`) are treated by J as stand-alone words or, when inflected, as single-character roots of multi-character words. J is a very terse array programming language, and is most suited to mathematical and statistical programming, especially when performing operations on matrices. It has also been used in extreme programming and network performance analysis. Like John Backus's languages FP and FL, J supports function-level programming via its _tacit programming_ features. Unlike most languages that support object-oriented programming, J's flexible hierarchical namespace scheme (where every name exists in a specific _locale_) can be effectively used as a framework for both class-based and prototype- based object-oriented programming. Since March 2011, J is free and open-source software under the GNU General Public License version 3 (GPLv3). One may also purchase source under a negotiated license."
  },
  "207": {
    "label": "J#",
    "wikipedia_pageid": 419765,
    "inception": { "time": "+2002-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 3, 36],
    "typing": [],
    "description": "**Visual J#** (pronounced \"jay-sharp\") was an implementation of the J# programming language that was a transitional language for programmers of Java and Visual J++ languages, so they could use their existing knowledge and applications with the .NET Framework. It was introduced in 2002 and discontinued in 2007, with support for the final release of the product continuing until October 2017. J# worked with Java bytecode as well as source so it could be used to transition applications that used third-party libraries even if their original source code was unavailable. It was developed by the Hyderabad-based Microsoft India Development Center at HITEC City in India."
  },
  "208": {
    "label": "JADE",
    "wikipedia_pageid": 5887624,
    "inception": { "time": "+1996-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 16],
    "typing": [],
    "description": "**JADE** is a proprietary object-oriented software development and deployment platform product from the New Zealand-based Jade Software Corporation, first released in 1996. It consists of the JADE programming language, Integrated development environment and debugger, integrated application server and object database management system. Designed as an end-to-end development environment to allow systems to be coded in one language from the database server down to the clients, it also provides APIs for other languages, including .NET Framework, Java, C/C++ and Web services. Although a free limited licence is available for development, using the JADE platform requires per-process fees to be paid."
  },
  "209": {
    "label": "JAL",
    "wikipedia_pageid": 2410974,
    "inception": { "time": "+2003-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2],
    "typing": [],
    "description": "**JAL (Just Another Language)** is a Pascal-like programming language and compiler that generates executable code for PIC microcontrollers. It is a free-format language with a compiler that runs on Linux, MS-Windows and MS-DOS (OSX support). It is configurable and extendable through the use of libraries and can even be combined with PIC assembly language."
  },
  "210": {
    "label": "JOSS",
    "wikipedia_pageid": 140643,
    "inception": { "time": "+1963-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**JOSS**, an acronym for **JOHNNIAC Open Shop System**, was one of the first interactive, time-sharing programming languages. It pioneered a number of features that would become common in languages from the 1960s into the 1980s, including the use of line numbers as both editing instructions and targets for branches, statements predicated by boolean decisions, and a built-in editor that can perform instructions in \"direct\" or \"immediate\" mode, what they referred to as a conversational user interface. JOSS was initially implemented on the JOHNNIAC machine at Rand Corporation and put online in 1963. It proved very popular, and the users quickly bogged the machine down. By 1964 a replacement was sought with higher performance. JOHNNIAC was retired in 1966 and replaced by a PDP-6, which ultimately grew to support hundreds of computer terminals based on the IBM Selectric. The terminals used green ink for user input and black for the computer's response. Any command that was not understood elicited the response \"Eh?\" or \"SORRY\". The system was highly influential, spawning a variety of ports and offshoots. Some remained similar to the original, like TELCOMP and STRINGCOMP, CAL, CITRAN, ISIS, PIL/I, JEAN (ICT 1900 series), AID (PDP-10); while others, such as FOCAL and MUMPS, developed in distinctive directions. It also bears a strong resemblance to the BASIC interpreters found on microcomputers in the 1980s, differing primarily in syntax details."
  },
  "211": {
    "label": "JOVIAL",
    "wikipedia_pageid": 224748,
    "inception": { "time": "+1960-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 36],
    "typing": [12, 1, 11],
    "description": "**JOVIAL** is a high-level programming language based on ALGOL 58, specialized for developing embedded systems (specialized computer systems designed to perform one or a few dedicated functions, usually embedded as part of a larger, more complete device, including mechanical parts). It was a major system programming language through the 1960s and 70s."
  },
  "212": {
    "label": "JScript",
    "wikipedia_pageid": 263872,
    "inception": { "time": "+1996-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 14],
    "typing": [10, 13, 2],
    "description": "**JScript** is Microsoft's dialect of the ECMAScript standard that is used in Microsoft's Internet Explorer. JScript is implemented as an Active Scripting engine. This means that it can be \"plugged in\" to OLE Automation applications that support Active Scripting, such as Internet Explorer, Active Server Pages, and Windows Script Host. It also means such applications can use multiple Active Scripting languages, e.g., JScript, VBScript or PerlScript. JScript was first supported in the Internet Explorer 3.0 browser released in August 1996. Its most recent version is JScript 9.0, included in Internet Explorer 9. JScript 10.0 is a separate dialect, also known as JScript .NET, which adds several new features from the abandoned fourth edition of the ECMAScript standard. It must be compiled for .NET Framework version 2 or version 4, but static type annotations are optional."
  },
  "213": {
    "label": "JScript .NET",
    "wikipedia_pageid": 840451,
    "inception": null,
    "paradigm": [],
    "typing": [2, 13, 10],
    "description": "**JScript .NET** is a .NET programming language developed by Microsoft. The primary differences between JScript and JScript .NET can be summarized as follows: Firstly, JScript is a scripting language, and as such programs (or more suggestively, scripts) can be executed without the need to compile the code first. This is not the case with the JScript .NET command-line compiler, since this next-generation version relies on the .NET Common Language Runtime (CLR) for execution, which requires that the code be compiled to Common Intermediate Language (CIL), formerly called Microsoft Intermediate Language (MSIL), code before it can be run. Nevertheless, JScript .NET still provides full support for interpreting code at runtime (e.g., via the `Function` constructor or the `eval` function) and indeed the interpreter can be exposed by custom applications hosting the JScript .NET engine via the VSA interfaces. Secondly, JScript has a strong foundation in Microsoft's ActiveX/COM technologies, and relies primarily on ActiveX components to provide much of its functionality (including database access via ADO, file handling, etc.), whereas JScript .NET uses the .NET Framework to provide equivalent functionality. For backwards-compatibility (or for where no .NET equivalent library exists), JScript .NET still provides full access to ActiveX objects via .NET / COM Interop using both the ActiveXObject constructor and the standard methods of the .NET **Type** class. Although the .NET Framework and .NET languages such as C# and Visual Basic .NET have seen widespread adoption, JScript .NET has never received much attention, by the media or by developers. It is not supported in Microsoft's premier development tool, Visual Studio .NET. However, ASP.NET supports JScript .NET."
  },
  "214": {
    "label": "Janus",
    "wikipedia_pageid": 50304023,
    "inception": { "time": "+1990-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [27],
    "typing": [],
    "description": "**Janus** is a computer programming language partially described by K. Kahn and Vijay A. Saraswat in the paper \"Actors as a special case of concurrent constraint (logic) programming\" in 1990. It is a concurrent constraint language without backtracking. Janus models concurrency through the use of _bag channels_. Code that needs to send a message to a process does so by constraining a bag to be the union of another bag and the singleton bag of the message. The other bag is then available to be constrained for sending subsequent messages. The process receives the message by matching the bag to a pattern that says it is the union of some singleton and some other bag. The logic of the bag channels produces a property shared by the actor model, namely that the order of arrival of the messages is not guaranteed. However, unlike actors in the actor model, processes in Janus can pass around their \"mailboxes\" so to speak, in the form of bags, and can hold more than one. This ability to pass mailboxes around and hold more than one is inherited in computer programming language ToonTalk, which is influenced by Janus. Janus, the programming language, is named after Janus, the two-faced Roman god, because every logical variable in Janus has as its two \"faces\", two aspects that can be passed as arguments. These are called the _asker_ and the _teller_. These represent, respectively, the right to ask the value of the variable (or some characteristic of the value) and the right to tell the value (or to tell some constraint on what the value can be). The asker and teller aspects can be passed around as arguments independently of each other. Neither right implies the other right. The syntax of the language prevents copying a teller or exercising it more than once. Logical contradiction is statically prevented, according to Kahn and Saraswat."
  },
  "215": {
    "label": "Janus",
    "wikipedia_pageid": 50304039,
    "inception": { "time": "+1982-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3],
    "typing": [],
    "description": "**Janus** is a time-reversible programming language written at Caltech in 1982. The operational semantics of the language were formally specified, together with a program inverter and an invertible self-interpreter, in 2007 by Tetsuo Yokoyama and Robert Glück. A Janus inverter and interpreter is made freely available by the TOPPS research group at DIKU. Another Janus interpreter was implemented in Prolog in 2009. The below summarises the language presented in the 2007 paper. Janus is an imperative programming language with a global store (there is no stack or heap allocation). Janus is a reversible programming language, i.e. it supports deterministic forward and backward computation by local inversion."
  },
  "216": {
    "label": "Java",
    "wikipedia_pageid": 15881,
    "inception": { "time": "+1995-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3, 4, 21, 6, 26, 0, 9, 36],
    "typing": [4, 14, 1, 11],
    "description": "**Java** is a high-level, class-based, object-oriented programming language that is designed to have as few implementation dependencies as possible. It is a general-purpose programming language intended to let application developers _write once, run anywhere_ (WORA), meaning that compiled Java code can run on all platforms that support Java without the need for recompilation. Java applications are typically compiled to bytecode that can run on any Java virtual machine (JVM) regardless of the underlying computer architecture. The syntax of Java is similar to C and C++, but has fewer low-level facilities than either of them. The Java runtime provides dynamic capabilities (such as reflection and runtime code modification) that are typically not available in traditional compiled languages. As of 2019, Java was one of the most popular programming languages in use according to GitHub, particularly for client- server web applications, with a reported 9 million developers. Java was originally developed by James Gosling at Sun Microsystems (which has since been acquired by Oracle) and released in 1995 as a core component of Sun Microsystems' Java platform. The original and reference implementation Java compilers, virtual machines, and class libraries were originally released by Sun under proprietary licenses. As of May 2007, in compliance with the specifications of the Java Community Process, Sun had relicensed most of its Java technologies under the GPL-2.0-only license. Oracle offers its own HotSpot Java Virtual Machine, however the official reference implementation is the OpenJDK JVM which is free open source software and used by most developers and is the default JVM for almost all Linux distributions. As of March 2021, the latest version is Java 16, with Java 11, a currently supported long-term support (LTS) version, released on September 25, 2018. Oracle released the last zero-cost public update for the legacy version Java 8 LTS in January 2019 for commercial use, although it will otherwise still support Java 8 with public updates for personal use indefinitely. Other vendors have begun to offer zero-cost builds of OpenJDK 8 and 11 that are still receiving security and other upgrades. Oracle (and others) highly recommend uninstalling outdated versions of Java because of serious risks due to unresolved security issues. Since Java 9, 10, 12, 13, 14, and 15 are no longer supported, Oracle advises its users to immediately transition to the latest version (currently Java 16) or an LTS release."
  },
  "217": {
    "label": "JavaFX Script",
    "wikipedia_pageid": 11117691,
    "inception": { "time": "+2008-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [13],
    "typing": [],
    "description": "**JavaFX Script** was a scripting language designed by Sun Microsystems, forming part of the JavaFX family of technologies on the Java Platform. JavaFX targeted the Rich Internet Application domain (competing with Adobe Flex and Microsoft Silverlight), specializing in rapid development of visually rich applications for the desktop and mobile markets. JavaFX Script works with integrated development environments such as NetBeans, Eclipse and IntelliJ IDEA. JavaFX is released under the GNU General Public License, via the Sun sponsored OpenJFX project."
  },
  "218": {
    "label": "JavaScript",
    "wikipedia_pageid": 9845,
    "inception": { "time": "+1996-05-00T00:00:00Z", "precision": 10 },
    "paradigm": [12, 3, 21, 31, 14, 26],
    "typing": [10, 13],
    "description": "**JavaScript** (), often abbreviated as **JS**, is a programming language that conforms to the ECMAScript specification. JavaScript is high-level, often just-in-time compiled, and multi-paradigm. It has curly-bracket syntax, dynamic typing, prototype-based object-orientation, and first-class functions. Alongside HTML and CSS, JavaScript is one of the core technologies of the World Wide Web. Over 97% of websites use it client-side for web page behavior, often incorporating third-party libraries. All major web browsers have a dedicated JavaScript engine to execute the code on the user's device. As a multi-paradigm language, JavaScript supports event-driven, functional, and imperative programming styles. It has application programming interfaces (APIs) for working with text, dates, regular expressions, standard data structures, and the Document Object Model (DOM). The ECMAScript standard does not include any input/output (I/O), such as networking, storage, or graphics facilities. In practice, the web browser or other runtime system provides JavaScript APIs for I/O. JavaScript engines were originally used only in web browsers, but they are now core components of other software systems, most notably servers and a variety of applications. Although there are similarities between JavaScript and Java, including language name, syntax, and respective standard libraries, the two languages are distinct and differ greatly in design."
  },
  "219": {
    "label": "Jess",
    "wikipedia_pageid": 37091,
    "inception": { "time": "+1995-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [28, 13],
    "typing": [],
    "description": "**Jess** is a rule engine for the Java platform that was developed by Ernest Friedman-Hill of Sandia National Labs. It is a superset of the CLIPS programming language. It was first written in late 1995. The language provides rule-based programming for the automation of an expert system, and is frequently termed as an _expert system shell_. In recent years, intelligent agent systems have also developed, which depend on a similar capability. Rather than a procedural paradigm, where a single program has a loop that is activated only one time, the declarative paradigm used by Jess continuously applies a collection of rules to a collection of facts by a process called _pattern matching_. Rules can modify the collection of facts, or they can execute any Java code. It uses the Rete algorithm to execute rules."
  },
  "220": {
    "label": "Job Control Language",
    "wikipedia_pageid": 391487,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**Job Control Language** (**JCL**) is a name for scripting languages used on IBM mainframe operating systems to instruct the system on how to run a batch job or start a subsystem. More specifically, the purpose of JCL is to say which programs to run, using which files or devices for input or output, and at times to also indicate under what conditions to skip a step. There are two distinct IBM Job Control languages:   * one for the operating system lineage that begins with DOS/360 and whose latest member is z/VSE; and   * the other for the lineage from OS/360 to z/OS, the latter now including JES extensions, Job _Entry_ Control Language (JECL). They share some basic syntax rules and a few basic concepts, but are otherwise very different. The VM operating system does not have JCL as such; the CP and CMS components each have command languages."
  },
  "221": {
    "label": "Join Java",
    "wikipedia_pageid": 2225745,
    "inception": { "time": "+2000-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 9, 16],
    "typing": [],
    "description": "**Join Java** is a programming language based on the join-pattern that extends the standard Java programming language with the join semantics of the join- calculus. It was written at the University of South Australia within the Reconfigurable Computing Lab by Dr. Von Itzstein."
  },
  "222": {
    "label": "Joule",
    "wikipedia_pageid": 502786,
    "inception": { "time": "+1996-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [22, 6, 3],
    "typing": [],
    "description": "**Joule** is a capability-secure massively-concurrent dataflow programming language, designed for building distributed applications. It is so concurrent that the order of statements within a block is irrelevant to the operation of the block. Statements are executed whenever possible, based on their inputs. Everything in Joule happens by sending messages. There is no control flow. Instead, the programmer describes the flow of data, making it a dataflow programming language. Joule development started in 1994 at _Agorics_ in Palo Alto, California. It is considered the precursor to the E programming language."
  },
  "223": {
    "label": "Joy",
    "wikipedia_pageid": 696166,
    "inception": { "time": "+2001-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [29, 23, 33],
    "typing": [10, 1],
    "description": "The **Joy programming language** in computer science is a purely functional programming language that was produced by Manfred von Thun of La Trobe University in Melbourne, Australia. Joy is based on composition of functions rather than lambda calculus. It has turned out to have many similarities to Forth, due not to design but to a sort of parallel evolution and convergence. It was also inspired by the function-level programming style of John Backus's FP."
  },
  "224": {
    "label": "Julia",
    "wikipedia_pageid": 38455554,
    "inception": { "time": "+2009-08-23T00:00:00Z", "precision": 11 },
    "paradigm": [2, 3, 20, 21, 6, 7, 25],
    "typing": [1, 3, 10, 4],
    "description": "**Julia** is a high-level, high-performance, dynamic programming language. While it is a general-purpose language and can be used to write any application, many of its features are well suited for numerical analysis and computational science. Distinctive aspects of Julia's design include a type system with parametric polymorphism in a dynamic programming language; with multiple dispatch as its core programming paradigm. Julia supports concurrent, (composable) parallel and distributed computing (with or without using MPI or the built-in corresponding to \"OpenMP-style\" threads), and direct calling of C and Fortran libraries without glue code. Julia uses a just-in-time (JIT) compiler that is referred to as \"just-ahead-of-time\" (JAOT) in the Julia community, as Julia compiles all code (by default) to machine code before running it. Julia is garbage-collected, uses eager evaluation, and includes efficient libraries for floating-point calculations, linear algebra, random number generation, and regular expression matching. Many libraries are available, including some (e.g., for fast Fourier transforms) that were previously bundled with Julia and are now separate. Several development tools support coding in Julia, such as integrated development environments (e.g. Microsoft's Visual Studio Code, with extensions available adding Julia support to IDEs, e.g. providing debugging and linting support); with integrated tools, e.g. a profiler (and flame graph support available for the built-in one), debugger, and the Rebugger.jl package \"supports repeated-execution debugging\" and more."
  },
  "225": {
    "label": "Jython",
    "wikipedia_pageid": 390263,
    "inception": { "time": "+2001-01-17T00:00:00Z", "precision": 11 },
    "paradigm": [6],
    "typing": [],
    "description": "**Jython** is an implementation of the Python programming language designed to run on the Java platform. The implementation was formerly known as **JPython** until 1999."
  },
  "226": {
    "label": "K",
    "wikipedia_pageid": 890956,
    "inception": { "time": "+1993-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [20, 21],
    "typing": [10, 1],
    "description": "**K** is a proprietary array processing programming language developed by Arthur Whitney and commercialized by Kx Systems. The language serves as the foundation for kdb+, an in-memory, column-based database, and other related financial products. The language, originally developed in 1993, is a variant of APL and contains elements of Scheme. Advocates of the language emphasize its speed, facility in handling arrays, and expressive syntax."
  },
  "227": {
    "label": "KRL",
    "wikipedia_pageid": 17227,
    "inception": { "time": "+1971-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [28, 13],
    "typing": [],
    "description": "**KRL** is a knowledge representation language, developed by Daniel G. Bobrow and Terry Winograd while at Xerox PARC and Stanford University, respectively. It is a frame-based language. > KRL was an attempt to produce a language which was nice to read and write > for the engineers who had to write programs in it, processed like human > memory, so you could have realistic AI programs, had an underlying semantics > which was firmly grounded like logic languages, all in one, all in one > language. And I think it - again, in hindsight - it just bogged down under > the weight of trying to satisfy all those things at once."
  },
  "228": {
    "label": "Kaleidoscope",
    "wikipedia_pageid": 4400159,
    "inception": { "time": "+1994-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 2, 3, 5],
    "typing": [],
    "description": "The **Kaleidoscope programming language** is a constraint programming language embedding constraints into an imperative object-oriented language. It adds keywords _always_,_once_, and _assert_.. _during_ (formerly _while_.. _assert_) to make statements about relational invariants. Objects have constraint constructors, which are not methods, to enforce the meanings of user-defined datatypes. There are three versions of Kaleidoscope which show an evolution from declarative to an increasingly imperative style. Differences between them are as follows."
  },
  "229": {
    "label": "Karel",
    "wikipedia_pageid": 1433925,
    "inception": { "time": "+1981-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2],
    "typing": [],
    "description": "**Karel** is an educational programming language for beginners, created by Richard E. Pattis in his book _Karel The Robot: A Gentle Introduction to the Art of Programming_. Pattis used the language in his courses at Stanford University, California. The language is named after Karel Čapek, a Czech writer who introduced the word _robot_ in his play R.U.R."
  },
  "230": {
    "label": "Kent Recursive Calculator",
    "wikipedia_pageid": 17224,
    "inception": { "time": "+1981-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [21],
    "typing": [],
    "description": "**KRC** (**Kent Recursive Calculator**) is a lazy functional language developed by David Turner from November 1979 to October 1981 based on SASL, with pattern matching, guards and ZF expressions (now more usually called list comprehensions). Two implementations of KRC were written: David Turner's original one in BCPL running on EMAS, and Simon J. Croft's later one in C under Unix, and KRC was the main language used for teaching functional programming at the University of Kent at Canterbury (UK) from 1982 to 1985. The direct successor to KRC is Miranda, which includes a polymorphic type discipline based on that of Milner's ML."
  },
  "231": {
    "label": "KiXtart",
    "wikipedia_pageid": 1370630,
    "inception": { "time": "+1991-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**KiXtart** is a closed source free-format scripting language for Windows. It is described as a logon script processor and enhanced batch scripting language by the official website. Its name is a portmanteau of \"kick start\"."
  },
  "232": {
    "label": "Klerer-May System",
    "wikipedia_pageid": 17186,
    "inception": { "time": "+1960-01-01T00:00:00Z", "precision": 8 },
    "paradigm": [2],
    "typing": [],
    "description": "The **Klerer–May System** is a programming language developed in the mid-1960s, oriented to numerical scientific programming, whose most notable feature is its two-dimensional syntax based on traditional mathematical notation. For input and output, the Klerer–May system used a Friden Flexowriter modified to allow half-line motions for subscripts and superscripts. The character set included digits, upper-case letters, subsets of 14 lower-case Latin letters and 18 Greek letters, arithmetic operators (`+` `−` `×` `/` `|`) and punctuation (`.` `,` `(` `)`), and eight special line-drawing characters (resembling `╲` `╱` `⎜` `_` `⎨` `⎬` `˘` `⁔`) used to construct multi-line brackets and symbols for summation, products, roots, and for multi-line division or fractions. The system was intended to be forgiving of input mistakes, and easy to learn; its reference manual was only two pages. The system was developed by Melvin Klerer and Jack May at Columbia University's Hudson Laboratories in Dobbs Ferry, New York, for the Office of Naval Research, and ran on GE-200 series computers."
  },
  "233": {
    "label": "Kodu Game Lab",
    "wikipedia_pageid": 13837554,
    "inception": { "time": "+2009-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [10],
    "typing": [],
    "description": "**Kodu**, originally named _Boku_, is a programming integrated development environment (IDE) by Microsoft's FUSE Labs. It runs on Xbox 360 and Microsoft Windows XP, Windows Vista, Windows 7, Windows 8 and Windows 10. It was released on the Xbox Live Marketplace on June 30, 2009. A Windows version is available to the general public for download from Microsoft's FUSE web portal."
  },
  "234": {
    "label": "Kojo",
    "wikipedia_pageid": 30843423,
    "inception": { "time": "+2010-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 21],
    "typing": [1],
    "description": "**Kojo** is a programming language and integrated development environment (IDE) for computer programming and learning. It has many different features that enable playing, exploring, creating, and learning in the areas of computer programming, mental skills, (interactive) math, graphics, art, music, science, animation, games, and electronics. Kojo draws ideas from the programming languages Logo and Processing. Kojo is open-source software. It was created, and is actively developed, by Lalit Pant, a computer programmer and teacher living in Dehradun, India. Kojo provides domain-specific languages (DSLs) for its different areas of learning, and as such can be considered an educational programming language. Kojo is written in, and its approach is based on, the programming language Scala, where users begin with a simple subset of the language and progress in steps. Its graphical user interface is based on Java Swing; a former version was based on the Java NetBeans platform. Lalit chose Scala as the underlying language for Kojo because of its low barrier to entry and potential power. Kojo has been used in schools and classes around the world. Some of these include:   * Himjyoti School, Dehradun, India.   * Mondrian House School, Dehradun, India.   * Rishi Valley School, Madanapalle, India.   * Cardinal Forest Elementary School, Springfield, Virginia, USA.   * Diablo Valley College, Pleasant Hill, California, USA.   * Our Lady's Catholic High School, Preston, England.   * A Swedish 4th grade class consisting of 10-year-old children. Kojo has been featured by Dagens Nyheter (DN) and Computer Sweden as a result of the work done by this class.   * Events like Silicon Valley Code Camp, CoderDojo, Hack The Future, and Meetups. The development of Kojo is partly sponsored by Lightbend, formerly TypeSafe, and Lund University, Computer Science Department, where Kojo is used to introduce children and teachers to computer programming. Professor Björn Regnell of Lund University has an informative presentation on the subject. Professor Regnell writes, in translation: \"_Kojo is the best tool, with a low barrier of entry, I have seen for making real text based programming available for children, that is also usable all the way up to university level_\"."
  },
  "235": {
    "label": "Kotlin",
    "wikipedia_pageid": 41819039,
    "inception": { "time": "+2011-07-22T00:00:00Z", "precision": 11 },
    "paradigm": [3, 13, 21, 6, 26, 9, 16, 36],
    "typing": [1, 6, 11],
    "description": "**Kotlin** () is a cross-platform, statically typed, general-purpose programming language with type inference. Kotlin is designed to interoperate fully with Java, and the JVM version of Kotlin's standard library depends on the Java Class Library, but type inference allows its syntax to be more concise. Kotlin mainly targets the JVM, but also compiles to JavaScript (e.g., for frontend web applications using React) or native code (via LLVM); e.g., for native iOS apps sharing business logic with Android apps. Language development costs are borne by JetBrains, while the Kotlin Foundation protects the Kotlin trademark. On 7 May 2019, Google announced that the Kotlin programming language is now its preferred language for Android app developers. Since the release of Android Studio 3.0 in October 2017, Kotlin has been included as an alternative to the standard Java compiler. The Android Kotlin compiler produces Java 8 bytecode by default (which runs in any later JVM), but lets the programmer choose to target Java 8 up to 16, for optimization, or allows for more features, e.g. Java 8 related with Kotlin 1.4, and has experimental record class support for Java 16 compatibility. Kotlin support for JavaScript (i.e. classic back-end) is considered stable in Kotlin 1.3 by its developers, while Kotlin/JS (IR-based) in version 1.4, is considered alpha. Kotlin/Native Runtime (for e.g. Apple support) is considered beta."
  },
  "236": {
    "label": "LINC 4GL",
    "wikipedia_pageid": 4298516,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**LINC** (\"Logic and Information Network Compiler\") is a fourth-generation programming language, used mostly on Unisys computer systems."
  },
  "237": {
    "label": "Language Integrated Query",
    "wikipedia_pageid": 13706337,
    "inception": { "time": "+2007-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [1],
    "description": "**Language Integrated Query** (**LINQ**, pronounced \"link\") is a Microsoft .NET Framework component that adds native data querying capabilities to .NET languages, originally released as a major part of .NET Framework 3.5 in 2007. LINQ extends the language by the addition of query expressions, which are akin to SQL statements, and can be used to conveniently extract and process data from arrays, enumerable classes, XML documents, relational databases, and third-party data sources. Other uses, which utilize query expressions as a general framework for readably composing arbitrary computations, include the construction of event handlers or monadic parsers. It also defines a set of method names (called _standard query operators_, or _standard sequence operators_), along with translation rules used by the compiler to translate query syntax expressions into expressions using fluent-style (called method syntax by Microsoft) with these method names, lambda expressions and anonymous types. Many of the concepts that LINQ introduced were originally tested in Microsoft's Cω research project. Ports of LINQ exist for PHP (PHPLinq), JavaScript (linq.js), TypeScript (linq.ts), and ActionScript (ActionLinq), although none are strictly equivalent to LINQ in the .NET inspired languages C#, F# and VB.NET (where it is a part of the language, not an external library, and where it often addresses a wider range of needs)."
  },
  "238": {
    "label": "LIS",
    "wikipedia_pageid": 12073324,
    "inception": { "time": "+1973-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2],
    "typing": [],
    "description": "**LIS** (Language d'Implementation de Systèmes) was a system implementation programming language designed by Jean Ichbiah, who later designed Ada. LIS was used to implement the compiler for the Ada-0 subset of Ada at Karlsruhe on the BS2000 Siemens operating system. Later on the Karlsruhe Ada compilation system got rewritten in Ada-0 itself, which was easy, because LIS and Ada-0 are very close."
  },
  "239": {
    "label": "LSE",
    "wikipedia_pageid": 11730351,
    "inception": { "time": "+1960-01-01T00:00:00Z", "precision": 8 },
    "paradigm": [2, 36],
    "typing": [],
    "description": "**LSE** (French: _Langage symbolique d'enseignement_) is a programming language developed at Supélec and Télémécanique from the late 1960s to the mid 1970s.It is similar to BASIC, except with French-language instead of English- language keywords. It was derived from an earlier language called _LSD_, also developed at Supélec. It is most commonly said to be an acronym for _Langage Symbolique d'Enseignement_ (Symbolic Teaching Language), but other expansions are also known (e.g. _Langage de Sup-Élec_, or the more cynical). It originally flourished due to support from the French Ministry of National Education, but declined as the ministry lost interest. It went through a number of revisions; earlier versions of LSE lacked full support for structured programming, later versions such as LSE-83 (aka LSE-1983) by Jacques Arsac added structured programming support, along with exception handling. Even later revisions, such as LSE-2000, added more functionality, new types, new operators (NI, ET QUE, OU QUE and SELON-DANS-SINON), flow control commands, etc."
  },
  "240": {
    "label": "LYaPAS",
    "wikipedia_pageid": 18305664,
    "inception": { "time": "+1964-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [36, 18, 20, 21],
    "typing": [10],
    "description": "**Logical Language for the Representation of Synthesis Algorithms** (**LYaPAS**, Russian: **ЛЯПАС**) is a programming language created by Arkady Zakrevsky in the Soviet Union. LYaPAS is an extension to the programming language APL, and was initially designed especially for non-numeric programming for the Soviet designed and built line of mainframe computers named Ural-1. LYaPAS uses octal numbers. A further refinement of LYaPAS is LYaPAS-M."
  },
  "241": {
    "label": "LabVIEW",
    "wikipedia_pageid": 544733,
    "inception": { "time": "+1986-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [10],
    "typing": [],
    "description": "**Laboratory Virtual Instrument Engineering Workbench** (**LabVIEW**) is a system-design platform and development environment for a visual programming language from National Instruments. The graphical language is named \"G\"; not to be confused with G-code. The G dataflow language was originally developed by Labview, LabVIEW is commonly used for data acquisition, instrument control, and industrial automation on a variety of operating systems (OSs), including Microsoft Windows as well as various versions of Unix, Linux, and macOS. The latest versions of LabVIEW are LabVIEW 2020 (released in May 2020) and LabVIEW NXG 5.1 (released in January 2021). NI released the free for non- commercial use LabVIEW and LabVIEW NXG Community editions on April 28th, 2020."
  },
  "242": {
    "label": "ladder logic",
    "wikipedia_pageid": 66251,
    "inception": null,
    "paradigm": [10],
    "typing": [],
    "description": "**Ladder logic** was originally a written method to document the design and construction of relay racks as used in manufacturing and process control. Each device in the relay rack would be represented by a symbol on the ladder diagram with connections between those devices shown. In addition, other items external to the relay rack such as pumps, heaters, and so forth would also be shown on the ladder diagram. Ladder logic has evolved into a programming language that represents a program by a graphical diagram based on the circuit diagrams of relay logic hardware. Ladder logic is used to develop software for programmable logic controllers (PLCs) used in industrial control applications. The name is based on the observation that programs in this language resemble ladders, with two vertical rails and a series of horizontal rungs between them. While ladder diagrams were once the only available notation for recording programmable controller programs, today other forms are standardized in IEC 61131-3 (For example, as an alternative to the graphical ladder logic form, there is also a more assembly language like format called Instruction list within the IEC 61131-3 standard.)."
  },
  "243": {
    "label": "Language H",
    "wikipedia_pageid": 63559387,
    "inception": { "time": "+1962-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2],
    "typing": [],
    "description": "**Language H** is a proprietary, procedural programming language created by NCR based on COBOL. The first compiler was developed in August 1962 to run on the National-Elliott 405M and produce object code for the National-Elliott 803B. It is believed that the \"H\" stands for John C Harwell."
  },
  "244": {
    "label": "LISA",
    "wikipedia_pageid": 22061818,
    "inception": { "time": "+1997-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**LISA** (Language for Instruction Set Architectures) is a language to describe the instruction set architecture of a processor. LISA captures the information required to generate software tools (compiler, assembler, instruction set simulator, ...) and implementation hardware (in VHDL or Verilog) of a given processor. LISA has been used to re-implement the hardware of existing processor cores, keeping the binary compatibility with the legacy version, as all software tools did already exist and legacy compiled software images could be executed on the newly created hardware. Another application has been to generate the ISS (instruction set simulator) for RISC processors such the ARM architecture ISSes. **LISA** is not focused on the modeling of other on-chip components around the processor core itself, such as peripherals, hardware accelerators, buses and memories; Other languages such as SystemC can be used for these. The language has not been yet standardised by IEEE or ISO and is currently owned by RWTH Aachen University, in Germany."
  },
  "245": {
    "label": "Lasso",
    "wikipedia_pageid": 524247,
    "inception": { "time": "+1995-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 2, 16, 36],
    "typing": [13, 4, 10],
    "description": "**Lasso** is an application server and server management interface used to develop internet applications and is a general-purpose, high-level programming language. Originally a web datasource connection tool, for Filemaker and later included in Apple Computer's FileMaker 4.0 and Claris Homepage as CDML, it has since evolved into a complex language used to develop and serve large-scale internet applications and web pages. Lasso includes a simple template system allowing code to control generation of HTML and other content types. Lasso is object-oriented and every value is an object. It also supports procedural programming through _unbound_ methods. The language uses traits and multiple dispatch extensively. Lasso has a dynamic type system, where objects can be loaded and augmented at runtime, automatic memory management, a comprehensive standard library, and three compiling methodologies: dynamic (comparable to PHP-Python), just-in- time compilation (comparable to Java or .NET Framework), and pre-compiled (comparable to C). Lasso also supports Query Expressions, allowing elements within arrays and other types of sequences to be iterated, filtered, and manipulated using a natural language syntax similar to SQL. Lasso includes full Unicode character support in the standard string object, allowing it to serve and support multi-byte characters such as Japanese and Swedish, and supports transparent UTF-8 conversion when writing string data to the network or file system. Lasso is often used as a scripting language, and also used in a wide range of non-scripting contexts. Lasso code can be packaged into standalone executable programs called \"LassoApps\", in which folder structures are compiled into single files. The Lasso Server application server runs as a system service and receives requests from the web server through FastCGI. It then hands the request off to the appropriate Lasso Instance, which formulates the response. Multiple individual instances are supported, allowing one server to handle multiple sites, each as separate processes. The server uses a high performance IO-based green threading system designed for multi-core systems. Lasso can be compared to the server-side scripting languages PHP and Python, ColdFusion, Ruby, etc. Free for development, Lasso allows partial access to its source code, allowing developers to add or change major components of the language (for example, Ke Carlton's DS implementation of the Lasso Inline). Licensing comes in both SAS and stand-alone versions."
  },
  "246": {
    "label": "Lava",
    "wikipedia_pageid": 1982671,
    "inception": null,
    "paradigm": [6, 10],
    "typing": [],
    "description": "**Lava** is an experimental, visual object-oriented, interpreter-based programming language with an associated programming environment (Lava Programming Environment or **LavaPE**) that uses structure editors instead of text editors. Only comments, constants, and new identifiers may be entered as text. _Declarations_ are represented in LavaPE as tree structures whose subtrees may be collapsed or expanded. The properties of the declared Lava entities can be edited through pop-up dialogs. Although _executable code_ has a traditional text representation in LavaPE, it can be edited only as complete syntactic units, rather than character by character. If you insert a new syntactic construct, it will typically contain \"placeholders\" (syntactic variables) that can then be replaced by concrete constructs; the latter may in turn contain syntactic variables, etc. LavaPE provides a tool button for every type of syntactic construct, and a button is enabled only if it is syntactically correct to insert the associated construct at the selected place. Further characteristic properties of Lava and LavaPE include the following:   * It provides strict syntactic separation of interface (public) and implementation (private) sections of a Lava class.   * It distinguishes variable \"state objects\" from constant \"value objects\"; the latter cannot be modified any longer after creation/initialization.   * It supports \"virtual types\": type parameters of classes and packages (families of related classes). As a consequence, undermining of strong type checks by \"type casts\" is no longer required.   * It uses recursion and logical quantifiers instead of traditional loop constructs.   * It uses single assignment; i.e., a value can be assigned to a variable only once within the same branch of a function.   * It supports refactoring extensively via the LavaPE structure editors.   * It distinguishes between _constituents_ (sub-objects) and _object acquaintances_ (pointers to independent objects). Copying and deletion of complex objects is largely facilitated in this way.   * Since release 0.9.0, LavaPE completely prevents inadvertent access to uninitialized variables and null objects already at programming time by complete static initialization checks. Lava is open source software using the GPL license (see also Lava at the Free Software Foundation and at KDE-Apps.org). It currently runs on Microsoft Windows, Linux and Mac OS X platforms."
  },
  "247": {
    "label": "Lean",
    "wikipedia_pageid": 62889984,
    "inception": { "time": "+2013-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [0],
    "description": "**Lean** is a theorem prover and programming language. It is based on the calculus of constructions with inductive types. The Lean project is an open source project, hosted on GitHub. It was launched by Leonardo de Moura at Microsoft Research in 2013. Lean has an interface that differentiates it from other interactive theorem provers. Lean can be compiled to JavaScript and accessed in a web browser. It has native support for Unicode symbols. (These can be typed using LaTeX-like sequences, such as \"\\times\" for \"×\".) Lean also has an extensive support for meta-programming. Lean has gotten attention from mathematicians Thomas Hales and Kevin Buzzard. Hales is using it for his project, Formal Abstracts. Buzzard uses it for the Xena project. One of the Xena Project's goals is to rewrite every theorem and proof in the undergraduate math curriculum of Imperial College London in Lean."
  },
  "248": {
    "label": "Lexico",
    "wikipedia_pageid": 23474781,
    "inception": { "time": "+1985-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**Lexico** is a programming language in Spanish for learning and teaching object-oriented programming. It compiles on the .Net Framework"
  },
  "249": {
    "label": "Limbo",
    "wikipedia_pageid": 236298,
    "inception": { "time": "+1995-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [16, 18],
    "typing": [1],
    "description": "**Limbo** is a programming language for writing distributed systems and is the language used to write applications for the Inferno operating system. It was designed at Bell Labs by Sean Dorward, Phil Winterbottom, and Rob Pike. The Limbo compiler generates architecture-independent object code which is then interpreted by the Dis virtual machine or compiled just before runtime to improve performance. Therefore all Limbo applications are completely portable across all Inferno platforms. Limbo's approach to concurrency was inspired by Hoare's communicating sequential processes (CSP), as implemented and amended in Pike's earlier Newsqueak language and Winterbottom's Alef."
  },
  "250": {
    "label": "Limnor",
    "wikipedia_pageid": 2782804,
    "inception": null,
    "paradigm": [10],
    "typing": [],
    "description": "**Limnor** is a generic-purpose codeless and visual programming system. The aim is to enable users to create computer software without directly coding in a texture programming language. It can be extended by software developers. The general idea of Limnor codeless programming is to add \"Actions\" to classes."
  },
  "251": {
    "label": "Second Life",
    "wikipedia_pageid": 589192,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "_**Second Life**_ is an online virtual world, developed and owned by the San Francisco-based firm Linden Lab and launched on June 23, 2003. It saw rapid growth for some years and in 2013 it had approximately one million regular users; growth stabilized and by the end of 2017 active user count had declined to \"between 800,000 and 900,000\". In many ways,_Second Life_ is similar to massively multiplayer online role-playing games; nevertheless, Linden Lab is emphatic that their creation is not a game: \"There is no manufactured conflict, no set objective\". The virtual world can be accessed freely via Linden Lab's own client software or via alternative third-party viewers. _Second Life_ users, also called _residents_, create virtual representations of themselves, called _avatars_, and are able to interact with places, objects and other avatars. They can explore the world (known as the grid), meet other residents, socialize, participate in both individual and group activities, build, create, shop, and trade virtual property and services with one another. The platform principally features 3D-based user-generated content. _Second Life_ also has its own virtual currency, the Linden Dollar, which is exchangeable with real world currency.  _Second Life_ is intended for people aged 16 and over, with the exception of 13–15-year-old users, who are restricted to the _Second Life_ region of a sponsoring institution (e.g., a school)."
  },
  "252": {
    "label": "Lingo",
    "wikipedia_pageid": 493076,
    "inception": { "time": "+1989-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [],
    "description": "**Lingo** is a verbose object-oriented (OO) scripting language developed by John H. Thompson for use in Adobe Director (formerly Macromedia Director). Lingo is used to develop desktop application software, interactive kiosks, CD- ROMs and Adobe Shockwave content. Lingo is the primary programming language on the Adobe Shockwave platform, which dominated the interactive multimedia product market during the 1990s. Various graphic adventure games were developed with Lingo during the 1990s, including The Journeyman Project, Total Distortion, Mia's Language Adventure, Mia's Science Adventure, and the Didi & Ditto series. Hundreds of free online video games were developed using Lingo, and published on websites such as Miniclip and Shockwave.com. Lingo can be used to build user interfaces, to manipulate raster graphics, vector graphics and 3D computer graphics, and other data processing tasks. Lingo supports specialized syntax for image processing and 3D object manipulation. 3D meshes can also be created on the fly using Lingo."
  },
  "253": {
    "label": "Lisp",
    "wikipedia_pageid": 18016,
    "inception": { "time": "+1958-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [25, 2, 9, 21],
    "typing": [10, 1],
    "description": "**Lisp** (historically **LISP**) is a family of programming languages with a long history and a distinctive, fully parenthesized prefix notation. Originally specified in 1958, Lisp is the second-oldest high-level programming language in widespread use today. Only Fortran is older, by one year. Lisp has changed since its early days, and many dialects have existed over its history. Today, the best-known general-purpose Lisp dialects are Racket, Common Lisp, Scheme and Clojure. Lisp was originally created as a practical mathematical notation for computer programs, influenced by (though not originally derived from ) the notation of Alonzo Church's lambda calculus. It quickly became the favored programming language for artificial intelligence (AI) research. As one of the earliest programming languages, Lisp pioneered many ideas in computer science, including tree data structures, automatic storage management, dynamic typing, conditionals, higher-order functions, recursion, the self-hosting compiler, and the read–eval–print loop. The name _LISP_ derives from \"LISt Processor\". Linked lists are one of Lisp's major data structures, and Lisp source code is made of lists. Thus, Lisp programs can manipulate source code as a data structure, giving rise to the macro systems that allow programmers to create new syntax or new domain- specific languages embedded in Lisp. The interchangeability of code and data gives Lisp its instantly recognizable syntax. All program code is written as _s-expressions_, or parenthesized lists. A function call or syntactic form is written as a list with the function or operator's name first, and the arguments following; for instance, a function `f` that takes three arguments would be called as `(f arg1 arg2 arg3)`."
  },
  "254": {
    "label": "Lite-C",
    "wikipedia_pageid": 10780425,
    "inception": { "time": "+2007-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**Lite-C** is a programming language for multimedia applications and personal computer games, using a syntax subset of the C language with some elements of the C++ language. Its main difference to C is the native implementation of multimedia and computer game related objects like sounds, images, movies, GUI elements, 2D and 3D models, collision detection and rigid body physics. Lite-C executables are compiled instead of interpreted. Lite-C runs on 32-bit and 64-bit Windows XP or Vista operating systems. Lite-C claims to allow very fast programming with a minimum of code, and easy access to non-programmers. For this, the developer provides a 25-lesson workshop that especially deals with the game and multimedia related objects of the language. Lite-C supports the Windows API and the Component Object Model (COM); therefore OpenGL and DirectX programs can directly be written in lite-C. It has integrated the free A8 rendering engine."
  },
  "255": {
    "label": "Lithe",
    "wikipedia_pageid": 908572,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**Lithe** is an experimental programming language created in 1982 by David Sandberg at the University of Washington which allows the programmer to freely choose their own syntax. Lithe combines the ideas of syntax-directed translation and classes in a novel manner that results in a remarkably simple yet powerful language."
  },
  "256": {
    "label": "LC-3",
    "wikipedia_pageid": 9193341,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**Little Computer 3**, or **LC-3**, is a type of computer educational programming language, an assembly language, which is a type of low-level programming language. It features a relatively simple instruction set, but can be used to write moderately complex assembly programs, and is a viable target for a C compiler. The language is less complex than x86 assembly but has many features similar to those in more complex languages. These features make it useful for beginning instruction, so it is most often used to teach fundamentals of programming and computer architecture to computer science and computer engineering students. The LC-3 was developed by Yale N. Patt at the University of Texas at Austin and Sanjay J. Patel at the University of Illinois at Urbana–Champaign. Their specification of the instruction set, the overall architecture of the LC-3, and a hardware implementation can be found in the second edition of their textbook. Courses based on the LC-3 and Patt and Patel's book are offered in many computer engineering and computer science departments."
  },
  "257": {
    "label": "Little Implementation Language",
    "wikipedia_pageid": 35320077,
    "inception": { "time": "+1974-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2],
    "typing": [],
    "description": "**LIL**, the **Little Implementation Language**, was a system programming language during the early days of Unix history on PDP-11 machines. It was written by P. J. Plauger of Bell Labs. LIL attempted to fill the gap between assemblers and machine-independent system implementation languages (such as the C programming language), by basically adding structured programming to the PDP-11 assembly language. LIL resembled PL360 with C-like flow control syntax. The LIL compiler \"lc\" was part of Fifth Edition Unix (1974), but was dropped by Sixth Edition Unix (1975). Plauger left Bell Labs in the same year. Plauger explains why LIL was abandoned in Bell Labs in favor of C: [1]     _... LIL is, however, a failure. Its stiffest competition at Bell Labs is the language C, which is higher level, and machine independent. Every time it looked like C was too expensive to use for a particular project, LIL was considered. But almost every time, it proved easier (and more rewarding) to improve C, or its runtime support, or the hardware, than to invest time in yet another language. ... A machine independent language is always superior -- even for writing machine dependent code (it's easier to find trained programmers) -- so long as the overhead can be endured. It is clear now that writing straightforward code and then measuring it is the formula for the best end product. At worst there will be 5-15 per cent overhead, which is seldom critical. Once system writers become mature enough to recognize this basic truth, they gravitate naturally toward machine independent SILs. ... it looks like the little implementation language is an idea whose time as come -- and gone._"
  },
  "258": {
    "label": "Little b",
    "wikipedia_pageid": 4740151,
    "inception": { "time": "+2004-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 21],
    "typing": [10, 1],
    "description": "**Little b** is a domain-specific programming language, more specifically, a modeling language, designed to build modular mathematical models of biological systems. It was designed and authored by Aneil Mallavarapu. Little b is being developed in the Virtual Cell Program at Harvard Medical School, headed by mathematician Jeremy Gunawardena. This language is based on Lisp and is meant to allow modular programming to model biological systems. It will allow more flexibility to facilitate rapid change that is required to accurately capture complex biological systems. The language draws on techniques from artificial intelligence and symbolic mathematics, and provides syntactic conveniences derived from object-oriented languages. The language was originally denoted with a lowercase b (distinguishing it from B, the predecessor to the widely used C programming language, but the name was eventually changed to \"little b\" to avoid confusion and to pay homage to Smalltalk, the first object-oriented programming language."
  },
  "259": {
    "label": "LiveCode",
    "wikipedia_pageid": 30890362,
    "inception": { "time": "+2001-07-11T00:00:00Z", "precision": 11 },
    "paradigm": [6],
    "typing": [],
    "description": "**LiveCode** (formerly Revolution and MetaCard) is a cross-platform rapid application development runtime system inspired by HyperCard. It features the _LiveCode Script_ (formerly MetaTalk) programming language which belongs to the family of xTalk scripting languages like HyperCard's HyperTalk. The environment was introduced in 2001. The \"Revolution\" development system was based on the MetaCard engine technology which Runtime Revolution later acquired from MetaCard Corporation in 2003. The platform won the Macworld Annual Editor's Choice Award for \"Best Development Software\" in 2004. \"Revolution\" was renamed \"LiveCode\" in the fall of 2010. \"LiveCode\" is developed and sold by Runtime Revolution Ltd., based in Edinburgh, Scotland. In March, 2015, the company was renamed \"LiveCode Ltd.\", to unify the company name with the product. In April 2013 a free/open source version 'LiveCode Community Edition 6.0' was published after a successful crowdfunding campaign at Kickstarter. The code base was re-licensed and made available as free and open source software with a version in April 2013. LiveCode runs on iOS, Android, OS X, Windows 95 through Windows 10, Raspberry Pi and several variations of Unix, including Linux, Solaris, and BSD. It can be used for mobile, desktop and server/CGI applications. The iOS (iPhone and iPad) version was released in December 2010. The first version to deploy to the Web was released in 2009. It is the most widely used HyperCard/HyperTalk clone, and the only one that runs on all major operating systems. A developer release of v.8 was announced in New York on March 12, 2015. This major enhancement to the product includes a new, separate development language, known as \"LiveCode Builder\", which is capable of creating new object classes called \"widgets\". In earlier versions, the set of object classes was fixed, and could be enhanced only via the use of ordinary procedural languages such as C. The new language, which runs in its own IDE, is a departure from the transitional x-talk paradigm in that it permits typing of variables. But the two environments are fully integrated, and apart from the ability to create new objects, development in LiveCode proceeds in the normal way, within the established IDE. A second crowdfunding campaign to Bring HTML5 to LiveCode reached funding goals of nearly $400,000 USD on July 31, 2014. LiveCode developer release 8.0 DP4 (August 31, 2015) was the first to include a standalone deployment option to HTML5."
  },
  "260": {
    "label": "LiveScript",
    "wikipedia_pageid": 17731,
    "inception": { "time": "+2011-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 21],
    "typing": [10, 2],
    "description": "**LiveScript** is a functional programming language that compiles to JavaScript. It was created by Jeremy Ashkenas—the creator of CoffeeScript—along with Satoshi Muramaki, George Zahariev, and many others. Not to be confused with JavaScript (for a brief period in the 1990s,_LiveScript_ was the name of JavaScript)."
  },
  "261": {
    "label": "Logo",
    "wikipedia_pageid": 18334,
    "inception": { "time": "+1967-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 9, 21],
    "typing": [10],
    "description": "**Logo** is an educational programming language, designed in 1967 by Wally Feurzeig, Seymour Papert, and Cynthia Solomon. _Logo_ is not an acronym: the name was coined by Feurzeig while he was at Bolt, Beranek and Newman, and derives from the Greek _logos_, meaning _word_ or _thought_. A general-purpose language, Logo is widely known for its use of turtle graphics, in which commands for movement and drawing produced line or vector graphics, either on screen or with a small robot termed a turtle. The language was conceived to teach concepts of programming related to Lisp and only later to enable what Papert called \"body-syntonic reasoning\", where students could understand, predict, and reason about the turtle's motion by imagining what they would do if they were the turtle. There are substantial differences among the many dialects of Logo, and the situation is confused by the regular appearance of turtle graphics programs that are named Logo. Logo is a multi-paradigm adaptation and dialect of Lisp, a functional programming language. There is no standard Logo, but UCBLogo has the best facilities for handling lists, files, I/O, and recursion in scripts, and can be used to teach all computer science concepts, as UC Berkeley lecturer Brian Harvey did in his _Computer Science Logo Style_ trilogy. Logo is usually an interpreted language, although compiled Logo dialects (such as Lhogho and Liogo) have been developed. Logo is not case-sensitive but retains the case used for formatting purposes."
  },
  "262": {
    "label": "Logtalk",
    "wikipedia_pageid": 7792164,
    "inception": { "time": "+1998-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [28, 6, 14],
    "typing": [],
    "description": "**Logtalk** is an object-oriented logic programming language that extends and leverages the Prolog language with a feature set suitable for programming in the large. It provides support for encapsulation and data hiding, separation of concerns and enhanced code reuse. Logtalk uses standard Prolog syntax with the addition of a few operators and directives. The Logtalk language implementation is distributed under an open source license and can run using a Prolog implementation (compliant with official and de facto standards) as the back-end compiler."
  },
  "263": {
    "label": "LotusScript",
    "wikipedia_pageid": 239268,
    "inception": null,
    "paradigm": [6],
    "typing": [],
    "description": "**LotusScript** is an object oriented programming language used by Lotus Notes (since version 4.0) and other IBM Lotus Software products. LotusScript is similar to Visual Basic. Developers familiar with one can easily understand the syntax and structure of code in the other. The major differences between the two are in their respective Integrated Development Environments and in the product-specific object classes provided in each language that are included. VB includes a richer set of classes for UI manipulation, whereas LotusScript includes a richer set of application- specific classes for Lotus Notes, Lotus Word Pro and Lotus 1-2-3. In the case of Lotus Notes, there are classes to work with Notes databases, documents (records) in those databases, etc. These classes can also be used as OLE Automation objects outside the Lotus Notes environment, from Visual Basic. LotusScript also allows the definition of user-defined types and classes, although it is not possible to inherit from the product-specific classes. LotusScript programs can access Microsoft Office documents by using the OLE automation in libraries from MS Office."
  },
  "264": {
    "label": "Lua",
    "wikipedia_pageid": 46150,
    "inception": { "time": "+1993-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 21, 6, 14],
    "typing": [10, 1, 13],
    "description": "**Lua** (_LOO -ə_; from Portuguese: _lua_ [ˈlu.(w)ɐ] meaning _moon_) is a lightweight, high-level, multi-paradigm programming language designed primarily for embedded use in applications. Lua is cross-platform, since the interpreter of compiled bytecode is written in ANSI C, and Lua has a relatively simple C API to embed it into applications. Lua was originally designed in 1993 as a language for extending software applications to meet the increasing demand for customization at the time. It provided the basic facilities of most procedural programming languages, but more complicated or domain-specific features were not included; rather, it included mechanisms for extending the language, allowing programmers to implement such features. As Lua was intended to be a general embeddable extension language, the designers of Lua focused on improving its speed, portability, extensibility, and ease-of-use in development."
  },
  "265": {
    "label": "Lucid",
    "wikipedia_pageid": 1485589,
    "inception": { "time": "+1976-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [22, 15, 16, 13],
    "typing": [],
    "description": "**Lucid** is a dataflow programming language designed to experiment with non- von Neumann programming models. It was designed by Bill Wadge and Ed Ashcroft and described in the 1985 book _Lucid, the Dataflow Programming Language_. pLucid was the first interpreter for Lucid."
  },
  "266": {
    "label": "Lustre",
    "wikipedia_pageid": 2211835,
    "inception": { "time": "+1980-01-01T00:00:00Z", "precision": 8 },
    "paradigm": [22, 13, 17],
    "typing": [],
    "description": "**Lustre** is a formally defined, declarative, and synchronous dataflow programming language for programming reactive systems. It began as a research project in the early 1980s. A formal presentation of the language can be found in the 1991 Proceedings of the IEEE. In 1993 it progressed to practical, industrial use in a commercial product as the core language of the industrial environment SCADE, developed by Esterel Technologies. It is now used for critical control software in aircraft, helicopters, and nuclear power plants."
  },
  "267": {
    "label": "M#",
    "wikipedia_pageid": 39420392,
    "inception": { "time": "+2012-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [12, 2, 6, 25, 36],
    "typing": [10, 11],
    "description": "**M#** (pronounced _em sharp_) is a code generation tool and a domain- specific language that can be used to create websites and web applications. It can translate entities and page definitions to ASP.NET Web Forms and MVC and C# code which in turn form the user interface and business logic layer of the application. Its main goals are to reduce time of development, increase code quality, and reduce human errors."
  },
  "268": {
    "label": "M2001",
    "wikipedia_pageid": 941103,
    "inception": { "time": "+1998-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [18],
    "typing": [],
    "description": "**M2001** is a modular educational mathematical programming language for developing and presenting mathematical algorithms, from the modern discrete to the classical continuous mathematics. M2001 is built on a semantic framework that is based in category theory and has a syntax similar to that of Pascal or Modula-2. It is designed purely for pedagogic use, so efficiency and ease of implementation have been far less important in its development than generality and range of application. It was created to play an important role in forming a formal algorithmic foundation for first-year college math students."
  },
  "269": {
    "label": "m4",
    "wikipedia_pageid": 625653,
    "inception": { "time": "+1977-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**m4** is a general-purpose macro processor included in most Unix-like operating systems, and is a component of the POSIX standard. The language was designed by Brian Kernighan and Dennis Ritchie for the original versions of UNIX. It is an extension of an earlier macro processor,**m3**, written by Ritchie for an unknown AP-3 minicomputer. The macro preprocessor operates as a text-replacement tool. It is employed to re-use text templates, typically in computer programming applications, but also in text editing and text-processing applications. Most users require m4 as a dependency of GNU autoconf."
  },
  "270": {
    "label": "MAD",
    "wikipedia_pageid": 55579,
    "inception": { "time": "+1959-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3],
    "typing": [],
    "description": "**MAD** (**Michigan Algorithm Decoder**) is a programming language and compiler for the IBM 704 and later the IBM 709, IBM 7090, IBM 7040, UNIVAC 1107, UNIVAC 1108, Philco 210-211, and eventually the IBM S/370 mainframe computers. Developed in 1959 at the University of Michigan by Bernard Galler, Bruce Arden and Robert M. Graham, MAD is a variant of the ALGOL language. It was widely used to teach programming at colleges and universities during the 1960s and played a minor role in the development of CTSS, Multics, and the Michigan Terminal System computer operating systems. The archives at the Bentley Historical Library of the University of Michigan contain reference materials on the development of MAD and MAD/I, including three linear feet of printouts with hand-written notations and original printed manuals."
  },
  "271": {
    "label": "MAPPER",
    "wikipedia_pageid": 7920952,
    "inception": { "time": "+1968-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**MAPPER**, now known as BIS, is a fourth-generation programming language from Sperry Univac. Mapper originated in the 1970s based on some work in the 1960s, but has been kept current. It was renamed and also given an extension named ICE - Internet Commerce Enabler. Originally available on Sperry's Univac 1108, implementations now also exist for Windows NT, Sun Solaris and Linux. The GUI on Windows is the most advanced of these."
  },
  "272": {
    "label": "MARK IV",
    "wikipedia_pageid": 7918764,
    "inception": { "time": "+1964-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**MARK IV** is a fourth-generation programming language that was created by Informatics, Inc. in the 1960s. Informatics took advantage of IBM's decision to unbundle their software; MARK IV was the first \"software product to have cumulative sales of $10 million\". MARK IV was developed for IBM Systems (360 and 370) and for the RCA Spectra 70. Its main benefit was allowing faster application development on the order of 6 to 10 times faster than doing a system using a 3GL, such as COBOL. MARK IV, being an early 4GL, allowed user development of systems related to business. In a 1971 ad by Informatics, there are several quotes from customers, such as:     We conservatively estimate that the benefits derived from the MARK IV System have completely returned the cost of our investment in a period of less than 3 months.     MARK IV runs ... handle Accounts Receivable, Inventory, Sales Analyses, etc. on about 26 different factories. MARK IV went to Sterling Software in 1985 as part of that company's acquisition of Informatics General. As CA VISION:BUILDER, it became part of the product suite from Computer Associates once that company acquired Sterling Software in 2000. Following the acquisition of Computer Associates by Broadcom Inc in 2018, CA VISION:BUILDER was listed as a legacy product by the new owner."
  },
  "273": {
    "label": "MATH-MATIC",
    "wikipedia_pageid": 202110,
    "inception": { "time": "+1957-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3],
    "typing": [],
    "description": "**MATH-MATIC** is the marketing name for the AT-3 (Algebraic Translator 3) compiler, an early programming language for the UNIVAC I and UNIVAC II. MATH-MATIC was written beginning around 1955 by a team led by Charles Katz under the direction of Grace Hopper. A preliminary manual was produced in 1957 and a final manual the following year. Syntactically, MATH-MATIC was similar to Univac's contemporaneous business- oriented language, FLOW-MATIC, differing in providing algebraic-style expressions and floating-point arithmetic, and arrays rather than record structures."
  },
  "274": {
    "label": "MATLAB",
    "wikipedia_pageid": 20412,
    "inception": { "time": "+1984-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**MATLAB** (an abbreviation of \"matrix laboratory\") is a proprietary multi- paradigm programming language and numeric computing environment developed by MathWorks. MATLAB allows matrix manipulations, plotting of functions and data, implementation of algorithms, creation of user interfaces, and interfacing with programs written in other languages. Although MATLAB is intended primarily for numeric computing, an optional toolbox uses the MuPAD symbolic engine allowing access to symbolic computing abilities. An additional package, Simulink, adds graphical multi-domain simulation and model-based design for dynamic and embedded systems. As of 2020, MATLAB has more than 4 million users worldwide. MATLAB users come from various backgrounds of engineering, science, and economics."
  },
  "275": {
    "label": "MDL",
    "wikipedia_pageid": 586499,
    "inception": { "time": "+1971-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [25, 2, 9, 21],
    "typing": [10, 1],
    "description": "**MDL** (**Model Development Language**, or colloquially also referred to as **More Datatypes than Lisp** or **MIT Design Language**) is a programming language, a descendant of the language Lisp. Its initial purpose was to provide high level language support for the Dynamic Modeling Group at Massachusetts Institute of Technology's (MIT) Project MAC. It was initially developed in 1971 on a PDP-10 computer on a time-sharing operating system named Incompatible Timesharing System (ITS). It later ran on TENEX, TOPS-20, BSD, and AEGIS. The initial development team consisted of Gerald Sussman and Carl Hewitt of the Artificial Intelligence Lab, and Chris Reeve, Bruce Daniels, and David Cressey of the Dynamic Modeling Group. Later, Stu Galley, also of the Dynamic Modeling Group, wrote the MDL documentation. MDL was initially called _Muddle_. This style of self-deprecating humor was not widely understood or appreciated outside of Project MAC and a few other early citadels of information technology. So the name was sanitized to MDL. MDL provides several enhancements to classic Lisp. It supports several built- in data types, including lists, strings and arrays, and user-defined data types. It offers multithreaded expression evaluation and coroutines. Variables can carry both a local value within a scope, and a global value, for passing data between scopes. Advanced built-in functions supported interactive debugging of MDL programs, incremental development, and reconstruction of source programs from object programs. Although MDL is obsolete, some of its features have been incorporated in later versions of Lisp. Gerald Sussman went on to develop the Scheme language, in collaboration with Guy Steele, who later wrote the specifications for Common Lisp and Java. Carl Hewitt had already published the idea for the language _Planner_ before the MDL project began, but his subsequent thinking on Planner reflected lessons learned from building MDL. Planner concepts influenced languages such as Prolog and Smalltalk. Smalltalk and Simula, in turn, influenced Hewitt's future work on the actor model. But the largest influence that MDL had was on the software genre of interactive fiction (IF). An IF game named Zork, sometimes called Dungeon, was first written in MDL. Later, Reeve, Daniels, Galley and other members of Dynamic Modeling went on to start Infocom, a company that produced many early commercial works of interactive fiction. In 1980 Marc Blank and Joel Berez adapted the MDL language to create a subset called ZIL (Zork Implementation Language) which was used extensively by Infocom to create their award winning games. ZIL (Zork Implementation Language) remains in active usage with communities on Discord and Facebook, in this way the legacy of MDL directly lives on."
  },
  "276": {
    "label": "MIIS",
    "wikipedia_pageid": 3359079,
    "inception": null,
    "paradigm": [],
    "typing": [10],
    "description": "**MIIS** (Meditech Interpretive Information System) is a MUMPS-like programming language that was created by A.Neil Pappalardo and Curt W. Marble, on a DEC PDP at Mass General Hospital from 1964 to 1968. MUMPS evolution took two major directions: MUMPS proper and MIIS. MUMPS became an ANSI and ISO- standard language. When many MUMPS implementations standardized to be compatible, MIIS did not standardize, but became a proprietary system instead. As an example of the differences between MUMPS and MIIS, the value of a logical expression in MUMPS may be false = zero (0) or true = non-zero, canonically, one (1). In MIIS, the value false is the empty string and the value of true is a string consisting of the ASCII delete character (code 127 decimal). There is also a philosophical difference between the dialects. MIIS often takes the approach that code should march along, regardless of possible errors, where MUMPS will error out to prevent more serious problems. For example, when encountering an undefined variable, MUMPS generates an error where MIIS treats it as nil. In the 1980s Brigham and Women's Hospital in Massachusetts used MIIS to program their Data General Mainframe. In 1986, SCAMC reported that Vancouver General Hospital also had an Integrated Cardiology Patient Management System written in MIIS. The MIIS language has been used in programming library systems as well as health industry systems. The OCLC's library system is one example. It has also been used to create financial systems for insurance brokers, as seen in Ireland and the UK in the late 1970s."
  },
  "277": {
    "label": "MIMIC",
    "wikipedia_pageid": 4017688,
    "inception": { "time": "+1964-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [],
    "description": "**MIMIC**, known in capitalized form only, is a former simulation computer language developed 1964 by H. E. Petersen, F. J. Sansom and L. M. Warshawsky of Systems Engineering Group within the Air Force Materiel Command at the Wright-Patterson AFB in Dayton, Ohio, United States. It is an expression- oriented continuous block simulation language, but capable of incorporating blocks of FORTRAN-like algebra. MIMIC is a further development from MIDAS (**M** odified **I** ntegration **D** igital **A** nalog **S** imulator), which represented analog computer design. Written completely in FORTRAN but one routine in COMPASS, and ran on Control Data supercomputers, MIMIC is capable of solving much larger simulation models. With MIMIC, ordinary differential equations describing mathematical models in several scientific disciplines as in engineering, physics, chemistry, biology, economics and as well as in social sciences can easily be solved by numerical integration and the results of the analysis are listed or drawn in diagrams. It also enables the analysis of nonlinear dynamic conditions. The MIMIC software package, written as FORTRAN overlay programs, executes input statements of the mathematical model in six consecutive passes. Simulation programs written in MIMIC are compiled rather than interpreted. The core of the simulation package is a variable step numerical integrator of fourth-order Runge-Kutta method. Many useful functions related to electrical circuit elements exist besides some mathematical functions found in most scientific programming languages. There is no need to sort the statements in order of dependencies of the variables, since MIMIC does it internally. Parts of the software organized in overlays are:   * MIMIN (input)– reads in user simulation program and data,   * MIMCO (compiler) – compiles the user program and creates an in-core array of instructions,   * MIMSO (sort)– sorts the instructions array after dependencies of variables,   * MIMAS (assembler) – converts the BCD instructions into machine-oriented code,   * MIMEX (execute)– executes the user program by integrating,   * MIMOUT (output)– puts out the data as a list or diagram of data."
  },
  "278": {
    "label": "mIRC scripting language",
    "wikipedia_pageid": 310996,
    "inception": { "time": "+1995-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [12, 2],
    "typing": [10],
    "description": "The **mIRC scripting language** (often unofficially abbreviated to \"**mSL**\") is the scripting language embedded in mIRC, an IRC client for Windows."
  },
  "279": {
    "label": "MIVA Script",
    "wikipedia_pageid": 849448,
    "inception": { "time": "+1996-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3],
    "typing": [10],
    "description": "**Miva Script** is a proprietary computer scripting language mainly used for internet applications such as e-commerce. As of 2015, it is developed, maintained and owned by Miva Merchant, Inc., based in San Diego, California. Many web hosting companies support Miva Script on their servers, but it is significantly less widespread than other popular web languages."
  },
  "280": {
    "label": "ML",
    "wikipedia_pageid": 20607,
    "inception": { "time": "+1973-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 21],
    "typing": [1, 6, 11],
    "description": "**ML** (**Meta Language**) is a general-purpose functional programming language. It is known for its use of the polymorphic Hindley–Milner type system, which automatically assigns the types of most expressions without requiring explicit type annotations, and ensures type safety – there is a formal proof that a well-typed ML program does not cause runtime type errors. ML provides pattern matching for function arguments, garbage collection, imperative programming, call-by-value and currying. It is used heavily in programming language research and is one of the few languages to be completely specified and verified using formal semantics. Its types and pattern matching make it well-suited and commonly used to operate on other formal languages, such as in compiler writing, automated theorem proving, and formal verification."
  },
  "281": {
    "label": "MPD",
    "wikipedia_pageid": 928466,
    "inception": null,
    "paradigm": [16],
    "typing": [],
    "description": "**Multithreaded, Parallel, and Distributed Programming** (**MPD**) is a concurrent programming language whose syntax is derived from the one used in the book _Foundations of Multithreaded, Parallel, and Distributed Programming_. The name lists the distinguishing features of the language, namely that it supports all three of these concurrent programming techniques. MPD is implemented as a variant of the SR programming language. It has a different parser, but it uses the same intermediate form and run-time system as SR. Consequently, MPD provides the same variety of concurrent programming mechanisms as does SR. MPD programs can execute on single processors, shared-memory multiprocessors, or clusters of (homogeneous) processors. The implementation transparently supports a variety of different kinds of processors and Unix systems."
  },
  "282": {
    "label": "MUMPS",
    "wikipedia_pageid": 19723,
    "inception": { "time": "+1966-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3],
    "typing": [],
    "description": "**MUMPS** (\"Massachusetts General Hospital Utility Multi-Programming System\"), or **M**, is a high performance transaction processing key–value database with integrated programming language. It was originally developed at Massachusetts General Hospital for managing hospital laboratory information systems. MUMPS technology has since expanded as the predominant database for health information systems and electronic health records in the United States. MUMPS- based information systems run over 40% of the hospitals in the U.S., run across all of the U.S. federal hospitals and clinics, and provide health information services for over 54% of patients across the U.S. A unique feature of the MUMPS technology is its integrated database language, allowing direct, high-speed read-write access to permanent disk storage. This provides tight integration of unlimited applications within a single database, and provides extremely high performance and reliability as an online transaction processing system."
  },
  "283": {
    "label": "machine code",
    "wikipedia_pageid": 20683,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "In computer programming,**machine code**, consisting of **machine language** instructions, is a low-level programming language used to directly control a computer's central processing unit (CPU). Each instruction causes the CPU to perform a very specific task, such as a load, a store, a jump, or an arithmetic logic unit (ALU) operation on one or more units of data in the CPU's registers or memory. Machine code is a strictly numerical language which is intended to run as fast as possible, and it may be regarded as the lowest-level representation of a compiled or assembled computer program or as a primitive and hardware- dependent programming language. While it is possible to write programs directly in machine code, managing individual bits and calculating numerical addresses and constants manually is tedious and error-prone. For this reason, programs are very rarely written directly in machine code in modern contexts, but may be done for low level debugging, program patching (especially when assembler source is not available) and assembly language disassembly. The majority of practical programs today are written in higher-level languages or assembly language. The source code is then translated to executable machine code by utilities such as compilers, assemblers, and linkers, with the important exception of interpreted programs, which are not translated into machine code. However, the _interpreter_ itself, which may be seen as an executor or processor performing the instructions of the source code, typically consists of directly executable machine code (generated from assembly or high-level language source code). Machine code is by definition the lowest level of programming detail visible to the programmer, but internally many processors use microcode or optimise and transform machine code instructions into sequences of micro-ops. This is not generally considered to be a machine code."
  },
  "284": {
    "label": "Macsyma",
    "wikipedia_pageid": 303734,
    "inception": { "time": "+1968-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**Macsyma** (; \"Project MAC's SYmbolic MAnipulator\") is one of the oldest general-purpose computer algebra systems still in wide use. It was originally developed from 1968 to 1982 at MIT's Project MAC. In 1982, Macsyma was licensed to Symbolics and became a commercial product. In 1992, Symbolics Macsyma was spun off to Macsyma, Inc., which continued to develop Macsyma until 1999. That version is still available for Microsoft's Windows XP operating system. The 1982 version of MIT Macsyma remained available to academics and US government agencies, and it is distributed by the US Department of Energy (DOE). That version, DOE Macsyma, was maintained by Bill Schelter. Under the name of Maxima, it was released under the GPL in 1999, and remains under active maintenance."
  },
  "285": {
    "label": "Magik",
    "wikipedia_pageid": 2988758,
    "inception": { "time": "+1989-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [10],
    "description": "**Magik** is an object-oriented programming language that supports multiple inheritance and polymorphism, and it is dynamically typed. It was designed and implemented in 1989 by Arthur Chance of Smallworld Systems Ltd. as part of Smallworld Geographical Information System (GIS). Following Smallworld's acquisition in 2000, Magik is now provided by GE Energy, still as part of its Smallworld technology platform. Magik (Inspirational Magik) was originally introduced in 1990 and has been improved and updated over the years. Its current version is 5.2. In July 2012, Magik developers announced that they were in the process of porting Magik language on the Java virtual machine. The successful porting was confirmed by Oracle Corporation in November of the same year."
  },
  "286": {
    "label": "Magma",
    "wikipedia_pageid": 98628,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**Magma** is a computer algebra system designed to solve problems in algebra, number theory, geometry and combinatorics. It is named after the algebraic structure magma. It runs on Unix-like operating systems, as well as Windows."
  },
  "287": {
    "label": "Maple",
    "wikipedia_pageid": 79099,
    "inception": { "time": "+1982-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 2, 21],
    "typing": [],
    "description": "**Maple** is a symbolic and numeric computing environment as well as a multi- paradigm programming language. It covers several areas of technical computing, such as symbolic mathematics, numerical analysis, data processing, visualization, and others. A toolbox, MapleSim, adds functionality for multidomain physical modeling and code generation. Maple's capacity for symbolic computing include those of a general-purpose computer algebra system. For instance, it can manipulate mathematical expressions and find symbolic solutions to certain problems, such as those arising from ordinary and partial differential equations. Maple is developed commercially by the Canadian software company Maplesoft. The name 'Maple' is a reference to the software's Canadian heritage."
  },
  "288": {
    "label": "Mary",
    "wikipedia_pageid": 20340,
    "inception": { "time": "+1971-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3],
    "typing": [1, 11],
    "description": "**Mary** is a programming language designed and implemented by RUNIT at Trondheim, Norway in the 1970s. It borrowed many features from ALGOL 68 but was designed for systems programming (machine-oriented programming). An unusual feature of its syntax was that expressions were constructed using the conventional infix operators, but all of them had the same precedence and evaluation went from left to right unless there were brackets. Assignment had the destination on the right and assignment was considered just another operator. Similar to C, several language features appear to have existed to allow producing reasonably well optimised code, despite a quite primitive code generator in the compiler. These included operators similar to the `+=` _et alter_ in C and explicit register declarations for variables. Notable features:   * Dataflow syntax – values flow from left to right, including assignment   * Most constructs could be used in expressions: blocks, IF, CASE, etc.   * Text-based recursive macros   * Overloaded user-defined operators, not constrained to predefined identifiers as in C++   * Automatic building and dereferencing of pointers from type context   * Scalar range types   * Array and set enumeration in loop iterators   * Dynamic array descriptors (ROW) A book describing Mary was printed in 1974 (Fourth and last edition in 1979): _Mary Textbook_ by Reidar Conradi & Per Holager. Compilers were made for Kongsberg Våpenfabrikk's SM-4 and Norsk Data Nord-10/ND-100 mini-computers. The original Mary compiler was written in NU ALGOL, ran on the Univac-1100 series and was used to bootstrap a native compiler for ND-100/Sintran-III. RUNIT implemented a CHILL compiler written in Mary which ran on ND-100 and had Intel 8086 and 80286 targets. When this compiler was ported to the VAX platform, a common backend for Mary and CHILL was implemented. Later, backends for i386 and SPARC were available. Since the Mary compiler was implemented in Mary, it was possible to run the compiler on all these platforms. Mary is no longer maintained."
  },
  "289": {
    "label": "Maude system",
    "wikipedia_pageid": 1251423,
    "inception": null,
    "paradigm": [28, 25, 9],
    "typing": [],
    "description": "The **Maude system** is an implementation of rewriting logic developed at SRI International. It is similar in its general approach to Joseph Goguen's OBJ3 implementation of equational logic, but based on rewriting logic rather than order-sorted equational logic, and with a heavy emphasis on powerful metaprogramming based on reflection. Maude is free software, and tutorials are available online."
  },
  "290": {
    "label": "Max",
    "wikipedia_pageid": 479795,
    "inception": null,
    "paradigm": [10, 13],
    "typing": [],
    "description": "**Max**, also known as Max/MSP/Jitter, is a visual programming language for music and multimedia developed and maintained by San Francisco-based software company Cycling '74. Over its more than thirty-year history, it has been used by composers, performers, software designers, researchers, and artists to create recordings, performances, and installations. The Max program is modular, with most routines existing as shared libraries. An application programming interface (API) allows third-party development of new routines (named _external objects_). Thus, Max has a large user base of programmers unaffiliated with Cycling '74 who enhance the software with commercial and non-commercial extensions to the program. Because of this extensible design, which simultaneously represents both the program's structure and its graphical user interface (GUI), Max has been described as the lingua franca for developing interactive music performance software."
  },
  "291": {
    "label": "Maxima",
    "wikipedia_pageid": 95925,
    "inception": { "time": "+1982-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**Maxima** () is a computer algebra system (CAS) based on a 1982 version of Macsyma. It is written in Common Lisp and runs on all POSIX platforms such as macOS, Unix, BSD, and Linux, as well as under Microsoft Windows and Android. It is free software released under the terms of the GNU General Public License (GPL)."
  },
  "292": {
    "label": "Maya Embedded Language",
    "wikipedia_pageid": 1690201,
    "inception": { "time": "+1998-02-00T00:00:00Z", "precision": 10 },
    "paradigm": [],
    "typing": [],
    "description": "The **Maya Embedded Language** (MEL) is a scripting language used to simplify tasks in Autodesk's 3D Graphics Software _Maya_. Most tasks that can be achieved through Maya's GUI can be achieved with MEL, as well as certain tasks that are not available from the GUI. MEL offers a method of speeding up complicated or repetitive tasks, as well as allowing users to redistribute a specific set of commands to others that may find it useful."
  },
  "293": {
    "label": "Mercury",
    "wikipedia_pageid": 19726,
    "inception": { "time": "+1995-04-08T00:00:00Z", "precision": 11 },
    "paradigm": [28, 6, 29, 21],
    "typing": [3, 1, 11],
    "description": "**Mercury** is a functional logic programming language made for real-world uses. The first version was developed at the University of Melbourne, Computer Science department, by Fergus Henderson, Thomas Conway, and Zoltan Somogyi, under Somogyi's supervision, and released on April 8, 1995. Mercury is a purely declarative logic programming language. It is related to both Prolog and Haskell. It features a strong, static, polymorphic type system, and a strong mode and determinism system. The official implementation, the Melbourne Mercury Compiler, is available for most Unix and Unix-like platforms, including Linux, macOS, and for Windows."
  },
  "294": {
    "label": "Mesa",
    "wikipedia_pageid": 19962,
    "inception": { "time": "+1976-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2],
    "typing": [1, 11],
    "description": "**Mesa** is a programming language developed in the late 1970s at the Xerox Palo Alto Research Center in Palo Alto, California, United States. The language name was a pun based upon the programming language catchphrases of the time, because Mesa is a \"high level\" programming language. Mesa is an ALGOL-like language with strong support for modular programming. Every library module has at least two source files: a _definitions_ file specifying the library's interface plus one or more _program_ files specifying the implementation of the procedures in the interface. To use a library, a program or higher-level library must \"import\" the definitions. The Mesa compiler type-checks all uses of imported entities; this combination of separate compilation with type-checking was unusual at the time. Mesa introduced several other innovations in language design and implementation, notably in the handling of software exceptions, thread synchronization, and incremental compilation. Mesa was developed on the Xerox Alto, one of the first personal computers with a graphical user interface, however, most of the Alto's system software was written in BCPL. Mesa was the system programming language of the later Xerox Star workstations, and for the GlobalView desktop environment. Xerox PARC later developed Cedar, which was a superset of Mesa. Mesa and Cedar had a major influence on the design of other important languages, such as Modula-2 and Java, and was an important vehicle for the development and dissemination of the fundamentals of GUIs, networked environments, and the other advances Xerox contributed to the field of computer science."
  },
  "295": {
    "label": "Microassembler",
    "wikipedia_pageid": 20072,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "A **microassembler** is a computer program that helps prepare a microprogram, called _firmware_, to control the low level operation of a computer in much the same way an assembler helps prepare higher level code for a processor. The difference is that the microprogram is usually only developed by the processor manufacturer and works intimately with the computer hardware. On a microprogrammed computer the microprogram implements the operations of the instruction set in which any normal program (including both application programs and operating systems) is written. The use of a microprogram allows the manufacturer to fix certain mistakes, including working around hardware design errors, without modifying the hardware. Another means of employing microassembler-generated microprograms is in allowing the same hardware to run different instruction sets. After it is assembled, the microprogram is then loaded to a control store to become part of the logic of a CPU's control unit. Some microassemblers are more generalized and are not targeted at a single computer architecture. For example, through the use of macro-assembler-like capabilities, Digital Equipment Corporation used their _MICRO2_ microassembler for a very wide range of computer architectures and implementations. If a given computer implementation supports a writeable control store, the microassembler is usually provided to customers as a means of writing customized microcode. In the process of microcode assembly it is helpful to verify the microprogram with emulation tools before distribution. Nowadays, microcoding has experienced a revival, since it is possible to correct and optimize the firmware of processing units already manufactured or sold, in order to adapt to specific operating systems or to fix hardware bugs. However, a commonly usable microassembler for today's CPUs is not available to manipulate the microcode. Unfortunately, knowledge of a processor's microcode is usually considered proprietary information so it is difficult to obtain information about how to modify it."
  },
  "296": {
    "label": "Microsoft Macro Assembler",
    "wikipedia_pageid": 1061469,
    "inception": { "time": "+1981-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "The **Microsoft Macro Assembler** (**MASM**) is an x86 assembler that uses the Intel syntax for MS-DOS and Microsoft Windows. Beginning with MASM 8.0, there are two versions of the assembler: One for 16-bit & 32-bit assembly sources, and another (**ML64**) for 64-bit sources only. MASM is maintained by Microsoft, but since version 6.12 it has not been sold as a separate product. It is instead supplied with various Microsoft SDKs and C compilers. Recent versions of MASM are included with Microsoft Visual Studio."
  },
  "297": {
    "label": "Power Fx",
    "wikipedia_pageid": 67099860,
    "inception": null,
    "paradigm": [3, 13, 21],
    "typing": [1],
    "description": "**Microsoft Power Fx** is a free and open source low-code, general-purpose programming language for expressing logic across the Microsoft Power Platform. The programming language was first announced at Ignite 2021 and the specification was released in March 2021. It is based on spreadsheet-like formulas to make it accessible to a large number of people. Power Fx was also influenced by programming languages and tools like Pascal, Mathematica, and Miranda. As Microsoft describes the language, it heavily borrows from the spreadsheet paradigm. In a spreadsheet, cells can contain formulas referring to the contents of other cells, and if the user changes the content of a cell, the values of all dependent cells are automatically updated. In a similar fashion, the various properties of components in a Power Fx program are connected by formulas (whose syntax is very reminiscent of Excel) and their values are automatically updated if changes occur. For instance, a simple formula might connect the color property of some component to the value of a slider component, and if the user moves the slider, the color will automatically change. The Power Fx language was developed by a team at Microsoft led by Vijay Mital, Robin Abraham, Shon Katzenberger and Darryl Rubin. It is open source released under MIT License and is under active development on GitHub."
  },
  "298": {
    "label": "Mirah",
    "wikipedia_pageid": 27970668,
    "inception": { "time": "+2008-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 3],
    "typing": [1, 10, 6, 11],
    "description": "**Mirah** (formerly **Duby**) is a programming language based on Ruby language syntax, local type inference, hybrid static–dynamic type system, and a pluggable compiler toolchain. Mirah was created by Charles Oliver Nutter to be \"a 'Ruby-like' language, probably a subset of Ruby syntax, that [could] compile to solid, fast, idiomatic JVM bytecode.\" The word __mirah__ refers to the gemstone ruby in the Javanese language, a play on the concept of Ruby in Java."
  },
  "299": {
    "label": "Miranda",
    "wikipedia_pageid": 93267,
    "inception": { "time": "+1985-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [29, 13],
    "typing": [1, 11],
    "description": "**Miranda** is a lazy, purely functional programming language designed by David Turner as a successor to his earlier programming languages SASL and KRC, using some concepts from ML and Hope. It was produced by Research Software Ltd. of England (which holds a trademark on the name _Miranda_) and was the first purely functional language to be commercially supported. Miranda was first released in 1985, as a fast interpreter in C for Unix- flavour operating systems, with subsequent releases in 1987 and 1989. Miranda had a strong influence on the later Haskell programming language."
  },
  "300": {
    "label": "Modelica",
    "wikipedia_pageid": 1467946,
    "inception": { "time": "+1997-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 13],
    "typing": [],
    "description": "**Modelica** is an object-oriented, declarative, multi-domain modeling language for component-oriented modeling of complex systems, e.g., systems containing mechanical, electrical, electronic, hydraulic, thermal, control, electric power or process-oriented subcomponents. The free Modelica language is developed by the non-profit Modelica Association. The Modelica Association also develops the free Modelica Standard Library that contains about 1400 generic model components and 1200 functions in various domains, as of version 4.0.0."
  },
  "301": {
    "label": "Modula",
    "wikipedia_pageid": 20824,
    "inception": { "time": "+1975-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 18],
    "typing": [1, 11],
    "description": "The **Modula** programming language is a descendant of the Pascal language. It was developed in Switzerland, at ETH Zurich, in the mid-1970s by Niklaus Wirth, the same person who designed Pascal. The main innovation of Modula over Pascal is a module system, used for grouping sets of related declarations into program units; hence the name _Modula_. The language is defined in a report by Wirth called _Modula. A language for modular multiprogramming_ published 1976. Modula was first implemented by Wirth on a PDP-11. Very soon, other implementations followed, most importantly, the compilers developed for University of York Modula, and one at Philips Laboratories named PL Modula, which generated code for the LSI-11 microprocessor. The development of Modula was discontinued soon after its publication. Wirth then concentrated his efforts on Modula's successor, Modula-2."
  },
  "302": {
    "label": "Modula-2",
    "wikipedia_pageid": 24102707,
    "inception": { "time": "+1978-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [18, 3, 16, 36],
    "typing": [1, 11],
    "description": "**Modula-2** is a structured, procedural programming language developed between 1977 and 1985 by Niklaus Wirth at ETH Zurich. It was created as the language for the operating system and application software of the Lilith personal workstation. It was later used for programming outside the context of the Lilith. Wirth viewed Modula-2 as a successor to his earlier programming languages Pascal and Modula. The main concepts are:   1. The module as a compiling unit for separate compiling   2. The coroutine as the basic building block for concurrent processes   3. Types and procedures that allow access to machine-specific data The language design was influenced by the Mesa language and the Xerox Alto, both from Xerox PARC, that Wirth saw during his 1976 sabbatical year there. The computer magazine _Byte_ devoted the August 1984 issue to the language and its surrounding environment. Modula-2 was followed by Modula-3, and later by the Oberon series of languages."
  },
  "303": {
    "label": "Modula-3",
    "wikipedia_pageid": 241545,
    "inception": { "time": "+1989-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 3],
    "typing": [],
    "description": "**Modula-3** is a programming language conceived as a successor to an upgraded version of Modula-2 known as Modula-2+. While it has been influential in research circles (influencing the designs of languages such as Java, C#, and Python) it has not been adopted widely in industry. It was designed by Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan (before at the Olivetti Software Technology Laboratory), Bill Kalsow and Greg Nelson at the Digital Equipment Corporation (DEC) Systems Research Center (SRC) and the Olivetti Research Center (ORC) in the late 1980s. Modula-3's main features are simplicity and safety while preserving the power of a systems-programming language. Modula-3 aimed to continue the Pascal tradition of type safety, while introducing new constructs for practical real- world programming. In particular Modula-3 added support for generic programming (similar to templates), multithreading, exception handling, garbage collection, object-oriented programming, partial revelation, and explicit marking of unsafe code. The design goal of Modula-3 was a language that implements the most important features of modern imperative programming languages in quite basic forms. Thus allegedly dangerous and complicating features such as multiple inheritance and operator overloading were omitted."
  },
  "304": {
    "label": "Mouse",
    "wikipedia_pageid": 6378343,
    "inception": { "time": "+1970-01-01T00:00:00Z", "precision": 8 },
    "paradigm": [33],
    "typing": [],
    "description": "The **Mouse programming language** is a small computer programming language developed by Dr. Peter Grogono in the late 1970s and early 1980s. It was developed as an extension of an earlier language called MUSYS, which was used to control digital and analog devices in an electronic music studio. Mouse was originally intended as a small, efficient language for microcomputers with limited memory. It is an interpreted, stack-based language and uses Reverse Polish notation. To make an interpreter as easy as possible to implement, Mouse is designed so that a program is processed as a stream of characters, interpreted one character at a time. The elements of the Mouse language consist of a set of (mostly) one-character symbols, each of which performs a specific function (see table below). Since variable names are limited to one character, there are only 26 possible variables in Mouse (named A-Z). Integers and characters are the only available data types. Despite these limits, Mouse includes a number of relatively advanced features, including:   * Conditional branching   * Loops   * Pointers   * Macros (subroutines (which may be recursive))   * Arrays   * Code tracing The design of the Mouse language makes it ideal for teaching the design of a simple interpreter. Much of the book describing Mouse is devoted to describing the implementation of two interpreters, one in Z80 assembly language, the other in Pascal."
  },
  "305": {
    "label": "MuPAD",
    "wikipedia_pageid": 30874575,
    "inception": { "time": "+1997-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 21],
    "typing": [],
    "description": "**MuPAD** is a computer algebra system (CAS). Originally developed by the MuPAD research group at the University of Paderborn, Germany, development was taken over by the company SciFace Software GmbH & Co. KG in cooperation with the MuPAD research group and partners from some other universities starting in 1997. MuPAD's graphics package was particularly successful, especially considering the era when it was developed. Until autumn 2005, the version \"MuPAD Light\" was offered for free for research and education, but as a result of the closure of the home institute of the MuPAD research group, only the version \"MuPAD Pro\" became available for purchase. The MuPAD kernel is bundled with Scientific Notebook and Scientific Workplace. Former versions of _MuPAD Pro_ were bundled with SciLab. In MathCAD's version 14 release Mupad was adopted as the CAS engine. In September 2008, SciFace was purchased by MathWorks and the MuPAD code was included in the Symbolic Math Toolbox add-on for MATLAB. On 28 September 2008, MuPAD was withdrawn from the market as a software product in its own right. However, it is still available in the Symbolic Math Toolbox in MATLAB and can also be used as a stand-alone program by the command `mupad` entered into the MATLAB terminal. The MuPAD notebook feature has been removed in MATLAB R2020a. However, MATLAB's Symbolic Math Toolbox still uses the MuPAD language as part of its underlying computational engine. MATLAB Live Editor is the recommended environment for performing, documenting, and sharing symbolic math computations."
  },
  "306": {
    "label": "NESL",
    "wikipedia_pageid": 919571,
    "inception": { "time": "+1993-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [20, 7, 21],
    "typing": [],
    "description": "**NESL** is a parallel programming language developed at Carnegie Mellon by the SCandAL project and released in 1993. It integrates various ideas from parallel algorithms, and functional programming and array programming languages. The most important new ideas behind NESL are   * **Nested data parallelism** : this feature offers the benefits of data parallelism, concise code that is easy to understand and debug, while being well suited for irregular algorithms, such as algorithms on trees, graphs or sparse matrices.   * **A language based performance model** : this gives a formal way to calculate the work and depth of a program. These measures can be related to running time on parallel machines. The main design guideline for NESL was to make parallel programming easy and portable. Algorithms are typically significantly more concise in NESL than in most other parallel programming languages, and the code closely resembles high-level pseudocode. NESL supports nested data parallelism by using the flattening transform to convert nested data parallelism to flat data parallelism. This works by storing nested vectors as the nested data and a segment descriptor of vector lengths, separately. This flattening transform, however, can increase the asymptotic work and space complexity of the original program, leading to a much less efficient result."
  },
  "307": {
    "label": "NEWP",
    "wikipedia_pageid": 6433017,
    "inception": null,
    "paradigm": [2, 3, 36],
    "typing": [1, 11],
    "description": "**New Executive Programming Language** (**NEWP**) is a high-level programming language used on computers running the Unisys operating system _Master Control Program_ (MCP). The language is used to write the operating system and other system utility software, though it can also be used to write user software. Several constructs separate it from extended ALGOL on which it is based. Language operators such as `MEMORY` which allows direct memory access are strictly used by programs running as the MCP. NEWP replaced Burroughs Executive Systems Problem Oriented Language (ESPOL)"
  },
  "308": {
    "label": "Nord Programming Language",
    "wikipedia_pageid": 8295240,
    "inception": null,
    "paradigm": [2],
    "typing": [],
    "description": "**Nord Programming Language**, commonly abbreviated **NPL**, was a programming language by the Norwegian minicomputer manufacturer Norsk Data. It shipped as a standard component of the operating system SINTRAN III. The language was also used to implement SINTRAN III. I.e. the core and file system of SINTRAN III was written in NPL. The NPL compiler was also written in NPL and some core applications was early on written in NPL until PLANC came and linker and other software was rewritten in PLANC. The NPL compiler was also special in that it did not produce object code as most compilers do. Instead it produced assembler code which then had to be assembled using the Norsk Data Assembler. The registers of the CPU were available in NPL as predefined variables. Thus you could write:               X + T =: A      and the compiler would generate:               COPY SX DA     RADD ST DA      Functions could be declared with multiple entry points:               FUNC FUN1, FUN2          FUN1: T := 1     FUN2:          code here          END      FUN1 could be called to set T to 1 before falling into FUN2 or T could be set to something else and call FUN2. If T register specified which file handle to write to then either FUN1 could be called to always output to terminal or T could be specified to handle a file itself in T and call FUN2 to output to that file."
  },
  "309": {
    "label": "NWScript",
    "wikipedia_pageid": 853032,
    "inception": { "time": "+2002-06-18T00:00:00Z", "precision": 11 },
    "paradigm": [],
    "typing": [],
    "description": "**NWScript** is the scripting language developed by BioWare for the role- playing video game _Neverwinter Nights_. It is based on the C programming language and is implemented in the Aurora toolset. Neverscript, an open source 3rd party editor, has been created for the Mac OS X and Linux versions of _Neverwinter Nights_ because the Aurora toolset has not been ported to those platforms. NWScript is also used in the video games _The Witcher_,_Star Wars: Knights of the Old Republic_ and _Star Wars: Knights of the Old Republic II The Sith Lords_, which use the Odyssey Engine. _Neverwinter Nights 2_, the sequel to the original _NWN_, features a modified version of this scripting language."
  },
  "310": {
    "label": "Napier88",
    "wikipedia_pageid": 5748470,
    "inception": { "time": "+1988-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 36],
    "typing": [],
    "description": "**Napier88** is an orthogonally persistent programming language that was designed and implemented at the University of St Andrews, Scotland. The primary designer was Ron Morrison, whose initial designs were extended and implemented by Fred Brown, Richard Connor, and Al Dearle. Napier88 was ahead of its time in many ways, and was the first robustly implemented language to combine a polymorphic type system with orthogonal persistence. The language was robustly implemented and released to users from both industry and academia; up to 1,000 registered users were recorded in due course. The language, however, was only intended to provide a proof of concept for an experiment in persistent programming; some time after 1989 (the year the first implementation was in fact released) the group's interests moved on and the language was no longer maintained. Its influence lives on in various other systems however; the CORBA type `ANY` is distinctly recognisable in Napier88's type `ANY`; Microsoft's Common Language Runtime (CLR) uses a similar polymorphic architecture, and Java's parametric types solve some of the same problems of uninstantiated types escaping from their static scope."
  },
  "311": {
    "label": "Neko",
    "wikipedia_pageid": 15110419,
    "inception": { "time": "+2005-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 14, 36],
    "typing": [10],
    "description": "**NekoVM** is a virtual machine developed by Nicolas Cannasse as part of research and development (R&D) efforts at two indie video game firms in Bordeaux, France: first at Motion Twin and then at Shiro Games. NekoVM's native language is the bytecode for a high-level dynamically typed programming language called **Neko**. This pairing allows Neko to be used directly as an embedded scripting language or to target NekoVM by compiling some other language (such as Haxe) to NekoVM bytecode."
  },
  "312": {
    "label": "Nemerle",
    "wikipedia_pageid": 30883042,
    "inception": { "time": "+2003-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 21, 6, 25],
    "typing": [4, 1, 6, 11],
    "description": "**Nemerle** is a general-purpose, high-level, statically typed programming language designed for platforms using the Common Language Infrastructure (.NET/Mono). It offers functional, object-oriented and imperative features. It has a simple C#-like syntax and a powerful metaprogramming system. In June 2012, the core developers of Nemerle were hired by the Czech software development company JetBrains. The team is focusing on developing Nitra, a framework to implement extant and new programming languages. This framework will likely be used to create future versions of Nemerle. Nemerle is named after the Archmage Nemmerle, a character in the fantasy novel _A Wizard of Earthsea_ by Ursula K. Le Guin."
  },
  "313": {
    "label": "Net.Data",
    "wikipedia_pageid": 18491810,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**Net.Data** is a programming language by IBM used largely for database-backed web applications. It is a server-side scripting language that extends Web servers by enabling the dynamic generation of Web pages using data from a variety of data sources. The data sources can include relational and non-relational database management systems."
  },
  "314": {
    "label": "NetLogo",
    "wikipedia_pageid": 593757,
    "inception": { "time": "+1999-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [19, 2],
    "typing": [10, 1],
    "description": "**NetLogo** is a programming language and integrated development environment (IDE) for agent-based modeling."
  },
  "315": {
    "label": "NetRexx",
    "wikipedia_pageid": 11690683,
    "inception": { "time": "+1996-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 2, 36],
    "typing": [10, 1, 11],
    "description": "**NetRexx** is an open source, originally IBM's, variant of the REXX programming language to run on the Java virtual machine. It supports a classic REXX syntax, with no reserved keywords, along with considerable additions to support object-oriented programming in a manner compatible with Java's object model, yet can be used as both a compiled and an interpreted language, with an option of using only data types native to the JVM or the NetRexx runtime package. The latter offers the standard Rexx data type that combines string processing with unlimited precision decimal arithmetic. Integration with the JVM platform is tight, and all existing Java class libraries can be used unchanged and without special setup; at the same time, a Java programmer can opt to just use the Rexx class from the runtime package for improved string handling in Java syntax source programs. NetRexx is free to download from the Rexx Language Association. IBM announced the transfer of NetRexx 3.00 source code to the Rexx Language Association (RexxLA) on June 8, 2011."
  },
  "316": {
    "label": "Netwide Assembler",
    "wikipedia_pageid": 60647,
    "inception": { "time": "+1996-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "The **Netwide Assembler** (**NASM**) is an assembler and disassembler for the Intel x86 architecture. It can be used to write 16-bit, 32-bit (IA-32) and 64-bit (x86-64) programs. NASM is considered to be one of the most popular assemblers for Linux. NASM was originally written by Simon Tatham with assistance from Julian Hall. As of 2016, it is maintained by a small team led by H. Peter Anvin. It is open-source software released under the terms of a simplified (2-clause) BSD license."
  },
  "317": {
    "label": "newLISP",
    "wikipedia_pageid": 1964813,
    "inception": { "time": "+1991-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 14, 21],
    "typing": [10],
    "description": "**newLISP** is a scripting language which is a dialect of the Lisp family of programming languages. It was designed and developed by Lutz Mueller. newLISP is free and open-source software released under the GNU General Public License, version 3 or later."
  },
  "318": {
    "label": "Newspeak",
    "wikipedia_pageid": 24308364,
    "inception": { "time": "+2006-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 21],
    "typing": [10],
    "description": "**Newspeak** is a programming language and platform in the tradition of Smalltalk and Self being developed by a team led by Gilad Bracha. The platform includes an IDE, a GUI library, and standard libraries. Starting in 2006, Cadence Design Systems funded its development and employed the main contributors, but ceased funding in January 2009. Newspeak is a class based language. Classes may be nested, as in BETA. This is one of the key differences between Newspeak and Smalltalk. All names in Newspeak are late-bound, and are interpreted as message sends, as in Self. Newspeak is distinguished by its unusual approach to modularity. The language has no global namespace. Top level classes act as module declarations. Module declarations are first class values (i.e., they may be stored in variables, passed as parameters, returned from methods, etc.) and are stateless."
  },
  "319": {
    "label": "NewtonScript",
    "wikipedia_pageid": 60545,
    "inception": { "time": "+1993-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 14],
    "typing": [10],
    "description": "**NewtonScript** is a prototype-based programming language created to write programs for the Newton platform. It is heavily influenced by the Self programming language, but modified to be more suited to needs of mobile and embedded devices."
  },
  "320": {
    "label": "Nial",
    "wikipedia_pageid": 21571,
    "inception": { "time": "+1981-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [20],
    "typing": [10],
    "description": "**Nial** (from \"Nested Interactive Array Language\") is a high-level array programming language developed from about 1981 by Mike Jenkins of Queen's University, Kingston, Ontario, Canada. Jenkins co-created the Jenkins–Traub algorithm. Nial combines a functional programming notation for arrays based on an array theory developed by Trenchard More with structured programming concepts for numeric, character and symbolic data. It is most often used for prototyping and artificial intelligence."
  },
  "321": {
    "label": "Nickle",
    "wikipedia_pageid": 4072208,
    "inception": { "time": "+2001-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**Nickle** is a numeric oriented programming language by Keith Packard and Bart Massey. Originally used for desktop calculation, it has since expanded for prototyping of complicated algorithms."
  },
  "322": {
    "label": "Nim",
    "wikipedia_pageid": 45413679,
    "inception": { "time": "+2008-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 21, 6, 16],
    "typing": [1, 12, 6, 11],
    "description": "**Nim** is an imperative, general-purpose, multi-paradigm, statically typed, systems, compiled programming language designed and developed by Andreas Rumpf. It is designed to be \"efficient, expressive, and elegant\", supporting metaprogramming, functional, message passing, procedural, and object-oriented programming styles by providing several features such as compile time code generation, algebraic data types, a foreign function interface (FFI) with C, C++, Objective-C, and JavaScript, and supporting compiling to those same languages."
  },
  "323": {
    "label": "Not Quite C",
    "wikipedia_pageid": 969174,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**Not Quite C** (**NQC**) is a programming language, application programming interface (API), and native bytecode compiler toolkit for the Lego Mindstorms, Cybermaster and LEGO Spybotics systems. It is based primarily on the C language but has specific limitations, such as the maximum number of subroutines and variables allowed, which differ depending on the version of firmware the RCX has. The language was invented by David Baum. He has released two books on the subject."
  },
  "324": {
    "label": "Not eXactly C",
    "wikipedia_pageid": 16826148,
    "inception": { "time": "+2006-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**Not eXactly C**, or **NXC**, is a high-level programming language for the Lego Mindstorms NXT designed by John Hansen in 2006. NXC, which is short for Not eXactly C, is based on Next Byte Codes, an assembly language. NXC has a syntax like C. The IDE for NXC is the Bricx Command Center. The NXC compiler is available under the Mozilla Public License. A sample code is as shown below:"
  },
  "325": {
    "label": "Nu",
    "wikipedia_pageid": 17151577,
    "inception": { "time": "+2007-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 21, 6, 36],
    "typing": [10],
    "description": "**Nu** is an interpreted object-oriented programming language, with a Lisp- like syntax, created by Tim Burks as an alternative scripting language to program OS X through its Cocoa application programming interface (API). Implementations also exist for iPhone and Linux. The language was first announced at C4, a conference for indie Mac developers held in August 2007."
  },
  "326": {
    "label": "o:XML",
    "wikipedia_pageid": 851815,
    "inception": null,
    "paradigm": [6],
    "typing": [10],
    "description": "**o:XML** is an open source, dynamically typed, general-purpose object- oriented programming language based on XML-syntax. It has threads, exception handling, regular expressions and namespaces. Additionally o:XML has an expression language very similar to XPath that allows functions to be invoked on nodes and node sets."
  },
  "327": {
    "label": "OCaml",
    "wikipedia_pageid": 39652,
    "inception": { "time": "+1996-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 18, 3, 21],
    "typing": [1, 12, 6, 11],
    "description": "**OCaml** (_oh- KAM-əl_, formerly **Objective Caml**) is a general-purpose, multi-paradigm programming language which extends the Caml dialect of ML with object-oriented features. OCaml was created in 1996 by Xavier Leroy, Jérôme Vouillon, Damien Doligez, Didier Rémy, Ascánder Suárez, and others. The OCaml toolchain includes an interactive top-level interpreter, a bytecode compiler, an optimizing native code compiler, a reversible debugger, and a package manager (OPAM). OCaml was initially developed in the context of automated theorem proving, and has an outsize presence in static analysis and formal methods software. Beyond these areas, it has found serious use in systems programming, web development, and financial engineering, among other application domains. The acronym _CAML_ originally stood for _Categorical Abstract Machine Language_, but OCaml omits this abstract machine. OCaml is a free and open- source software project managed and principally maintained by the French Institute for Research in Computer Science and Automation (INRIA). In the early 2000s, elements from OCaml were adopted by many languages, notably F# and Scala."
  },
  "328": {
    "label": "OPS5",
    "wikipedia_pageid": 475829,
    "inception": null,
    "paradigm": [21],
    "typing": [],
    "description": "**OPS5** is a rule-based or production system computer language, notable as the first such language to be used in a successful expert system, the R1/XCON system used to configure VAX computers. The OPS (said to be short for \"Official Production System\") family was developed in the late 1970s by Charles Forgy while at Carnegie Mellon University. Allen Newell's research group in artificial intelligence had been working on production systems for some time, but Forgy's implementation, based on his Rete algorithm, was especially efficient, sufficiently so that it was possible to scale up to larger problems involving hundreds or thousands of rules. OPS5 uses a forward chaining inference engine; programs execute by scanning \"working memory elements\" (which are vaguely object-like, with classes and attributes) looking for matches with the rules in \"production memory\". Rules have actions that may modify or remove the matched element, create new ones, perform side effects such as output, and so forth. Execution continues until no more matches can be found. In this sense, OPS5 is an execution engine for a Petri net extended with inhibitor arcs. The OPS5 forward chaining process makes it extremely parallelizeable during the matching phase, and several automatic parallelizing compilers were created. **OPS4** was an early version, while **OPS83** came later. The first implementation of OPS5 was written in Lisp, and later rewritten in BLISS for speed. **DEC OPS5** is an extended implementation of the OPS5 language definition, developed for use with the VMS, RISC ULTRIX, and DEC OSF/1 operating systems."
  },
  "329": {
    "label": "Oak",
    "wikipedia_pageid": 16840885,
    "inception": { "time": "+1989-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [],
    "description": "**Oak** is a discontinued programming language created by James Gosling in 1989, initially for Sun Microsystems' set-top box project. The language later evolved to become Java. The name _Oak_ was used by Gosling after an oak tree that stood outside his office."
  },
  "330": {
    "label": "Oberon",
    "wikipedia_pageid": 22496,
    "inception": { "time": "+1987-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [18, 2, 3, 6, 36],
    "typing": [10, 1, 11],
    "description": "**Oberon** is a general-purpose programming language first published in 1987 by Niklaus Wirth and the latest member of the Wirthian family of ALGOL-like languages (Euler, ALGOL W, Pascal, Modula, and Modula-2). Oberon was the result of a concentrated effort to increase the power of Modula-2, the direct successor of Pascal, and simultaneously to reduce its complexity. Its principal new feature is the concept of type extension of record types. It permits constructing new data types on the basis of existing ones and to relate them, deviating from the dogma of strictly static typing of data. Type extension is Wirth's way of inheritance reflecting the viewpoint of the parent site. Oberon was developed as part of the implementation of an operating system, also named Oberon at ETH Zurich in Switzerland. The name is from the moon of the planet Uranus, named Oberon. Oberon is still maintained by Wirth and the latest Project Oberon compiler update is dated 6 March 2020."
  },
  "331": {
    "label": "Object Lisp",
    "wikipedia_pageid": 1064021,
    "inception": null,
    "paradigm": [6, 14],
    "typing": [],
    "description": "**Object Lisp** was a computer programming language, a dialect of the Lisp language. It was an object-oriented extension for the Lisp dialect Lisp Machine Lisp, designed by Lisp Machines, Inc. Object Lisp was also an early example of prototype-based programming. It was seen as a competitor to other object-oriented extensions to Lisp at around the same time such as Flavors, in use by Symbolics, Common Objects developed by Hewlett-Packard, and CommonLoops, in use by Xerox. Object Lisp was also used in early versions of Macintosh Common Lisp. There, the user interface toolkit was written using Object Lisp."
  },
  "332": {
    "label": "Object Pascal",
    "wikipedia_pageid": 630175,
    "inception": { "time": "+1986-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [12, 2, 3, 6, 26, 36],
    "typing": [10, 1, 11],
    "description": "**Object Pascal** is an extension to the programming language Pascal that provides object-oriented programming (OOP) features such as classes and methods. The language was originally developed by Apple Computer as _Clascal_ for the Lisa Workshop development system. As Lisa gave way to Macintosh, Apple collaborated with Niklaus Wirth, the author of Pascal, to develop an officially standardized version of Clascal. This was renamed Object Pascal. Through the mid-1980s, Object Pascal was the main programming language for early versions of the MacApp application framework. The language lost its place as the main development language on the Mac in 1991 with the release of the C++-based MacApp 3.0. Official support ended in 1996. Symantec also developed a compiler for Object Pascal for their Think Pascal product, which could compile programs much faster than Apple's own Macintosh Programmer's Workshop (MPW). Symantec then developed the Think Class Library (TCL), based on MacApp concepts, which could be called from both Object Pascal and THINK C. The Think suite largely displaced MPW as the main development platform on the Mac in the late 1980s. Symantec ported Object Pascal to the PC, and developed a similar object framework on that platform. In contrast to TCL, which eventually migrated to C++, the PC libraries remained mainly based on Pascal. Borland added support for object-oriented programming to Turbo Pascal 5.5, which would eventually become the basis for the Object Pascal dialect used in Delphi. Delphi remained mainstream for business applications on the PC into the early 2000s, and was partly displaced in the 2000s with the introduction of the .NET Framework."
  },
  "333": {
    "label": "Object REXX",
    "wikipedia_pageid": 1353817,
    "inception": { "time": "+1988-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [],
    "description": "The **Object REXX** programming language is an object-oriented scripting language initially produced by IBM for the operating system OS/2 and later for Microsoft Windows. It is a follow-on to and a significant extension of the \"Classic Rexx\" language originally created for the Conversational Monitor System (CMS) component of the operating system VM/SP and later ported to Multiple Virtual Storage (MVS), OS/2 and PC DOS. The OS/2 version of IBM Object REXX includes classes to support IBM System Object Model (SOM) and Workplace Shell (WPS). It is also included in ArcaOS. On October 12, 2004, IBM released Object REXX as free and open-source software, giving rise to _Open Object Rexx_ (**ooREXX**), now available for various operating systems: Linux, Solaris, Windows. This implementation includes a Windows Script Host (WSH) Scripting Engine for Rexx. The released sources however didn't include the classes for SOM and Workplace Shell (WPS) support. Object REXX supports multiple inheritance via the use of mixin classes."
  },
  "334": {
    "label": "Objective-C",
    "wikipedia_pageid": 39809523,
    "inception": { "time": "+1984-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 0, 9],
    "typing": [2, 10, 11],
    "description": "**Objective-C** is a general-purpose, object-oriented programming language that adds Smalltalk-style messaging to the C programming language. Originally developed by Brad Cox and Tom Love in the early 1980s, it was selected by NeXT for its NeXTSTEP operating system. Objective-C was the standard programming language supported by Apple for developing macOS (which descended from NeXTSTEP) and iOS applications using their respective application programming interfaces (APIs), Cocoa and Cocoa Touch, until the introduction of Swift in 2014. Objective-C programs developed for non-Apple operating systems or that are not dependent on Apple’s APIs may also be compiled for any platform supported by GNU GCC or LLVM/Clang. Objective-C source code 'implementation' program files usually have .m filename extensions, while Objective-C 'header/interface' files have .h extensions, the same as C header files. Objective-C++ files are denoted with a .mm file extension."
  },
  "335": {
    "label": "Objective-J",
    "wikipedia_pageid": 19176983,
    "inception": { "time": "+2008-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 3, 9, 21],
    "typing": [2, 13, 10],
    "description": "**Objective-J** is a programming language developed as part of the Cappuccino web development framework. Its syntax is nearly identical to the Objective-C syntax and it shares with JavaScript the same relationship that Objective-C has with the C programming language: that of being a strict, but small, superset; adding traditional inheritance and Smalltalk/Objective-C style dynamic dispatch. Pure JavaScript, being a prototype-based language, already has a notion of object orientation and inheritance, but Objective-J adds the use of class-based programming to JavaScript. Programs written in Objective-J need to be preprocessed before being run by a web browser's JavaScript virtual machine. This step can occur in the web browser at runtime or by a compiler which translates Objective-J programs into pure JavaScript code. The Objective-J compiler is written in JavaScript; consequently, deploying Objective-J programs does not require a web browser plug-in. Objective-J can be compiled and run on Node.js."
  },
  "336": {
    "label": "Obliq",
    "wikipedia_pageid": 602578,
    "inception": { "time": "+1993-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [18, 3, 6, 14, 7, 36],
    "typing": [10, 1],
    "description": "**Obliq** is an interpreted, object-oriented programming language designed to make distributed, and locally multithreaded, computing simpler and easier to program, while providing program safety and an implicit type system. The interpreter is written in Modula-3, and provides Obliq with full access to Modula-3's network objects abilities. A type inference algorithm for record concatenation, subtyping, and recursive types has been developed for Obliq. Further, it has been proved to be NP-complete and its lowest complexity to be _Ο_ (_n_ 3) or if under other modeling up to certain conditions down to _Ο_ (_n_ 2) and its best known implementation runs in _Ο_ (_n_ 5). Obliq's syntax is very similar to Modula-3, the biggest difference being that Obliq has no need of explicit typed variables (i.e., a variable can hold any data type allowed by the type checker and if does not accepts one, i.e., a given expression execution error will display) although explicit type declarations are allowed and ignored by the interpreter. The basic data types in the language include booleans, integers, reals, characters, strings, and arrays. Obliq supports the usual set of sequential control structures (conditional, iteration, and exception handling forms), and special control forms for concurrency (mutexes and guarded statements). Further, Obliq's objects can be cloned and safely copied remotely by any machine in a distributed network object and it can be done safely and transparently. Obliq's large standard library provides strong support for mathematical operations, input/output (I/O), persistence, thread control, graphics, and animation. Distributed computing is object-based: objects hold a state, which is local to one process. Scope of objects and other variables is purely lexical. Objects can call methods of other objects, even if those objects are on another machine on the network. Obliq objects are simply collections of named fields (similar to slots in Self and Smalltalk), and support inheritance by delegation (like Self). The common uses of Obliq involve programming over networks, 3D animation, and distributed computing, as occurs over a local area network (LAN) such as Ethernet. Obliq is included free with the Digital Equipment Corporation (DEC) Modula-3 distribution, but other free versions exist elsewhere including precompiled binaries for several operating systems."
  },
  "337": {
    "label": "occam",
    "wikipedia_pageid": 22660,
    "inception": { "time": "+1983-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 16],
    "typing": [],
    "description": "**occam** is a programming language which is concurrent and builds on the communicating sequential processes (CSP) process algebra, and shares many of its features. It is named after philosopher William of Ockham after whom Occam's razor is named. occam is an imperative procedural language (such as Pascal). It was developed by David May and others at Inmos (trademark INMOS), advised by Tony Hoare, as the native programming language for their transputer microprocessors, but implementations for other platforms are available. The most widely known version is occam 2; its programming manual was written by Steven Ericsson- Zenith and others at Inmos."
  },
  "338": {
    "label": "occam-π",
    "wikipedia_pageid": 2079775,
    "inception": { "time": "+2006-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 16],
    "typing": [],
    "description": "In computer science,**occam-π** (or **occam-pi**) is the name of a variant of the programming language occam developed by the Kent Retargetable occam Compiler (KRoC) team at the University of Kent. The name reflects the introduction of elements of π-calculus (pi-calculus) into occam, especially concepts involving mobile agents (processes) and data. The language contains several extensions to occam 2.1, including:   * Nested protocols   * Run-time process creation   * Mobile channels, data, and processes   * Recursion   * Protocol inheritance   * Array constructors   * Extended rendezvous"
  },
  "339": {
    "label": "OmniMark",
    "wikipedia_pageid": 3375679,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**OmniMark** is a fourth-generation programming language used mostly in the publishing industry. It is currently a proprietary software product of Stilo International. As of September 2018 the most recent release of OmniMark was 10.1.2, dated April 2016."
  },
  "340": {
    "label": "Opa",
    "wikipedia_pageid": 32976878,
    "inception": { "time": "+2011-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3, 21],
    "typing": [1, 6, 11],
    "description": "**Opa** is an open-source programming language for developing scalable web applications. It can be used for both client-side and server-side scripting, where complete programs are written in Opa and subsequently compiled to Node.js on the server and JavaScript on the client, with the compiler automating all communication between the two. Opa implements strong, static typing, which can be helpful in protecting against security issues such as SQL injections and cross-site scripting attacks. The language was first officially presented at the OWASP conference in 2010, and the source code was released on GitHub in June 2011, under a GNU Affero General Public License. Later, the license changed to the MIT license for the framework part (library) and AGPL for the compiler so that applications written in Opa can be released under any license, proprietary or open source."
  },
  "341": {
    "label": "Opal",
    "wikipedia_pageid": 1936835,
    "inception": null,
    "paradigm": [21],
    "typing": [],
    "description": "**OPAL** (**OP** timized **A** pplicative **L** anguage) is a functional programming language first developed at the Technical University of Berlin."
  },
  "342": {
    "label": "Open Programming Language",
    "wikipedia_pageid": 832032,
    "inception": { "time": "+1984-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3, 36],
    "typing": [],
    "description": "**Open Programming Language** (**OPL**) is an embedded programming language for portable devices that run the Symbian Operating System."
  },
  "343": {
    "label": "OpenCL",
    "wikipedia_pageid": 17861917,
    "inception": { "time": "+2009-08-28T00:00:00Z", "precision": 11 },
    "paradigm": [6, 3, 26, 36],
    "typing": [11, 14, 4, 2],
    "description": "**OpenCL** (**Open Computing Language**) is a framework for writing programs that execute across heterogeneous platforms consisting of central processing units (CPUs), graphics processing units (GPUs), digital signal processors (DSPs), field-programmable gate arrays (FPGAs) and other processors or hardware accelerators. OpenCL specifies programming languages (based on C99, C++14 and C++17) for programming these devices and application programming interfaces (APIs) to control the platform and execute programs on the compute devices. OpenCL provides a standard interface for parallel computing using task- and data-based parallelism. OpenCL is an open standard maintained by the non-profit technology consortium Khronos Group. Conformant implementations are available from Altera, AMD, Apple (OpenCL along with OpenGL is deprecated for Apple hardware, in favor of Metal 2), ARM, Creative, IBM, Imagination, Intel, Nvidia, Qualcomm, Samsung, Vivante, Xilinx, and ZiiLABS."
  },
  "344": {
    "label": "OpenEdge Advanced Business Language",
    "wikipedia_pageid": 1071357,
    "inception": null,
    "paradigm": [6],
    "typing": [],
    "description": "**OpenEdge Advanced Business Language**, or **OpenEdge ABL** for short, is a business application development language created and maintained by Progress Software Corporation (PSC). The language, typically classified as a fourth- generation programming language, uses an English-like syntax to simplify software development. The language was called **PROGRESS** or **Progress 4GL** up until version 9, but in 2006 PSC changed the name to OpenEdge Advanced Business Language (OpenEdge ABL) in order to overcome a presumed industry perception that 4GLs were less capable than other languages. A subset of the language, called _SpeedScript_, is used in the development of web applications. OpenEdge ABL helps developers to develop applications optionally using its own integrated relational database and programming tool. These applications are portable across computing systems and allow access to various popular data sources without having to learn the underlying data access methods. This means that the end-user of these products can be unaware of the underlying architecture. By combining a fourth generation language and relational database, OpenEdge ABL allows the use of the Rapid Application Development (RAD) model for developing software. A programmer and even end users can do rapid prototyping using the integrated and GUI tools of the development environment. OpenEdge can be used for:   * Microsoft Windows GUI (Graphical User Interface)   * WWW Programming (UNIX and Windows)   * CHUI (CHaracter User Interface) (UNIX and Windows)   * JSON and XML appserver programming (UNIX and Windows)   * as well background process programming (UNIX and Windows)."
  },
  "345": {
    "label": "OpenVera",
    "wikipedia_pageid": 7841593,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**OpenVera** was a hardware verification language developed by System Science and acquired by Synopsys."
  },
  "346": {
    "label": "OptimJ",
    "wikipedia_pageid": 28952622,
    "inception": { "time": "+2006-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [],
    "description": "**OptimJ** is an extension for Java with language support for writing optimization models and abstractions for bulk data processing. The extensions and the proprietary product implementing the extensions were developed by Ateji which went out of business in September 2011. OptimJ aims at providing a clear and concise algebraic notation for optimization modeling, removing compatibility barriers between optimization modeling and application programming tools, and bringing software engineering techniques such as object-orientation and modern IDE support to optimization experts. OptimJ models are directly compatible with Java source code, existing Java libraries such as database access, Excel connection or graphical interfaces. OptimJ is compatible with development tools such as Eclipse, CVS, JUnit or JavaDoc. OptimJ is available free with the following solvers: lp_solve, glpk, LP or MPS file formats and also supports the following commercial solvers: Gurobi, MOSEK, IBM ILOG CPLEX Optimization Studio."
  },
  "347": {
    "label": "Orc",
    "wikipedia_pageid": 13345244,
    "inception": { "time": "+2004-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [16],
    "typing": [],
    "description": "**Orc** is a concurrent, nondeterministic computer programming language created by Jayadev Misra at the University of Texas at Austin. Orc provides uniform access to computational services, including distributed communication and data manipulation, through sites. Using four simple concurrency primitives, the programmer orchestrates the invocation of sites to achieve a goal, while managing timeouts, priorities, and failures."
  },
  "348": {
    "label": "Oriel",
    "wikipedia_pageid": 35116049,
    "inception": { "time": "+1991-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3],
    "typing": [],
    "description": "**Oriel** is a scripting language released with the _Power Tools_ series of instructional books written by the LeBlond Group. Described in its documentation as a \"graphics-based batch language\", it was originally designed for Microsoft Windows 3.0 and released with the book _Windows 3 Power Tools_ in 1991. However, versions of the language were also bundled with _Windows 3.1 Power Tools_ in 1992 and _Windows NT Power Tools_ in 1994. The suggested extension for an Oriel script file was ORL. Oriel was distributed with two executables: ORIEL.EXE, and MKRUNTIM.EXE. The former was the Oriel interpreter, which when invoked would prompt the user to choose a script file for execution. The latter gave the user the ability to create custom executables by bundling a script within a copy of the interpreter. In this way, an Oriel program could be distributed and run in the same way as any other Windows EXE. The language was named after the oriel style of bay window. A window of that style is depicted in the icon distributed with the runtime."
  },
  "349": {
    "label": "Orwell",
    "wikipedia_pageid": 15127684,
    "inception": { "time": "+1984-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [21],
    "typing": [],
    "description": "**Orwell** is a small, lazy-evaluation functional programming language implemented principally by Martin Raskovsky and first released in 1984 by Philip Wadler during his time as a Research Fellow in the Programming Research Group, part of the Oxford University Computing Laboratory. Developed as a free alternative to Miranda, it was a forerunner of Haskell and was one of the first programming languages to support list comprehensions and pattern matching. The name is a tribute to George Orwell's novel _Nineteen Eighty-Four_, the year in which the programming language was released. In the late 1980s and the 1990s, most of the computing practical assignments for undergraduates studying for a degree in _Mathematics and Computation_ at Oxford University were required to be completed using the language."
  },
  "350": {
    "label": "Oxygene",
    "wikipedia_pageid": 4249746,
    "inception": { "time": "+2005-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 7],
    "typing": [],
    "description": "**Oxygene** (formerly known as **Chrome**) is a programming language developed by RemObjects Software for Microsoft's Common Language Infrastructure, the Java Platform and Cocoa. Oxygene based on Delphi's Object Pascal, but also has influences from C#, Eiffel, Java, F# and other languages. Compared to the now deprecated Delphi.NET, Oxygene does not emphasize total backward compatibility, but is designed to be a \"reinvention\" of the language, be a good citizen on the managed development platforms, and leverage all the features and technologies provided by the .NET and Java runtimes. Oxygene is a commercial product and offers full integration into Microsoft's Visual Studio IDE on Windows, as well as its own IDE called Fire for use on macOS. The command-line compiler is available for free. Oxygene is one of six languages supported by the underlying Elements Compiler toolchain, next to C#, Swift, Java, Go and Mercury (based on Visaul Basic.NET). From 2008 to 2012, RemObjects Software licensed its compiler and IDE technology to Embarcadero to be used in their Embarcadero Prism product. Starting in the Fall of 2011, Oxygene became available in two separate editions, with the second edition adding support for the Java and Android runtimes. Starting with the release of XE4, Embarcadero Prism is no longer part of the RAD Studio SKU. Numerous support and upgrade paths for Prism customers exist to migrate to Oxygene. As of 2016, there is only one edition of Oxygene, which allows development on Windows or macOS, and which can create executables for Windows, Linux, WebAssembly .NET, iOS, Android, Java and macOS."
  },
  "351": {
    "label": "Oz",
    "wikipedia_pageid": 256916,
    "inception": { "time": "+1991-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3, 5, 21, 6, 14, 16],
    "typing": [10],
    "description": "**Oz** is a multiparadigm programming language, developed in the Programming Systems Lab at Université catholique de Louvain, for programming language education. It has a canonical textbook: Concepts, Techniques, and Models of Computer Programming. Oz was first designed by Gert Smolka and his students in 1991. In 1996, development of Oz continued in cooperation with the research group of Seif Haridi and Peter Van Roy at the Swedish Institute of Computer Science. Since 1999, Oz has been continually developed by an international group, the Mozart Consortium, which originally consisted of Saarland University, the Swedish Institute of Computer Science, and the Université catholique de Louvain. In 2005, the responsibility for managing Mozart development was transferred to a core group, the Mozart Board, with the express purpose of opening Mozart development to a larger community. The Mozart Programming System is the primary implementation of Oz. It is released with an open source license by the Mozart Consortium. Mozart has been ported to Unix, FreeBSD, Linux, Windows, and macOS."
  },
  "352": {
    "label": "P",
    "wikipedia_pageid": 53163248,
    "inception": { "time": "+2012-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**P** is a programming language for asynchronous event-driven programming and the IoT that was developed by Microsoft and University of California, Berkeley. P enables programmers to specify systems consisting of a collection of state machines that communicate asynchronously in terms of events. Code can be run on Microsoft Windows and Windows Phone, and is now open source licensed under MIT License and available on GitHub."
  },
  "353": {
    "label": "P4",
    "wikipedia_pageid": 46347117,
    "inception": { "time": "+2013-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3],
    "typing": [],
    "description": "**P4** is a programming language for controlling packet forwarding planes in networking devices, such as routers and switches. In contrast to a general purpose language such as C or Python, P4 is a domain-specific language with a number of constructs optimized for network data forwarding. P4 is distributed as open-source, permissively licensed code, and is maintained by the P4 Language Consortium, a not-for-profit organization hosted by the Open Networking Foundation."
  },
  "354": {
    "label": "PARI/GP",
    "wikipedia_pageid": 24383128,
    "inception": { "time": "+1985-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**PARI/GP** is a computer algebra system with the main aim of facilitating number theory computations. Versions 2.1.0 and higher are distributed under the GNU General Public License. It runs on most common operating systems."
  },
  "355": {
    "label": "PCASTL",
    "wikipedia_pageid": 17955097,
    "inception": { "time": "+2008-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 9],
    "typing": [],
    "description": "The **PCASTL** (an acronym for _by Parent and Childset Accessible Syntax Tree Language_) is an interpreted high-level programming language. It was created in 2008 by Philippe Choquette. The PCASTL is designed to ease the writing of self-modifying code. The language has reserved words **parent** and **childset** to access the nodes of the syntax tree of the currently written code."
  },
  "356": {
    "label": "PEARL",
    "wikipedia_pageid": 2603123,
    "inception": { "time": "+1977-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2],
    "typing": [],
    "description": "**PEARL**, or **Process and experiment automation realtime language**, is a computer programming language designed for multitasking and real-time programming. Being a high-level language, it is fairly cross-platform. Since 1977, the language has been going under several standardization steps by the Deutsches Institut für Normung. The current version is PEARL-90, which was standardized in 1998 as DIN 66253-2."
  },
  "357": {
    "label": "PHP",
    "wikipedia_pageid": 24131,
    "inception": { "time": "+1995-06-08T00:00:00Z", "precision": 11 },
    "paradigm": [2, 3, 21, 6, 9],
    "typing": [5, 10, 2],
    "description": "**PHP** is a general-purpose scripting language especially suited to web development. It was originally created by Danish-Canadian programmer Rasmus Lerdorf in 1994. The PHP reference implementation is now produced by The PHP Group. PHP originally stood for _Personal Home Page_, but it now stands for the recursive initialism _PHP: Hypertext Preprocessor_. PHP code is usually processed on a web server by a PHP interpreter implemented as a module, a daemon or as a Common Gateway Interface (CGI) executable. On a web server, the result of the interpreted and executed PHP code – which may be any type of data, such as generated HTML or binary image data – would form the whole or part of an HTTP response. Various web template systems, web content management systems, and web frameworks exist which can be employed to orchestrate or facilitate the generation of that response. Additionally, PHP can be used for many programming tasks outside of the web context, such as standalone graphical applications and robotic drone control. PHP code can also be directly executed from the command line. The standard PHP interpreter, powered by the Zend Engine, is free software released under the PHP License. PHP has been widely ported and can be deployed on most web servers on almost every operating system and platform, free of charge. The PHP language evolved without a written formal specification or standard until 2014, with the original implementation acting as the _de facto_ standard which other implementations aimed to follow. Since 2014, work has gone on to create a formal PHP specification. W3Techs reports that, as of April 2021,_\"PHP is used by 79.2% of all the websites whose server-side programming language we know.\"_"
  },
  "358": {
    "label": "PILOT",
    "wikipedia_pageid": 57399,
    "inception": { "time": "+1968-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3],
    "typing": [],
    "description": "**Programmed Inquiry, Learning, or Teaching** (**PILOT**) is a simple high- level programming language developed in the 1960s. Like its younger sibling LOGO, it was an early foray into the technology of computer-assisted instruction. PILOT is an imperative language similar in structure to BASIC and FORTRAN in its basic layout and structure. Its keywords are single characters, `T` for \"type\" to print text, or `A` for \"accept\", to input values from the user."
  },
  "359": {
    "label": "PL-11",
    "wikipedia_pageid": 507366,
    "inception": { "time": "+1971-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2],
    "typing": [],
    "description": "**PL-11** is a high-level machine-oriented programming language for the PDP-11, developed by R.D. Russell of CERN in 1971. Written in Fortran IV, it is similar to PL360 and is cross-compiled on other machines. PL-11 was originally developed as part of the Omega project, a particle physics facility operational at CERN (Geneva, Switzerland) during the 1970s. The first version was written for the CII 10070, a clone of the XDS Sigma 7 built in France. Towards the end of the 1970s it was ported to the IBM 370/168, then part of CERN's computer centre. A report describing the language is available from CERN."
  },
  "360": {
    "label": "PL/0",
    "wikipedia_pageid": 507221,
    "inception": { "time": "+1975-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 36],
    "typing": [],
    "description": "**PL/0** is a programming language, intended as an educational programming language, that is similar to but much simpler than Pascal, a general-purpose programming language. It serves as an example of how to construct a compiler. It was originally introduced in the book,_Algorithms + Data Structures = Programs_, by Niklaus Wirth in 1976. It features quite limited language constructs: there are no real numbers, very few basic arithmetic operations and no control-flow constructs other than \"if\" and \"while\" blocks. While these limitations make writing real applications in this language impractical, it helps the compiler remain compact and simple."
  },
  "361": {
    "label": "PL/C",
    "wikipedia_pageid": 309357,
    "inception": { "time": "+1973-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 36],
    "typing": [1],
    "description": "**PL/C** is an instructional dialect of the PL/I computer programming language, developed at Cornell University in the 1970s."
  },
  "362": {
    "label": "PL/I",
    "wikipedia_pageid": 23708,
    "inception": { "time": "+1964-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 16, 36],
    "typing": [1],
    "description": "**PL/I** (**Programming Language One**, pronounced  and sometimes written **PL/1**) is a procedural, imperative computer programming language developed and published by IBM. It is designed for scientific, engineering, business and system programming. It has been used by academic, commercial and industrial organizations since it was introduced in the 1960s, and is still used. PL/I's main domains are data processing, numerical computation, scientific computing, and system programming. It supports recursion, structured programming, linked data structure handling, fixed-point, floating-point, complex, character string handling, and bit string handling. The language syntax is English-like and suited for describing complex data formats with a wide set of functions available to verify and manipulate them."
  },
  "363": {
    "label": "PL/M",
    "wikipedia_pageid": 543057,
    "inception": { "time": "+1973-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 36],
    "typing": [],
    "description": "The **PL/M programming language** (an acronym of _**P** rogramming **L** anguage for **M** icrocomputers_) is a high-level language conceived and developed by Gary Kildall in 1973 for Hank Smith at Intel for its microprocessors."
  },
  "364": {
    "label": "PL/P",
    "wikipedia_pageid": 1960521,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "The **PL/P programming language** (an acronym of _**P** rogramming **L** anguage for **P** rime (computers)_) is a mid-level programming language developed by Prime Computer to serve as their second primary system programming language after Fortran IV. PL/P was a subset of PL/I. Additions to the PRIMOS operating system for Prime 50 Series computers were written mostly in PL/P in later years. Certain PRIMOS modules written in Fortran IV during PRIMOS's early years were rewritten in PL/P. PL/P was the most widespread compiled programming language used for commercial PRIMOS applications, outpacing the use of the Prime C compiler, the CPL (PRIMOS) scripting language, and the Fortran IV compiler in commercial applications."
  },
  "365": {
    "label": "IBM PL/S",
    "wikipedia_pageid": 1033828,
    "inception": { "time": "+1960-01-01T00:00:00Z", "precision": 8 },
    "paradigm": [],
    "typing": [],
    "description": "**PL/S**, short for **Programming Language/Systems**, is a \"machine- oriented\" programming language based on PL/I. It was developed by IBM in the late 1960s, under the name **Basic Systems Language** (**BSL**), as a replacement for assembly language on internal software projects; it included support for inline assembly and explicit control over register usage. Early projects using PL/S were the batch utility, IEHMOVE, and the Time Sharing Option of MVT, TSO. By the 1970s, IBM was rewriting its flagship operating system in PL/S. Although users frequently asked IBM to release PL/S for their use, IBM refused saying that the product was proprietary. Their concern was that open PL/S would give competitors, Amdahl, Itel (National Advanced Systems), Storage Technology Corporation, Trilogy Systems, Magnuson Computer Systems, Fujitsu, Hitachi, and other PCM vendors a competitive advantage. However, even though they refused to make available a compiler, they shipped the PL/S source code to large parts of the OS to customers, many of whom thus became familiar with reading it. Closed PL/S meant that only IBM could easily modify and enhance the operating system. PL/S was succeeded by PL/S II, PL/S III and PL/AS (Programming Language/Advanced Systems), and then PL/X (Programming Language/Cross Systems). PL/DS (Programming Language/Distributed Systems) was a closely related language used to develop the DPPX operating system, and PL/DS II was a port of the S/370 architecture for the DPPX/370 port. As the market for computers and software shifted away from IBM mainframes and MVS, IBM recanted and has offered the current versions of PL/S to select customers (ISVs through the Developer Partner program.)"
  },
  "366": {
    "label": "PL/SQL",
    "wikipedia_pageid": 33862363,
    "inception": { "time": "+1992-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2],
    "typing": [],
    "description": "**PL/SQL** (**Procedural Language for SQL)** is Oracle Corporation's procedural extension for SQL and the Oracle relational database. PL/SQL is available in Oracle Database (since version 6 - stored PL/SQL procedures/functions/packages/triggers since version 7), Times Ten in-memory database (since version 11.2.1), and IBM DB 2 (since version 9.7). Oracle Corporation usually extends PL/SQL functionality with each successive release of the Oracle Database. PL/SQL includes procedural language elements such as conditions and loops. It allows declaration of constants and variables, procedures and functions, types and variables of those types, and triggers. It can handle exceptions (run-time errors). Arrays are supported involving the use of PL/SQL collections. Implementations from version 8 of Oracle Database onwards have included features associated with object-orientation. One can create PL/SQL units such as procedures, functions, packages, types, and triggers, which are stored in the database for reuse by applications that use any of the Oracle Database programmatic interfaces. Historically, the first public version of PL/SQL definition was in 1995, and the Oracle's inception year ~1992. It implements the ISO SQL/PSM standard."
  },
  "367": {
    "label": "PL360",
    "wikipedia_pageid": 15774460,
    "inception": { "time": "+1966-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 36],
    "typing": [1, 11],
    "description": "**PL360** (or PL/360) is a system programming language designed by Niklaus Wirth and written by Wirth, Joseph W. Wells Jr., and Edwin Satterthwaite Jr. for the IBM System/360 computer at Stanford University. A description of PL360 was published in early 1968, although the implementation was probably completed before Wirth left Stanford in 1967."
  },
  "368": {
    "label": "PLANC",
    "wikipedia_pageid": 5081365,
    "inception": null,
    "paradigm": [2],
    "typing": [],
    "description": "**PLANC** (pronounced as \"plank\") is a high level computer programming language. The acronym stands for _Programming LAnguage for Nd Computers_. Compilers were developed by Norsk Data for several architectures, including the Motorola 68000, 88000, x86, and the Norsk Data NORD-10 minicomputer architecture and ND-500 superminicomputer. The language was designed to be platform independent. It was mainly used internally at Norsk Data for writing high level systems software such as the upper parts of the operating systems and compilers."
  },
  "369": {
    "label": "PLEX",
    "wikipedia_pageid": 21866469,
    "inception": { "time": "+1970-01-01T00:00:00Z", "precision": 8 },
    "paradigm": [2, 3, 16],
    "typing": [],
    "description": "**PLEX** (Programming Language for EXchanges) is a special-purpose, concurrent, real-time programming language. The proprietary PLEX language is closely tied to the architecture of Ericsson's AXE telephone exchanges which it was designed to control. PLEX was developed by Göran Hemdahl at Ericsson in the 1970s, and it has been continuously evolving since then. PLEX was described in 2008 as \"a cross between Fortran and a macro assembler.\" The language has two variants: _Plex-C_ used for the AXE Central Processor (CP) and _Plex-M_ used for Extension Module Regional Processors (EMRP). Ericsson started a project in the mid-1980s to create a successor language which resulted in Erlang. According to co-creator Joe Armstrong, \"Erlang was heavily influenced by PLEX and the AXE design.\" Erlang did not replace PLEX, but was used alongside it."
  },
  "370": {
    "label": "PLEXIL",
    "wikipedia_pageid": 19189627,
    "inception": { "time": "+2005-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [4, 11],
    "description": "PLEXIL (**Pl** an **Ex** ecution **I** nterchange **L** anguage) is an open source technology for automation, created and currently in development by NASA."
  },
  "371": {
    "label": "POP-11",
    "wikipedia_pageid": 562827,
    "inception": null,
    "paradigm": [2, 9, 13],
    "typing": [],
    "description": "**POP-11** is a reflective, incrementally compiled programming language with many of the features of an interpreted language. It is the core language of the Poplog programming environment developed originally by the University of Sussex, and recently in the School of Computer Science at the University of Birmingham, which hosts the main Poplog website. Core source files are also available on GitHub. POP-11 is an evolution of the language POP-2, developed in Edinburgh University, and features an open stack model (like Forth, among others). It is mainly procedural, but supports declarative language constructs, including a pattern matcher, and is mostly used for research and teaching in artificial intelligence, although it has features sufficient for many other classes of problems. It is often used to introduce symbolic programming techniques to programmers of more conventional languages like Pascal, who find POP syntax more familiar than that of Lisp. One of POP-11's features is that it supports first-class functions. POP-11 is the core language of the Poplog system. The availability of the compiler and compiler subroutines at run-time (a requirement for incremental compilation) gives it the ability to support a far wider range of extensions (including run-time extensions, such as adding new data-types) than would be possible using only a macro facility. This made it possible for (optional) incremental compilers to be added for Prolog, Common Lisp and Standard ML, which could be added as required to support either mixed language development or development in the second language without using any POP-11 constructs. This made it possible for Poplog to be used by teachers, researchers, and developers who were interested in only one of the languages. The most successful product developed in POP-11 was the Clementine Data-mining system, developed by ISL. After SPSS bought ISL they decided to port Clementine to C++ and Java, and eventually succeeded with great effort (and perhaps some loss of the flexibility provided by the use of an AI language). POP-11 was for a time available only as part of an expensive commercial package (Poplog), but since about 1999 it has been freely available as part of the Open Source version of Poplog, including various additional packages and teaching libraries. An online version of ELIZA using POP-11 is available at Birmingham. At the University of Sussex, David Young used POP-11 in combination with C and Fortran to develop a suite of teaching and interactive development tools for image processing and vision, and has made them available in the Popvision extension to Poplog."
  },
  "372": {
    "label": "POP-2",
    "wikipedia_pageid": 981616,
    "inception": { "time": "+1970-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [21],
    "typing": [],
    "description": "**POP-2** (also referred to as **POP2**) is a programming language developed around 1970 from the earlier language POP-1 (developed by Robin Popplestone in 1968, originally named COWSEL) by Robin Popplestone and Rod Burstall at the University of Edinburgh. It drew roots from many sources: the languages LISP and ALGOL 60, and theoretical ideas from Peter J. Landin. It used an incremental compiler, which gave it some of the flexibility of an interpreted language, including allowing new function definitions at run time and modification of function definitions while a program was running (both of which are features of dynamic compilation), without the overhead of an interpreted language."
  },
  "373": {
    "label": "PROIV",
    "wikipedia_pageid": 580197,
    "inception": { "time": "+1976-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [13],
    "typing": [],
    "description": "**PROIV** (/proʊ,fʊər/) is a low code development platform, developed and sold by NorthgateArinso, part of the Northgate Information Solutions Group. It has an active community of around 2500 developers and end-users worldwide, ranging from consultants to large multinationals, finance institutions, tax authorities, retailers, engineering companies, media operators and software houses. PROIV's usual application domain is database-centric business applications. PROIV has some similarities to languages such as ABAP, FOCUS and RPG. PROIV programs consist of declarative/non-procedural specifications that control the overall structure of the program and database access and that have an implicit sequence of execution (which PROIV programmers refer to as the timing cycle). Procedural subroutines can be added by the programmer; these are written in a 3GL-like language which PROIV calls \"Logic\". Note that in PROIV programs are referred to as \"functions\", which can be confusing as it differs from the more usual use of that term in programming languages."
  },
  "374": {
    "label": "PROMAL",
    "wikipedia_pageid": 1064169,
    "inception": { "time": "+1984-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 36],
    "typing": [],
    "description": "**PROMAL** (**PROgrammer's Microapplication Language**) is a structured programming language from Systems Management Associates for MS-DOS, Commodore 64, and Apple II. PROMAL features simple syntax, no line numbers, long variable names, functions and procedures with argument passing, real number type, arrays, strings, pointer, and a built-in I/O library. Like ABC and Python, indentation is part of the language syntax. The language uses a single-pass compiler to generate byte code that is interpreted when the program is run. Since the memory is very limited on these early home computers, the compiler can compile to/from disk and memory. The software package for C64 includes a full-screen editor and command shell. See also [Computer Language, Mar 1986, pp. 128–134]."
  },
  "375": {
    "label": "PROSE",
    "wikipedia_pageid": 40811716,
    "inception": { "time": "+1974-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "Author Joseph Thames, now deceased (2019), has left us with his latest version of PROSE, called FortranCalculus. It is freeware that can be downloaded from https://goal-driven.net/apps/fc-compiler.html . Joe's www.metacalculus.com website is no longer up. I have worked with Joe since ~1975, he will be missed! Thanks, Phil B Brubaker. \\--- PROSE was the mathematical 4GL virtual machine which established the holistic modeling paradigm known as Synthetic Calculus (AKA MetaCalculus). A successor to the SLANG/CUE simulation and optimization language developed at TRW Systems, it was introduced in 1974 on Control Data supercomputers. It was the first commercial language to employ automatic differentiation (AD), which was optimized to loop in the instruction-stack of the CDC 6600 CPU. Although PROSE was a rich block-structured procedural language, its focus was the blending of simultaneous-variable _mathematical systems_ such as:               implicit non-linear equations systems, ordinary differential-equations systems, and multidimensional optimization.        Each of these kinds of system models were distinct and had operator templates to automate and solve them, added to the procedural syntax. These automated system problems were considered \"holistic\" because their unknowns were simultaneous, and they could not be reduced in formulation to solve piecewise, or by algebra manipulation (e.g. substitution), but had to be solved as wholes. And wholeness also pertained to algorithmic determinacy or mathematical \"closure\", which made solution convergence possible and certain in principle, if not corrupted by numerical instability."
  },
  "376": {
    "label": "ParaSail",
    "wikipedia_pageid": 36619168,
    "inception": { "time": "+2009-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 6, 7, 16, 36],
    "typing": [1, 11],
    "description": "**Parallel Specification and Implementation Language** (**ParaSail**) is an object-oriented parallel programming language. Its design and ongoing implementation is described in a blog and on its official website. ParaSail uses a pointer-free programming model, where objects can grow and shrink, and value semantics are used for assignment. It has no global garbage collected heap. Instead, region-based memory management is used throughout. Types can be recursive, so long as the recursive components are declared _optional_. There are no global variables, no parameter aliasing, and all subexpressions of an expression can be evaluated in parallel. Assertions, preconditions, postconditions, class invariants, etc., are part of the standard syntax, using a Hoare-like notation. Any possible race conditions are detected at compile time. Initial design of ParaSail began in September 2009, by S. Tucker Taft. Both an interpreter using the ParaSail virtual machine, and an LLVM-based ParaSail compiler are available. Work stealing is used for scheduling ParaSail's light-weight threads. The latest version can be downloaded from the ParaSail website."
  },
  "377": {
    "label": "Pascal",
    "wikipedia_pageid": 23773,
    "inception": { "time": "+1970-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3, 36],
    "typing": [1, 11],
    "description": "**Pascal** is an imperative and procedural programming language, designed by Niklaus Wirth as a small, efficient language intended to encourage good programming practices using structured programming and data structuring. It is named in honour of the French mathematician, philosopher and physicist Blaise Pascal. Based on Wirth's book _Algorithms + Data Structures = Programs_, Pascal was developed on the pattern of the ALGOL 60 language. Wirth was involved in the process to improve the language as part of the ALGOL X efforts and proposed a version named ALGOL W. This was not accepted, and the ALGOL X process bogged down. In 1968, Wirth decided to abandon the ALGOL X process and further improve ALGOL W, releasing this as Pascal in 1970. On top of ALGOL's scalars and arrays, Pascal enabled defining complex datatypes and building dynamic and recursive data structures such as lists, trees and graphs. Pascal has strong typing on all objects, which means that one type of data cannot be converted to or interpreted as another without explicit conversions. Unlike C (and most languages in the C-family), Pascal allows nested procedure definitions to any level of depth, and also allows most kinds of definitions and declarations inside subroutines (procedures and functions). A program is thus syntactically similar to a single procedure or function. This is similar to the block structure of ALGOL 60, but restricted from arbitrary block statements to just procedures and functions. Pascal became very successful in the 1970s, notably on the burgeoning minicomputer market. Compilers were also available for many microcomputers as the field emerged in the late 1970s. It was widely used as a teaching language in university-level programming courses in the 1980s, and also used in production settings for writing commercial software during the same period. It was displaced by the C programming language during the late 1980s and early 1990s as UNIX-based systems became popular, and especially with the release of C++. A derivative named Object Pascal designed for object-oriented programming was developed in 1985. This was used by Apple Computer and Borland in the late 1980s and later developed into Delphi on the Microsoft Windows platform. Extensions to the Pascal concepts led to the languages Modula-2 and Oberon."
  },
  "378": {
    "label": "Pascal Script",
    "wikipedia_pageid": 31788384,
    "inception": { "time": "+2000-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 2, 3],
    "typing": [1],
    "description": "**Pascal Script** is a scripting language based on the programming language Pascal that facilitates automated runtime control over scriptable applications and server software. It is implemented by a free scripting engine that includes a compiler and an interpreter for byte code. Pascal Script supports the majority of Object Pascal constructs, making it partly compatible to Delphi, Free Pascal and GNU Pascal. Initially developed by Carlo Kok as CajScript and renamed to Innerfuse Pascal Script with version 2.23, the software was taken over by RemObjects, renamed again to RemObjects Pascal Script and offered as open source software for the Delphi IDE. Beginning with version 2.07 CajScript has been ported to Free Pascal. Since 2017 Pascal Script is included as a standard component in the Lazarus IDE."
  },
  "379": {
    "label": "PeopleCode",
    "wikipedia_pageid": 5157513,
    "inception": null,
    "paradigm": [6, 3],
    "typing": [],
    "description": "**PeopleCode** is a proprietary object-oriented programming language used to express business logic for PeopleSoft applications. Syntactically, PeopleCode is similar to other programming languages, and can be found in both loosely- typed and strongly-typed forms. PeopleCode and its run-time environment is part of the larger PeopleTools framework. PeopleCode has evolved over time and its implementation through the PeopleSoft applications lack consistency. PeopleCode offers some interoperability with the Java programming language. Definition name references, for example, enable you to refer to PeopleTools definitions, such as record definitions or pages, without using hard-coded string literals. Other language features, such as PeopleCode data types and metastrings, reflect the close interaction of PeopleTools and Structured Query Language (SQL). Dot notation, classes and methods in PeopleCode are similar to other object oriented languages, like Java. Object syntax was an important feature of PeopleTools 8."
  },
  "380": {
    "label": "Perl",
    "wikipedia_pageid": 23939,
    "inception": { "time": "+1987-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [10],
    "description": "**Perl** is a family of two high-level, general-purpose, interpreted, dynamic programming languages. \"Perl\" refers to Perl 5, but from 2000 to 2019 it also referred to its redesigned \"sister language\", Perl 6, before the latter's name was officially changed to Raku in October 2019. Though Perl is not officially an acronym, there are various backronyms in use, including \"Practical Extraction and Reporting Language\". Perl was developed by Larry Wall in 1987 as a general-purpose Unix scripting language to make report processing easier. Since then, it has undergone many changes and revisions. Raku, which began as a redesign of Perl 5 in 2000, eventually evolved into a separate language. Both languages continue to be developed independently by different development teams and liberally borrow ideas from each other. The Perl languages borrow features from other programming languages including C, shell script (sh), AWK, and sed; They provide text processing facilities without the arbitrary data-length limits of many contemporary Unix command line tools. Perl 5 gained widespread popularity in the late 1990s as a CGI scripting language, in part due to its unsurpassed regular expression and string parsing abilities. In addition to CGI, Perl 5 is used for system administration, network programming, finance, bioinformatics, and other applications, such as for GUIs. It has been nicknamed \"the Swiss Army chainsaw of scripting languages\" because of its flexibility and power, and also its ugliness. In 1998, it was also referred to as the \"duct tape that holds the Internet together,\" in reference to both its ubiquitous use as a glue language and its perceived inelegance. Perl is a highly expressive programming language: source code for a given algorithm can be short and highly compressible."
  },
  "381": {
    "label": "Perl Data Language",
    "wikipedia_pageid": 908764,
    "inception": { "time": "+1996-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3, 20, 21],
    "typing": [],
    "description": "**Perl Data Language** (abbreviated **PDL**) is a set of free software array programming extensions to the Perl programming language. PDL extends the data structures built into Perl, to include large multidimensional arrays, and adds functionality to manipulate those arrays as vector objects. It also provides tools for image processing, machine learning, computer modeling of physical systems, and graphical plotting and presentation. Simple operations are automatically vectorized across complete arrays, and higher-dimensional operations (such as matrix multiplication) are supported."
  },
  "382": {
    "label": "Pharo",
    "wikipedia_pageid": 23490878,
    "inception": { "time": "+2008-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 9],
    "typing": [10],
    "description": "**Pharo** is an open source dynamic and reflective language which is inspired by the programming language Smalltalk. Pharo offers several live programming features such as immediate object manipulation, live update and hot recompiling."
  },
  "383": {
    "label": "Pico",
    "wikipedia_pageid": 379013,
    "inception": { "time": "+1997-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 9],
    "typing": [],
    "description": "_See also Pico (disambiguation)._  **Pico** is a programming language developed at the Software Languages Lab at Vrije Universiteit Brussel. The language was created to introduce the essentials of programming to non-computer science students. Pico can be seen as an effort to generate a palatable and enjoyable language for people who do not want to study hard for the elegance and power of a language. They have done it by adapting Scheme's semantics. While designing Pico, the Software Languages Lab was inspired by the Abelson and Sussman's book \"Structure and Interpretation of Computer Programs\". Furthermore, they were influenced by the teaching of programming at high school or academic level. Pico should be interpreted as 'small', the idea was to create a small language for educational purposes."
  },
  "384": {
    "label": "PicoLisp",
    "wikipedia_pageid": 25055375,
    "inception": { "time": "+1988-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 13, 21, 6, 25, 9],
    "typing": [13, 1, 10],
    "description": "**PicoLisp** is a programming language, a dialect of the language Lisp. It runs on operating systems including Linux and others that are _Portable Operating System Interface_ (POSIX) compliant. Its most prominent features are simplicity and minimalism. It is built on one internal data type: a cell. On the language level, a programmer can use three different data types (numbers, symbols, and lists) being represented by cells and differentiated by bits at the end of the cell. It is free and open-source software released under an MIT License (X11)."
  },
  "385": {
    "label": "Pict",
    "wikipedia_pageid": 6751312,
    "inception": null,
    "paradigm": [16, 21],
    "typing": [11],
    "description": "**Pict** is a statically typed programming language, one of the very few based on the π-calculus. Work on the language began at the University of Edinburgh in 1992, and development has been more or less dormant since 1998. The language is still at an experimental stage."
  },
  "386": {
    "label": "Pizza",
    "wikipedia_pageid": 509700,
    "inception": null,
    "paradigm": [26],
    "typing": [],
    "description": "**Pizza** is an open-source superset of Java 1.4, prior to the introduction of generics for the Java programming language. In addition to its own solution for adding generics to the language, Pizza also added function pointers and algebraic types with case classes and pattern matching. In August 2001, the developers made a compiler capable of working with Java. Most Pizza applications can run in a Java environment, but certain cases will cause problems. Pizza's last version was released in January 2002. Its main developers turned their focus afterwards to the Generic Java project: another attempt to add generics to Java that was officially adopted as of version 5 of the language. The pattern matching and other functional programming-like features have been further developed in the Scala programming language. Martin Odersky remarked, \"we wanted to integrate the functional and object-oriented parts in a cleaner way than what we were able to achieve before with the Pizza language. [...] In Pizza we did a clunkier attempt, and in Scala I think we achieved a much smoother integration between the two.\""
  },
  "387": {
    "label": "Plankalkül",
    "wikipedia_pageid": 65944,
    "inception": { "time": "+1948-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2],
    "typing": [],
    "description": "**Plankalkül** (German pronunciation: [ˈplaːnkalkyːl]) is a programming language designed for engineering purposes by Konrad Zuse between 1942 and 1945. It was the first high-level programming language to be designed for a computer. _Kalkül_ is the German term for a formal system—as in _Hilbert-Kalkül_, the original name for the Hilbert-style deduction system—so _Plankalkül_ refers to a formal system for planning."
  },
  "388": {
    "label": "Planner",
    "wikipedia_pageid": 46143,
    "inception": { "time": "+1969-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [28, 2],
    "typing": [],
    "description": "**Planner** (often seen in publications as \"PLANNER\" although it is not an acronym) is a programming language designed by Carl Hewitt at MIT, and first published in 1969. First, subsets such as Micro-Planner and Pico-Planner were implemented, and then essentially the whole language was implemented as _Popler_ by Julian Davies at the University of Edinburgh in the POP-2 programming language. Derivations such as QA4, Conniver, QLISP and Ether (see scientific community metaphor) were important tools in artificial intelligence research in the 1970s, which influenced commercial developments such as Knowledge Engineering Environment (KEE) and Automated Reasoning Tool (ART)."
  },
  "389": {
    "label": "Plus",
    "wikipedia_pageid": 27900530,
    "inception": { "time": "+1976-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 36],
    "typing": [1, 11],
    "description": "**Plus** is a \"Pascal-like\" system implementation language from the University of British Columbia (UBC), Canada, based on the SUE system language developed at the University of Toronto, c. 1971. There is another programming language named PLUS, developed at Sperry Univac in Roseville, Minnesota, but the Univac PLUS is not the subject of this article."
  },
  "390": {
    "label": "Polymorphic Programming Language",
    "wikipedia_pageid": 5005125,
    "inception": { "time": "+1969-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2],
    "typing": [],
    "description": "The **Polymorphic Programming Language** (**PPL**) was developed in 1969 at Harvard University by Thomas A. Standish. It is an interactive, extensible language with a base language similar to the language APL. The assignment operator `<-` (or `←`) has influenced the language S."
  },
  "391": {
    "label": "PostScript",
    "wikipedia_pageid": 24080,
    "inception": { "time": "+1982-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 23, 33],
    "typing": [10, 2],
    "description": "**PostScript** (**PS**) is a page description language in the electronic publishing and desktop publishing business. It is a dynamically typed, concatenative programming language. It was created at Adobe Systems by John Warnock, Charles Geschke, Doug Brotz, Ed Taft and Bill Paxton from 1982 to 1984."
  },
  "392": {
    "label": "PowerShell",
    "wikipedia_pageid": 14465871,
    "inception": { "time": "+2006-11-14T00:00:00Z", "precision": 11 },
    "paradigm": [2, 3, 21, 6, 9],
    "typing": [1, 10, 6],
    "description": "**PowerShell** is a task automation and configuration management framework from Microsoft, consisting of a command-line shell and the associated scripting language. Initially a Windows component only, known as **Windows PowerShell**, it was made open-source and cross-platform on 18 August 2016 with the introduction of **PowerShell Core**. The former is built on the .NET Framework, the latter on .NET Core. In PowerShell, administrative tasks are generally performed by _cmdlets_ (pronounced _command-lets_), which are specialized .NET classes implementing a particular operation. These work by accessing data in different data stores, like the file system or registry, which are made available to PowerShell via _providers_. Third-party developers can add cmdlets and providers to PowerShell. Cmdlets may be used by scripts, which may in turn be packaged into modules. PowerShell provides access to COM and WMI, enabling administrators to perform administrative tasks on both local and remote Windows systems as well as WS- Management and CIM enabling management of remote Linux systems and network devices. PowerShell also provides a hosting API with which the PowerShell runtime can be embedded inside other applications. These applications can then use PowerShell functionality to implement certain operations, including those exposed via the graphical interface. This capability has been used by Microsoft Exchange Server 2007 to expose its management functionality as PowerShell cmdlets and providers and implement the graphical management tools as PowerShell hosts which invoke the necessary cmdlets. Other Microsoft applications including Microsoft SQL Server 2008 also expose their management interface via PowerShell cmdlets. PowerShell includes its own extensive, console-based help (similar to man pages in Unix shells) accessible via the `Get-Help` cmdlet. Updated local help contents can be retrieved from the Internet via the `Update-Help` cmdlet. Alternatively, help from the web can be acquired on a case-by-case basis via the `-online` switch to `Get-Help`."
  },
  "393": {
    "label": "PowerHouse",
    "wikipedia_pageid": 4313670,
    "inception": { "time": "+1982-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**PowerHouse** is a byte-compiled fourth-generation programming language (or 4GL) originally produced by Quasar Corporation (later renamed Cognos Incorporated) for the Hewlett-Packard _HP3000_ mini-computer, as well as Data General and DEC VAX VMS computing products. It was initially composed of five components:   * _QDD, or Quasar Data Dictionary_ : for building a central data dictionary used by all other components   * _QDesign_ : a character-based screen generator   * _Quick_ : an interactive, character-based screen processor (running screens generated by QDesign)   * _Quiz_ : a report writer   * _QTP_ : a batch transaction processor."
  },
  "394": {
    "label": "Pro*C",
    "wikipedia_pageid": 13142178,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**Pro*C** (also known as **Pro*C/C++**) is an embedded SQL programming language used by Oracle Database DBMSes. Pro*C uses either C or C++ as its host language. During compilation, the embedded SQL statements are interpreted by a precompiler and replaced by C or C++ function calls to their respective SQL library. The output from the Pro*C precompiler is standard C or C++ code that is then compiled by any one of several C or C++ compilers into an executable."
  },
  "395": {
    "label": "Processing",
    "wikipedia_pageid": 546083,
    "inception": { "time": "+2001-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [],
    "description": "**Processing** is a free graphical library and integrated development environment (IDE) built for the electronic arts, new media art, and visual design communities with the purpose of teaching non-programmers the fundamentals of computer programming in a visual context. Processing uses the Java language, with additional simplifications such as additional classes and aliased mathematical functions and operations. It also provides a graphical user interface for simplifying the compilation and execution stage. The Processing language and IDE have been the precursor to other projects including Arduino, Wiring and p5.js."
  },
  "396": {
    "label": "Programming Language for Business",
    "wikipedia_pageid": 350323,
    "inception": { "time": "+1972-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3],
    "typing": [1, 11],
    "description": "**Programming Language for Business** or **PL/B** is a business-oriented programming language originally called **DATABUS** and designed by Datapoint in 1972 as an alternative to COBOL because Datapoint's 8-bit computers could not fit COBOL into their limited memory, and because COBOL did not at the time have facilities to deal with Datapoint's built-in keyboard and screen. A version of DATABUS became an ANSI standard, and the name PL/B came about when Datapoint chose not to release its trademark on the DATABUS name."
  },
  "397": {
    "label": "Programming Computable Functions",
    "wikipedia_pageid": 3239232,
    "inception": { "time": "+1977-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [21],
    "typing": [],
    "description": "In computer science,**Programming Computable Functions** (PCF) is a typed functional language introduced by Gordon Plotkin in 1977, based on previous unpublished material by Dana Scott. It can be considered to be an extended version of the typed lambda calculus or a simplified version of modern typed functional languages such as ML or Haskell. A fully abstract model for PCF was first given by Milner (1977). However, since Milner's model was essentially based on the syntax of PCF it was considered less than satisfactory (Ong, 1995). The first two fully abstract models not employing syntax were formulated during the 1990s. These models are based on game semantics (Hyland and Ong, 2000; Abramsky, Jagadeesan, and Malacaria, 2000) and Kripke logical relations (O'Hearn and Riecke, 1995). For a time it was felt that neither of these models was completely satisfactory, since they were not effectively presentable. However, Ralph Loader demonstrated that no effectively presentable fully abstract model could exist, since the question of program equivalence in the finitary fragment of PCF is not decidable."
  },
  "398": {
    "label": "Prograph",
    "wikipedia_pageid": 521637,
    "inception": { "time": "+1983-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [22, 6, 10],
    "typing": [],
    "description": "**Prograph** is a visual, object-oriented, dataflow, multiparadigm programming language that uses iconic symbols to represent actions to be taken on data. Commercial Prograph software development environments such as Prograph Classic and Prograph CPX were available for the Apple Macintosh and Windows platforms for many years but were eventually withdrawn from the market in the late 1990s. Support for the Prograph language on macOS has recently reappeared with the release of the Marten software development environment."
  },
  "399": {
    "label": "Project Verona",
    "wikipedia_pageid": 65846629,
    "inception": { "time": "+2019-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**Project Verona** is an experimental research programming language developed by Microsoft and aimed at dealing with memory situations to make other programming languages safer. The project is being supported by C# project manager Mads Torgensen and Microsoft Research Cambridge research software engineer Juliana Franco. Project Verona is also being aided by academics at Imperial College London. Unlike in Rust where the ownership model based on a single object, it is based on groups of objects in Verona. According to Microsoft, the goal of the project is to create a safer platform for memory management. Project Verona is open source released under MIT License and is under active development on GitHub."
  },
  "400": {
    "label": "Prolog",
    "wikipedia_pageid": 23485,
    "inception": { "time": "+1972-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [28, 13, 18],
    "typing": [],
    "description": "**Prolog** is a logic programming language associated with artificial intelligence and computational linguistics. Prolog has its roots in first-order logic, a formal logic, and unlike many other programming languages, Prolog is intended primarily as a declarative programming language: the program logic is expressed in terms of relations, represented as facts and rules. A computation is initiated by running a _query_ over these relations. The language was developed and implemented in Marseille, France, in 1972 by Alain Colmerauer with Philippe Roussel, based on Robert Kowalski's procedural interpretation of Horn clauses. Prolog was one of the first logic programming languages and remains the most popular such language today, with several free and commercial implementations available. The language has been used for theorem proving, expert systems, term rewriting, type systems, and automated planning, as well as its original intended field of use, natural language processing. Modern Prolog environments support the creation of graphical user interfaces, as well as administrative and networked applications. Prolog is well-suited for specific tasks that benefit from rule-based logical queries such as searching databases, voice control systems, and filling templates."
  },
  "401": {
    "label": "Promela",
    "wikipedia_pageid": 9733137,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**PROMELA** (**Process** or **Protocol Meta Language**) is a verification modeling language introduced by Gerard J. Holzmann. The language allows for the dynamic creation of concurrent processes to model, for example, distributed systems. In PROMELA models, communication via message channels can be defined to be synchronous (i.e., rendezvous), or asynchronous (i.e., buffered). PROMELA models can be analyzed with the SPIN model checker, to verify that the modeled system produces the desired behavior. An implementation verified with Isabelle/HOL is also available, as part of the Computer Aided Verification of Automata project. Files written in Promela traditionally have a `.pml` file extension."
  },
  "402": {
    "label": "Protel",
    "wikipedia_pageid": 13134192,
    "inception": null,
    "paradigm": [2],
    "typing": [],
    "description": "**Protel** stands for \"Procedure Oriented Type Enforcing Language\". It is a programming language created by Nortel Networks and used on telecommunications switching systems such as the DMS-100. Protel-2 is the object-oriented version of Protel. PROTEL languages were designed to meet the needs of digital telephony and is the basis of the DMS-100 line of switching systems PROTEL is a strongly typed, block-structured language which is based heavily on PASCAL and ALGOL 68 with left-to-right style of variable assignment, variable-sized arrays, and extensible structures. The designers of PROTEL significantly extended PASCAL of the day by adding external compilation and extending the data structures available in the language."
  },
  "403": {
    "label": "ProvideX",
    "wikipedia_pageid": 2276397,
    "inception": { "time": "+1992-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 2],
    "typing": [1],
    "description": "**ProvideX** is a computer language and development environment derived from Business Basic (a business oriented derivative of BASIC) in the mid-1980s. ProvideX is available on several operating systems (Unix/Linux/Windows/Mac OS X) and includes not only the programming language but also file system, presentation layer interface, and other components. The language is primarily designed for use in the development of business applications. Over the years since its inception and as the computer industry has changed, ProvideX has added functionality such as a graphical interface, client-server capabilities, access to external databases, web services, and, more recently, object-oriented programming capabilities. On October 8, 2010, PVX Plus Technologies announced that it has assumed all ongoing sales, development, and support of the ProvideX product line for Independent Software Vendors. This brings the development of the language back under control of the original creator, Mike King and is the end result of almost 2 years of negotiations between Sage, EDIAS, and PVX Plus Technologies."
  },
  "404": {
    "label": "Pure",
    "wikipedia_pageid": 20446791,
    "inception": { "time": "+2008-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [13, 21],
    "typing": [10, 1],
    "description": "**Pure**, successor to the equational language **Q**, is a dynamically typed, functional programming language based on term rewriting. It has facilities for user-defined operator syntax, macros, arbitrary-precision arithmetic (multiple-precision numbers), and compiling to native code through the LLVM. Pure is free and open-source software distributed (mostly) under the GNU Lesser General Public License version 3 or later. Pure comes with an interpreter and debugger, provides automatic memory management, has powerful functional and symbolic programming abilities, and interfaces to libraries in C (e.g., for numerics, low-level protocols, and other such tasks). At the same time, Pure is a _small_ language designed from scratch; its interpreter is not large, and the library modules are written in Pure. The syntax of Pure resembles that of Miranda and Haskell, but it is a free-format language and thus uses explicit delimiters (rather than off-side rule indents) to denote program structure. The Pure language is a successor of the equational programming language Q, previously created by the same author, Albert Gräf at the University of Mainz, Germany. Relative to Q, it offers some important new features (such as local functions with lexical scoping, efficient vector and matrix support, and the built-in C interface) and programs run much faster as they are compiled just- in-time to native code on the fly. Pure is mostly aimed at mathematical applications and scientific computing currently, but its interactive interpreter environment, the C interface and the growing set of addon modules make it suitable for a variety of other applications, such as artificial intelligence, symbolic computation, and real-time multimedia processing. Pure plug-ins are available for the Gnumeric spreadsheet and Miller Puckette's Pure Data graphical multimedia software, which make it possible to extend these programs with functions written in the Pure language. Interfaces are also provided as library modules to GNU Octave, OpenCV, OpenGL, the GNU Scientific Library, FAUST, SuperCollider, and liblo (for Open Sound Control (OSC))."
  },
  "405": {
    "label": "Pure Data",
    "wikipedia_pageid": 480378,
    "inception": { "time": "+1996-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [22],
    "typing": [],
    "description": "**Pure Data** (**Pd**) is a visual programming language developed by Miller Puckette in the 1990s for creating interactive computer music and multimedia works. While Puckette is the main author of the program, Pd is an open-source project with a large developer base working on new extensions. It is released under BSD-3-Clause. It runs on Linux, Mac OS X, iOS, Android and Windows. Ports exist for FreeBSD and IRIX. Pd is very similar in scope and design to Puckette's original Max program, developed while he was at IRCAM, and is to some degree interoperable with Max/MSP, the commercial predecessor to the Max language. They may be collectively discussed as members of the Patcher family of languages. With the addition of the Graphics Environment for Multimedia (GEM) external, and externals designed to work with it (like Pure Data Packet / PiDiP for Linux, Mac OS X), framestein for Windows, GridFlow (as n-dimensional matrix processing, for Linux, Mac OS X, Windows), it is possible to create and manipulate video, OpenGL graphics, images, etc., in realtime with extensive possibilities for interactivity with audio, external sensors, etc. Pd is natively designed to enable live collaboration across networks or the Internet, allowing musicians connected via LAN or even in disparate parts of the globe to create music together in real time. Pd uses FUDI as a networking protocol."
  },
  "406": {
    "label": "PureScript",
    "wikipedia_pageid": 60230260,
    "inception": { "time": "+2013-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [29, 21],
    "typing": [1, 6, 11],
    "description": "**PureScript** is a strongly-typed, purely-functional programming language that compiles to JavaScript. It can be used to develop web applications, server side apps, and also desktop applications with use of Electron. Its syntax is mostly comparable to that of Haskell. In addition, it introduces row polymorphism and extensible records. Also, contrary to Haskell, PureScript adheres to a strict evaluation strategy."
  },
  "407": {
    "label": "Python",
    "wikipedia_pageid": 23862,
    "inception": { "time": "+1991-02-20T00:00:00Z", "precision": 11 },
    "paradigm": [6, 3, 21],
    "typing": [5, 13, 10],
    "description": "**Python** is an interpreted high-level general-purpose programming language. Python's design philosophy emphasizes code readability with its notable use of significant indentation. Its language constructs as well as its object- oriented approach aim to help programmers write clear, logical code for small and large-scale projects. Python is dynamically-typed and garbage-collected. It supports multiple programming paradigms, including structured (particularly, procedural), object-oriented and functional programming. Python is often described as a \"batteries included\" language due to its comprehensive standard library. Guido van Rossum began working on Python in the late 1980s, as a successor to the ABC programming language, and first released it in 1991 as Python 0.9.0. Python 2.0 was released in 2000 and introduced new features, such as list comprehensions and a garbage collection system using reference counting. Python 3.0 was released in 2008 and was a major revision of the language that is not completely backward-compatible and much Python 2 code does not run unmodified on Python 3. Python 2 was discontinued with version 2.7.18 in 2020. Python consistently ranks as one of the most popular programming languages."
  },
  "408": {
    "label": "P′′",
    "wikipedia_pageid": 2242844,
    "inception": { "time": "+1964-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3, 36],
    "typing": [],
    "description": "**P′′** (P double prime) is a primitive computer programming language created by Corrado Böhm in 1964 to describe a family of Turing machines."
  },
  "409": {
    "label": "Q",
    "wikipedia_pageid": 18595067,
    "inception": { "time": "+2003-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [20, 21],
    "typing": [10, 1],
    "description": "**Q** is a programming language for array processing, developed by Arthur Whitney. It is proprietary software, commercialized by Kx Systems. Q serves as the query language for kdb+, a disk based and in-memory, column-based database. Kdb+ is based on the language k, a terse variant of the language APL. Q is a thin wrapper around k, providing a more readable, English-like interface."
  },
  "410": {
    "label": "Q#",
    "wikipedia_pageid": 56025620,
    "inception": { "time": "+2017-12-11T00:00:00Z", "precision": 11 },
    "paradigm": [3, 21],
    "typing": [1, 11],
    "description": "**Q#** (pronounced as _Q sharp_) is a domain-specific programming language used for expressing quantum algorithms. It was initially released to the public by Microsoft as part of the Quantum Development Kit."
  },
  "411": {
    "label": "Qalb",
    "wikipedia_pageid": 38441485,
    "inception": { "time": "+2012-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [21],
    "typing": [],
    "description": "**قلب** (Levantine Arabic: [ʔalb]), transliterated _**Qalb**_,_**Qlb**_ and _**Alb**_, is a functional programming language allowing a programmer to write programs completely in Arabic. Its name means _heart_ and is a recursive acronym in Arabic meaning _Qlb: a programming language_ (قلب: لغة برمجة,__Qlb: Lughat Barmajah__). It was developed in 2012 by Ramsey Nasser, a computer scientist at the Eyebeam Art + Technology Center in New York City, as both an artistic endeavor and as a response to the Anglophone bias in the vast majority of programming languages, which express their fundamental concepts using English words. The syntax is like that of Lisp or Scheme, consisting of parenthesized lists. All keywords are appropriate Arabic terms, and program text is laid out right- to-left, like all Arabic text. Specifically, the Arabic used is Lebanese Arabic, as is evident by the use of قول instead of the Modern Standard Arabic قل. The language provides a minimal set of primitives for defining functions, conditionals, looping, list manipulation, and basic arithmetic expressions. It is Turing-complete, and the Fibonacci sequence and Conway's Game of Life have been implemented. Because all program text is written in Arabic, and the connecting strokes between characters in the Arabic script can be extended to any length, it is possible to align the source code in artistic patterns, in the tradition of Arabic calligraphy. A JavaScript-based interpreter is currently hosted on herokuapp and the project can be forked on GitHub."
  },
  "412": {
    "label": "QtScript",
    "wikipedia_pageid": 9609819,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**QtScript** is a scripting engine that has been part of the Qt cross-platform application framework since version 4.3.0. The scripting language is based on the ECMAScript standard with a few extensions, such as QObject-style signal and slot connections. The library contains the engine, and a C++ API for evaluating QtScript code and exposing custom QObject-derived C++ classes to QtScript. The QtScript Binding Generator provides bindings for the Qt API to access directly from ECMAScript. QtScript and the binding generator are used for Amarok 2's scripting system. The current (as of Qt 4.7) implementation uses JavaScriptCore and will not be further developed. The module is deprecated as of Qt 5.5."
  },
  "413": {
    "label": "QuakeC",
    "wikipedia_pageid": 25207,
    "inception": { "time": "+1996-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 36],
    "typing": [1, 11],
    "description": "**QuakeC** is a compiled language developed in 1996 by John Carmack of id Software to program parts of the video game _Quake_. Using QuakeC, a programmer is able to customize _Quake_ to great extents by adding weapons, changing game logic and physics, and programming complex scenarios. It can be used to control many aspects of the game itself, such as parts of the AI, triggers, or changes in the level. The _Quake_ engine was the only game engine to use QuakeC. Following engines used DLL game modules for customization written in C, and C++ from id Tech 4 on."
  },
  "414": {
    "label": "Quantum computation language",
    "wikipedia_pageid": 55836939,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**Quantum Computation Language** (**QCL**) is one of the first implemented quantum programming languages. The most important feature of QCL is the support for user-defined operators and functions. Its syntax resembles the syntax of the C programming language and its classical data types are similar to primitive data types in C. One can combine classical code and quantum code in the same program. The QCL standard library provides standard quantum operators used in quantum algorithms such as:   * Controlled-not with many target qubits,   * Hadamard operation on many qubits,   * Phase and controlled phase.   * Quantum algorithms for addition, multiplication and exponentiation with binary constants (all modulus n)   * The quantum fourier transform"
  },
  "415": {
    "label": "R",
    "wikipedia_pageid": 376707,
    "inception": { "time": "+1993-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 20, 21, 6, 9],
    "typing": [10],
    "description": "**R** is a programming language and free software environment for statistical computing and graphics supported by the R Foundation for Statistical Computing. The R language is widely used among statisticians and data miners for developing statistical software and data analysis. Polls, data mining surveys, and studies of scholarly literature databases show substantial increases in popularity; as of June 2021, R ranks 14th in the TIOBE index, a measure of popularity of programming languages. The official R software environment is a GNU package. It is written primarily in C, Fortran, and R itself (thus, it is partially self-hosting) and is freely available under the GNU General Public License. Pre-compiled executables are provided for various operating systems. Although R has a command line interface, there are several third-party graphical user interfaces, such as RStudio, an integrated development environment, and Jupyter, a notebook interface."
  },
  "416": {
    "label": "R++",
    "wikipedia_pageid": 8387439,
    "inception": { "time": "+1990-01-01T00:00:00Z", "precision": 8 },
    "paradigm": [28],
    "typing": [],
    "description": "**R++** is a rule-based programming language based on C++. The United States patent describes R++ as follows: > The R++ extension permits rules to be defined as members of C++ classes. The > programming system of the invention takes the classes with rules defined > using R++ and generates C++ code from them in which the machinery required > for the rules is implemented completely as C++ data members and functions of > the classes involved in the rules. R++ was developed by Bell Labs in the 1990s, but due to the Bell System divestiture that split the legal rights to the work developed at the Laboratories between AT&T and Lucent, did not see immediate commercial development while the two companies disputed ownership."
  },
  "417": {
    "label": "RAPID",
    "wikipedia_pageid": 26407459,
    "inception": { "time": "+1994-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**RAPID** is a high-level programming language used to control ABB industrial robots. RAPID was introduced along with S4 Control System in 1994 by ABB, superseding the ARLA programming language. Features in the language include:   * Routine parameters:      * Procedures - used as a subprogram.     * Functions - return a value of a specific type and are used as an argument of an instruction.     * Trap routines - a means of responding to interrupts.   * Arithmetic and logical expressions   * Automatic error handling   * Modular programs   * Multi tasking"
  },
  "418": {
    "label": "REBOL",
    "wikipedia_pageid": 26384,
    "inception": { "time": "+1997-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [34, 3, 14, 21],
    "typing": [10, 1],
    "description": "**Rebol** (_REB -əl_; historically **REBOL**) is a cross-platform data exchange language and a multi-paradigm dynamic programming language designed by Carl Sassenrath for network communications and distributed computing. It introduces the concept of dialecting: small, optimized, domain-specific languages for code and data, which is also the most notable property of the language according to its designer Carl Sassenrath: > Although it can be used for programming, writing functions, and performing > processes, its greatest strength is the ability to easily create domain- > specific languages or dialects Douglas Crockford, known for his involvement in the development of JavaScript, has described Rebol as \"a more modern language, but with some very similar ideas to Lisp, in that it's all built upon a representation of data which is then executable as programs\" and as one of JSON's influences. Originally, the language and its official implementation were proprietary and closed source, developed by REBOL Technologies. Following discussion with Lawrence Rosen, the Rebol version 3 interpreter was released under the Apache 2.0 license on December 12, 2012. Older versions are only available in binary form, and no source release for them is planned. Rebol has been used to program Internet applications (both client- and server- side), database applications, utilities, and multimedia applications."
  },
  "419": {
    "label": "Refal",
    "wikipedia_pageid": 14926151,
    "inception": { "time": "+1968-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [21],
    "typing": [10, 1],
    "description": "**Refal** (**\"Recursive functions algorithmic language\"** ; Russian: РЕФАЛ) \"is a functional programming language oriented toward symbolic computations\", including \"string processing, language translation, [and] artificial intelligence\". It is one of the oldest members of this family, first conceived of in 1966 as a theoretical tool, with the first implementation appearing in 1968. Refal was intended to combine mathematical simplicity with practicality for writing large and sophisticated programs. One of the first functional programming languages to do so, and unlike Lisp of its time, Refal is based on pattern matching. Its pattern matching works in conjunction with term rewriting. The basic data structure of Lisp and Prolog is a linear list built by cons operation in a sequential manner, thus with _O(n)_ access to list's _n_ th element. Refal's lists are built and scanned from both ends, with pattern matching working for nested lists as well as the top-level one. In effect, the basic data structure of Refal is a tree rather than a list. This gives freedom and convenience in creating data structures while using only mathematically simple control mechanisms of pattern matching and substitution. Refal also includes a feature called the _freezer_ to support efficient partial evaluation. Refal can be applied to the processing and transformation of tree structures, similarly to XSLT."
  },
  "420": {
    "label": "REXX",
    "wikipedia_pageid": 25572284,
    "inception": { "time": "+1979-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 36],
    "typing": [10],
    "description": "**Rexx** (**Restructured Extended Executor**) is an interpreted programming language developed at IBM by Mike Cowlishaw. It is a structured, high-level programming language designed for ease of learning and reading. Proprietary and open source Rexx interpreters exist for a wide range of computing platforms; compilers exist for IBM mainframe computers. Rexx is used as a scripting and macro language, and is often used for processing data and text and generating reports; these similarities with Perl mean that Rexx works well in Common Gateway Interface (CGI) programming and it is indeed used for this purpose. Rexx is the primary scripting language in some operating systems, e.g. OS/2, MVS, VM, AmigaOS, and is also used as an internal macro language in some other software, such as SPFPC, KEDIT, THE and the ZOC terminal emulator. Additionally, the Rexx language can be used for scripting and macros in any program that uses Windows Scripting Host ActiveX scripting engines languages (e.g. VBScript and JScript) if one of the Rexx engines is installed. Rexx is supplied with VM/SP Release 3 on up, TSO/E Version 2 on up, OS/2 (1.3 and later, where it is officially named _Procedures Language/2_), AmigaOS Version 2 on up, PC DOS (7.0 or 2000), ArcaOS, and Windows NT 4.0 (Resource Kit: Regina). REXX scripts for OS/2 share the filename extension .cmd with other scripting languages, and the first line of the script specifies the interpreter to be used. REXX macros for REXX-aware applications use extensions determined by the application. In the late 1980s, Rexx became the common scripting language for IBM Systems Application Architecture, where it was renamed \"SAA Procedure Language REXX\". A Rexx script or command is sometimes referred to as an _EXEC_ in a nod to the CMS file type used for EXEC, EXEC 2 and REXX scripts on CP/CMS and VM/370 through z/VM."
  },
  "421": {
    "label": "ROOP",
    "wikipedia_pageid": 931356,
    "inception": { "time": "+1995-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [28, 6, 2],
    "typing": [],
    "description": "**ROOP** is a multiparadigm programming language targeted at AI applications created at the Chengdu University of China. It combines rule-based, procedural, logical and object-oriented programming techniques."
  },
  "422": {
    "label": "RPL",
    "wikipedia_pageid": 512681,
    "inception": { "time": "+1984-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [36, 6, 33],
    "typing": [],
    "description": "**RPL** [1] is a handheld calculator operating system and application programming language used on Hewlett-Packard's scientific graphing RPN (Reverse Polish Notation) calculators of the HP 28, 48, 49 and 50 series, but it is also usable on non-RPN calculators, such as the 38, 39 and 40 series. RPL is a structured programming language based on RPN, but equally capable of processing algebraic expressions and formulae, implemented as a threaded interpreter. RPL has many similarities to Forth, both languages being stack- based, as well as the list-based LISP. Contrary to previous HP RPN calculators, which had a fixed four-level stack, the stack used by RPL is only limited by available calculator RAM. RPL originated from HP's Corvallis, Oregon development facility in 1984 as a replacement for the previous practice of implementing the operating systems of calculators in assembly language. The last pocket calculator supporting RPL, the HP 50g, was discontinued in 2015. However, multiple emulators that can emulate HP's RPL calculators exist that run on a range of operating systems, and devices, including iOS and Android smartphones."
  },
  "423": {
    "label": "RTL/2",
    "wikipedia_pageid": 28045268,
    "inception": { "time": "+1972-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 36],
    "typing": [12, 1, 11],
    "description": "**RTL/2** (Real-Time Language) is a discontinued high-level programming language for use in real-time computing, developed at Imperial Chemical Industries, Ltd. (ICI), by J.G.P. Barnes. It was originally used internally in ICI but was distributed by SPL International in 1974. It was based on concepts from ALGOL 68, and intended to be small and simple. RTL/2 was standardised in 1980 by the British Standards Institution."
  },
  "424": {
    "label": "Racket",
    "wikipedia_pageid": 3350021,
    "inception": { "time": "+1995-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [18, 2, 21, 6, 25, 9],
    "typing": [10, 1],
    "description": "**Racket** is a general-purpose, multi-paradigm programming language based on the Scheme dialect of Lisp. It is designed as a platform for programming language design and implementation. In addition to the core Racket language,_Racket_ is also used to refer to the family of programming languages and set of tools supporting development on and with Racket. Racket is also used for scripting, computer science education, and research. The Racket platform provides an implementation of the Racket language (including a runtime system, libraries, and JIT compiler) along with the DrRacket integrated development environment (IDE) written in Racket. Racket is used by the ProgramByDesign outreach program, which aims to turn computer science into \"an indispensable part of the liberal arts curriculum\". The core Racket language is known for its extensive macro system which enables creating embedded and domain-specific languages, language constructs such as classes or modules, and separate dialects of Racket with different semantics. The platform distribution is free and open-source software distributed under the Apache 2.0 and MIT licenses. Extensions and packages written by the community may be uploaded to Racket's package catalog."
  },
  "425": {
    "label": "Raku",
    "wikipedia_pageid": 1146638,
    "inception": { "time": "+2015-12-25T00:00:00Z", "precision": 11 },
    "paradigm": [6, 3, 21],
    "typing": [10, 5],
    "description": "**Raku** is a member of the Perl family of programming languages. Formerly known as **Perl 6**, it was renamed in October 2019. Raku introduces elements of many modern and historical languages. Compatibility with Perl was not a goal, though a compatibility mode is part of the specification. The design process for Raku began in 2000."
  },
  "426": {
    "label": "Rapira",
    "wikipedia_pageid": 146951,
    "inception": { "time": "+1987-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 36],
    "typing": [10],
    "description": "_Rapira is also a name for the Soviet 100 mm anti-tank gun T-12_ **Rapira** (Russian: Рапира, rapier) is an educational procedural programming language developed in the Soviet Union and implemented on the Agat computer, PDP-11 clones (Electronika, DVK, BK series), and Intel 8080 and Zilog Z80 clones (Korvet). It is interpreted with a dynamic type system and high level constructions. The language originally had a Russian-based set of reserved words (keywords), but English and Romanian were added later. Also, it was more elegant and easier to use than Pascal implementations of the time. Rapira was used to teach computer programming in Soviet schools. The integrated development environment included a text editor and a debugger. Sample program:               ПРОЦ СТАРТ()         ВЫВОД: 'Привет, мир!!!'     КОН ПРОЦ      The same, but using the English lexics [sic, from the article referenced below]:               proc start()          output: 'Hello, world!!!';     end proc      Rapira's ideology was based on languages such as POP-2 and SETL, with strong influences from ALGOL. Consequently, for example, Rapira implements a very strong, flexible, and interesting data structure, named a _tuple_. in Rapira, these are heterogeneous lists with allowed operations such as indexing, joining, length count, getting of sublist, easy comparison, etc."
  },
  "427": {
    "label": "Ratfor",
    "wikipedia_pageid": 390257,
    "inception": { "time": "+1976-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**Ratfor** (short for _Rational Fortran_) is a programming language implemented as a preprocessor for Fortran 66. It provides modern control structures, unavailable in Fortran 66, to replace GOTOs and statement numbers."
  },
  "428": {
    "label": "rc",
    "wikipedia_pageid": 171918,
    "inception": { "time": "+1989-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3],
    "typing": [2],
    "description": "**rc** (for \"run commands\") is the command line interpreter for Version 10 Unix and Plan 9 from Bell Labs operating systems. It resembles the Bourne shell, but its syntax is somewhat simpler. It was created by Tom Duff, who is better known for an unusual C programming language construct (\"Duff's device\"). A port of the original rc to Unix is part of Plan 9 from User Space. A rewrite of rc for Unix-like operating systems by Byron Rakitzis is also available but includes some incompatible changes. Rc uses C-like control structures instead of the original Bourne shell's ALGOL-like structures, except that it uses an `if not` construct instead of `else`, and has a Bourne-like `for` loop to iterate over lists. In rc, all variables are lists of strings, which eliminates the need for constructs like \"`$@`\". Variables are not re-split when expanded. The language is described in Duff's paper."
  },
  "429": {
    "label": "Reason",
    "wikipedia_pageid": 60312680,
    "inception": { "time": "+2016-03-00T00:00:00Z", "precision": 10 },
    "paradigm": [21],
    "typing": [11],
    "description": "**Reason**, also known as **ReasonML**, is a syntax extension and toolchain for OCaml created by Jordan Walke, who also created React, at Facebook. Reason offers a syntax familiar to JavaScript programmers, and transpiles to OCaml. Statically typed Reason (or OCaml) code may be compiled to dynamically typed JavaScript using the _ReScript_ compiler. The Reason community officially provides ReasonReact as a solution for React based web applications."
  },
  "430": {
    "label": "Red",
    "wikipedia_pageid": 35733875,
    "inception": { "time": "+2011-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3, 21],
    "typing": [],
    "description": "**Red** is a programming language designed to overcome the limitations of the programming language Rebol. Red was introduced in 2011 by Nenad Rakočević, and is both an imperative and functional programming language. Its syntax and general usage overlaps that of the interpreted Rebol language. The implementation choices of Red intend to create a full stack programming language: Red can be used for extremely high-level programming (DSLs and GUIs) as well as low-level programming (operating systems and device drivers). Key to the approach is that the language has two parts: _Red/System_ and _Red_.   * _Red/System_ is similar to C, but packaged into a Rebol lexical structure – for example, one would write `if x > y [print \"Hello\"]` instead of `if (x > y) {printf(\"Hello\\n\");}`.   * _Red_ is a homoiconic language capable of meta-programming, with semantics similar to Rebol's. Red's runtime library is written in Red/System, and uses a hybrid approach: it compiles what it can deduce statically and uses an embedded interpreter otherwise. The project roadmap includes a just-in-time compiler for cases in between, but this has not yet been implemented. Red seeks to remain independent of any other toolchain; it does its own code generation. It is therefore possible to cross-compile Red programs from any platform it supports to any other, via a command-line switch. Both Red and Red/System are distributed as open-source software under the modified BSD license. The runtime library is distributed under the more permissive Boost Software License. As of version 0.6.4 Red includes a garbage collector \"the Simple GC\"."
  },
  "431": {
    "label": "Rlab",
    "wikipedia_pageid": 593529,
    "inception": null,
    "paradigm": [20],
    "typing": [],
    "description": "**Rlab** is an interactive, interpreted numerical computation program and its core programming language, written by Ian Searle. Rlab (the language) is very high level and is intended to provide fast prototyping and program development, as well as easy data-visualization, and processing. Rlab was not designed as a clone of MATLAB. However, as Rlab (the program) is intended to provide a good experimental environment (or laboratory) in which to do matrix math, the programming language possesses similar operators and concepts and could be called _MATLAB-like_. Rlab borrows some of the best features of the MATLAB language but provides them through a different syntax that has been modified in order to be more expressive while reducing ambiguity. The variable scoping rules facilitate the creation of larger programs and re-usable program libraries. A heterogeneous associative array datatype has been added to allow users to create and operate on arbitrary data structures. The fundamental data type is the dense floating point matrix (either real or complex), though string and sparse numerical matrices (both real and complex) are also provided. Rlab 2.1 is no longer under active development. Binary versions are available for Linux and for Windows, and source code is available under the GPL. Rlab 2.2 has been released as a part of the project _**rlabplus**_ by Marijan Koštrun."
  },
  "432": {
    "label": "Ruby",
    "wikipedia_pageid": 25768,
    "inception": { "time": "+1995-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 3, 9, 21],
    "typing": [13, 1, 10],
    "description": "**Ruby** is an interpreted, high-level, general-purpose programming language. It was designed and developed in the mid-1990s by Yukihiro \"Matz\" Matsumoto in Japan. Ruby is dynamically typed and uses garbage collection and just-in-time compilation. It supports multiple programming paradigms, including procedural, object-oriented, and functional programming. According to the creator, Ruby was influenced by Perl, Smalltalk, Eiffel, Ada, BASIC, and Lisp."
  },
  "433": {
    "label": "Rust",
    "wikipedia_pageid": 29414838,
    "inception": { "time": "+2010-07-07T00:00:00Z", "precision": 11 },
    "paradigm": [3, 21, 6, 26, 16],
    "typing": [4, 6, 9, 11, 1],
    "description": "**Rust** is a multi-paradigm programming language designed for performance and safety, especially safe concurrency. Rust is syntactically similar to C++, but can guarantee memory safety by using a _borrow checker_ to validate references. Rust achieves memory safety without garbage collection, and reference counting is optional. Rust was originally designed by Graydon Hoare at Mozilla Research, with contributions from Dave Herman, Brendan Eich, and others. The designers refined the language while writing the Servo layout or browser engine, and the Rust compiler. It has gained increasing use in industry, and Microsoft has been experimenting with the language for secure and safety-critical software components. Rust has been voted the \"most loved programming language\" in the Stack Overflow Developer Survey every year since 2016."
  },
  "434": {
    "label": "S",
    "wikipedia_pageid": 919313,
    "inception": { "time": "+1976-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 3, 20],
    "typing": [10, 1],
    "description": "**S** is a statistical programming language developed primarily by John Chambers and (in earlier versions) Rick Becker and Allan Wilks of Bell Laboratories. The aim of the language, as expressed by John Chambers, is \"to turn ideas into software, quickly and faithfully\". The modern implementation of S is R, a part of the GNU free software project. S-PLUS, a commercial product, was formerly sold by TIBCO Software."
  },
  "435": {
    "label": "S/SL",
    "wikipedia_pageid": 485828,
    "inception": { "time": "+1980-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "The **Syntax/Semantic Language** (**S/SL**) is an executable high level specification language for recursive descent parsers, semantic analyzers and code generators developed by James Cordy, Ric Holt and David Wortman at the University of Toronto in 1980. S/SL is a small programming language that supports cheap recursion and defines input, output, and error token names (& values), semantic mechanisms (class interfaces whose methods are really escapes to routines in a host programming language but allow good abstraction in the pseudocode) and a pseudocode program that defines the syntax of the input language by the token stream the program accepts. Alternation, control flow and one-symbol look-ahead constructs are part of the language. The S/SL processor compiles this pseudocode into a table (byte-codes) that is interpreted by the S/SL table-walker (interpreter). The pseudocode language processes the input language in LL(1) recursive descent style but extensions allow it to process any LR(k) language relatively easily. S/SL is designed to provide excellent syntax error recovery and repair. It is more powerful and transparent than Yacc but can be slower. S/SL's \"semantic mechanisms\" extend its capabilities to all phases of compiling, and it has been used to implement all phases of compilation, including scanners, parsers, semantic analyzers, code generators and virtual machine interpreters in multi-pass language processors. S/SL has been used to implement production commercial compilers for languages such as PL/I, Euclid, Turing, Ada, and COBOL, as well as interpreters, command processors, and domain specific languages of many kinds. It is the primary technology used in IBM's ILE/400 COBOL compiler, and the ZMailer mail transfer agent uses S/SL for defining both its mail router processing language and its RFC 822 email address validation."
  },
  "436": {
    "label": "S2",
    "wikipedia_pageid": 439466,
    "inception": { "time": "+1999-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [],
    "description": "**S2 (Style System 2)** is an object-oriented programming language developed in the late 1990s by Brad Fitzpatrick, Martin \"Mart\" Atkins, and others for the online journaling service LiveJournal in order to allow users full control over the appearance of their pages. S2 source code is compiled into Perl, which the webserver can then execute directly for individual web page requests. The S2 system is, at its heart, completely general and can be used for almost any web application; however there exists no documentation for the implementation of S2 within other applications, which ties it relatively closely to LiveJournal. This article will make use of LiveJournal's implementation of S2 for examples. A link to detailed documentation about this implementation can be found at the bottom."
  },
  "437": {
    "label": "S3",
    "wikipedia_pageid": 11484588,
    "inception": null,
    "paradigm": [3, 36],
    "typing": [],
    "description": "**S3** is a structured, imperative high-level computer programming language. It was developed by the UK company International Computers Limited (ICL) for its 2900 Series mainframes. It is a system programming language with syntax influenced by ALGOL 68 but with data types and operators aligned to those offered by the 2900 Series. It was the implementation language of the operating system VME."
  },
  "438": {
    "label": "SA-C",
    "wikipedia_pageid": 8787221,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**Single Assignment C** (**SA-C**) (pronounced \"sassy\") is a member of the C programming language family designed to be directly and intuitively translatable into circuits, including FPGAs. To ease translation, SA-C does not include pointers and arithmetics thereon. To retain most of the expressiveness of C, SA-C instead features true n-dimensional arrays as first- class objects of the language."
  },
  "439": {
    "label": "Stanford Artificial Intelligence Language",
    "wikipedia_pageid": 481275,
    "inception": { "time": "+1970-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**SAIL**, the **Stanford Artificial Intelligence Language**, was developed by Dan Swinehart and Bob Sproull of the Stanford AI Lab in 1970. It was originally a large ALGOL 60-like language for the PDP-10 and DECSYSTEM-20. SAIL's main feature is a symbolic data system based upon an associative store (based on the LEAP system of Jerry Feldman and Paul Rovner). Items may be stored as unordered sets or as associations (triples). Other features include processes, events and interrupts, contexts, backtracking and record garbage collection. It also has block-structured macros, a coroutining facility and some new data types intended for building search trees and association lists. A number of interesting software systems were coded in SAIL, including some early versions of FTP and TeX, a document formatting system called PUB, and BRIGHT, a clinical database project sponsored by the National Institutes of Health. In 1978, there were half a dozen different operating systems for the PDP-10: ITS (MIT), WAITS (Stanford), TOPS-10 (DEC), CMU TOPS-10 (Carnegie Mellon), TENEX (BBN), Tymcom-X (Tymshare), and TOPS-20 (DEC, based on TENEX). SAIL was ported from WAITS to ITS so that MIT researchers could make use of software developed at Stanford University. Every port usually required the rewriting of I/O code in each application. A machine-independent version of SAIL called MAINSAIL was developed in the late 1970s and was used to develop many eCAD design tools during the 1980s. MAINSAIL was easily portable to new processors and operating systems, and was still in limited use as of 2005."
  },
  "440": {
    "label": "SASL",
    "wikipedia_pageid": 1298198,
    "inception": { "time": "+1972-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [21],
    "typing": [],
    "description": "**SASL** (from **S** t **A** ndrews **S** tatic **L** anguage, alternatively **S** t **A** ndrews **S** tandard **L** anguage) is a purely functional programming language developed by David Turner at the University of St Andrews in 1972, based on the applicative subset of ISWIM. In 1976 Turner redesigned and reimplemented it as a non-strict (lazy) language. In this form it was the foundation of Turner's later languages KRC and Miranda, but SASL appears to be untyped whereas Miranda has polymorphic types. Burroughs Corporation used SASL to write a compiler and operating system."
  },
  "441": {
    "label": "SETL",
    "wikipedia_pageid": 916963,
    "inception": { "time": "+1969-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 2, 3, 36],
    "typing": [10],
    "description": "**SETL** (SET Language) is a very high-level programming language based on the mathematical theory of sets. It was originally developed by (Jack) Jacob T. Schwartz at the New York University (NYU) Courant Institute of Mathematical Sciences in the late 1960s."
  },
  "442": {
    "label": "SIGNAL",
    "wikipedia_pageid": 32475185,
    "inception": { "time": "+1980-01-01T00:00:00Z", "precision": 8 },
    "paradigm": [13],
    "typing": [],
    "description": "**SIGNAL** is a programming language based on synchronized data-flow (flows + synchronization): a process is a set of equations on elementary flows describing both data and control. The SIGNAL formal model provides the capability to describe systems with several clocks (polychronous systems) as relational specifications. Relations are useful as partial specifications and as specifications of non- deterministic devices (for instance a non-deterministic bus) or external processes (for instance an unsafe car driver). Using SIGNAL allows one to specify an application, to design an architecture, to refine detailed components down to RTOS or hardware description. The SIGNAL model supports a design methodology which goes from specification to implementation, from abstraction to concretization, from synchrony to asynchrony. SIGNAL has been mainly developed in INRIAEspresso team since the 1980s, at the same time as similar programming languages, Esterel and Lustre."
  },
  "443": {
    "label": "SIMSCRIPT",
    "wikipedia_pageid": 1064164,
    "inception": { "time": "+1962-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**SIMSCRIPT** is a free-form, English-like general-purpose simulation language conceived by Harry Markowitz and Bernard Hausner at the RAND Corporation in 1962. It was implemented as a Fortran preprocessor on the IBM 7090 and was designed for large discrete event simulations. It influenced Simula. Though earlier versions were released into the public domain, SIMSCRIPT was commercialized by Markowitz's company, California Analysis Center, Inc. (CACI), which produced proprietary versions SIMSCRIPT I.5 and SIMSCRIPT II.5."
  },
  "444": {
    "label": "SISAL",
    "wikipedia_pageid": 57406,
    "inception": { "time": "+1983-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [22, 16, 21],
    "typing": [1, 11],
    "description": "**SISAL** (\"**Streams and Iteration in a Single Assignment Language**\") is a general-purpose single assignment functional programming language with strict semantics, implicit parallelism, and efficient array handling. SISAL outputs a dataflow graph in Intermediary Form 1 (IF1). It was derived from VAL (Value- oriented Algorithmic Language, designed by Jack Dennis), and adds recursion and finite streams. It has a Pascal-like syntax and was designed to be a common high-level language for numerical programs on a variety of multiprocessors."
  },
  "445": {
    "label": "SLIP",
    "wikipedia_pageid": 4449554,
    "inception": { "time": "+1960-01-01T00:00:00Z", "precision": 8 },
    "paradigm": [],
    "typing": [],
    "description": "**SLIP** is a list processing computer programming language, invented by Joseph Weizenbaum in the 1960s. The name _SLIP_ stands for **S** ymmetric **LI** st **P** rocessor. It was first implemented as an extension to the Fortran programming language, and later embedded into MAD and ALGOL. The best known program written in the language is ELIZA, an early natural language processing computer program created by Weizenbaum at the MIT Artificial Intelligence Laboratory."
  },
  "446": {
    "label": "SMALL",
    "wikipedia_pageid": 1808130,
    "inception": { "time": "+1980-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 2, 3, 36],
    "typing": [],
    "description": "**Small Machine Algol Like Language** (**SMALL**), is a computer programming language developed by Dr. Nevil Brownlee of the University of Auckland."
  },
  "447": {
    "label": "SNOBOL",
    "wikipedia_pageid": 29515,
    "inception": { "time": "+1962-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3],
    "typing": [],
    "description": "**SNOBOL** (\"StriNg Oriented and symBOlic Language\") is a series of programming languages developed between 1962 and 1967 at AT&T Bell Laboratories by David J. Farber, Ralph E. Griswold and Ivan P. Polonsky, culminating in SNOBOL4. It was one of a number of text-string-oriented languages developed during the 1950s and 1960s; others included COMIT and TRAC. SNOBOL4 stands apart from most programming languages of its era by having patterns as a first-class data type (_i.e._ a data type whose values can be manipulated in all ways permitted to any other data type in the programming language) and by providing operators for pattern concatenation and alternation. SNOBOL4 patterns are a type of object and admit various manipulations, much like later object-oriented languages such as JavaScript whose patterns are known as regular expressions. In addition SNOBOL4 strings generated during execution can be treated as programs and either interpreted or compiled and executed (as in the eval function of other languages). SNOBOL4 was quite widely taught in larger US universities in the late 1960s and early 1970s and was widely used in the 1970s and 1980s as a text manipulation language in the humanities. In the 1980s and 1990s its use faded as newer languages such as AWK and Perl made string manipulation by means of regular expressions fashionable. SNOBOL4 patterns subsume BNF grammars, which are equivalent to context-free grammars and more powerful than regular expressions. The \"regular expressions\" in current versions of AWK and Perl are in fact extensions of regular expressions in the traditional sense, but regular expressions, unlike SNOBOL4 patterns, are not recursive, which gives a distinct computational advantage to SNOBOL4 patterns. (Recursive expressions did appear in Perl 5.10, though, released in December 2007.) The later SL5 (1977) and Icon (1978) languages were designed by Griswold to combine the backtracking of SNOBOL4 pattern matching with more standard ALGOL- like structuring."
  },
  "448": {
    "label": "SP/k",
    "wikipedia_pageid": 827334,
    "inception": { "time": "+1974-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3, 36],
    "typing": [1, 11],
    "description": "**SP/k** is a programming language developed circa 1974 by R.C. Holt, D.B. Wortman, D.T. Barnard and J.R. Cordy as a subset of the PL/I programming language designed for teaching programming. It was used for about a decade at over 40 universities, schools, and research laboratories in Canada and the United States. SP/k was one of the first languages specifically designed to encourage structured programming. The features of SP/k were chosen to encourage structured problem solving by computers, to make the language easy to learn and use, to eliminate confusing and redundant constructs, and to make the language easy to compile. The resulting language was suitable for introducing programming concepts used in various applications, including business data processing, scientific calculations and non-numeric computation. SP/k is actually a sequence of language subsets called SP/1, SP/2, ... SP/8. Each subset introduces new programming language constructs while retaining all the constructs of preceding subsets, forming a stepwise system for teaching computer programming. Each subset is precisely defined and self-contained, and can be learned or implemented without the following subsets. This allows for various levels of programming education. The design and philosophy of SP/k was a strong influence on the Turing programming language."
  },
  "449": {
    "label": "SPARK",
    "wikipedia_pageid": 291874,
    "inception": { "time": "+1988-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2],
    "typing": [1, 4, 11],
    "description": "**SPARK** is a formally defined computer programming language based on the Ada programming language, intended for the development of high integrity software used in systems where predictable and highly reliable operation is essential. It facilitates the development of applications that demand safety, security, or business integrity. Originally, there were three versions of the SPARK language (SPARK83, SPARK95, SPARK2005) based on Ada 83, Ada 95 and Ada 2005 respectively. A fourth version of the SPARK language, SPARK 2014, based on Ada 2012, was released on April 30, 2014. SPARK 2014 is a complete re-design of the language and supporting verification tools. The SPARK language consists of a well-defined subset of the Ada language that uses contracts to describe the specification of components in a form that is suitable for both static and dynamic verification. In SPARK83/95/2005, the contracts are encoded in Ada comments and so are ignored by any standard Ada compiler, but are processed by the SPARK \"Examiner\" and its associated tools. SPARK 2014, in contrast, uses Ada 2012's built-in \"aspect\" syntax to express contracts, bringing them into the core of the language. The main tool for SPARK 2014 (GNATprove) is based on the GNAT/GCC infrastructure, and re-uses almost the entirety of the GNAT Ada 2012 front-end."
  },
  "450": {
    "label": "Structured Query Language",
    "wikipedia_pageid": 29004,
    "inception": { "time": "+1974-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [13],
    "typing": [1, 11],
    "description": "**SQL** ( (listen) _S-Q-L_,  \"sequel\"; **Structured Query Language**) is a domain-specific language used in programming and designed for managing data held in a relational database management system (RDBMS), or for stream processing in a relational data stream management system (RDSMS). It is particularly useful in handling structured data, i.e. data incorporating relations among entities and variables. SQL offers two main advantages over older read–write APIs such as ISAM or VSAM. Firstly, it introduced the concept of accessing many records with one single command. Secondly, it eliminates the need to specify _how_ to reach a record, e.g. with or without an index. Originally based upon relational algebra and tuple relational calculus, SQL consists of many types of statements, which may be informally classed as sublanguages, commonly: a data query language (DQL), a data definition language (DDL), a data control language (DCL), and a data manipulation language (DML). The scope of SQL includes data query, data manipulation (insert, update and delete), data definition (schema creation and modification), and data access control. Although SQL is essentially a declarative language (4GL), it also includes procedural elements. SQL was one of the first commercial languages to use Edgar F. Codd’s relational model. The model was described in his influential 1970 paper, \"A Relational Model of Data for Large Shared Data Banks\". Despite not entirely adhering to the relational model as described by Codd, it became the most widely used database language. SQL became a standard of the American National Standards Institute (ANSI) in 1986, and of the International Organization for Standardization (ISO) in 1987. Since then, the standard has been revised to include a larger set of features. Despite the existence of standards, most SQL code requires at least some changes before being ported to different database systems."
  },
  "451": {
    "label": "SQR",
    "wikipedia_pageid": 1862060,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**SQR** (Hyperion SQR Production Reporting, Part of OBIEE) is a programming language designed for generating reports from database management systems. The name is an abbreviation of Structured Query Reporter, which suggests its relationship to SQL (Structured Query Language). Any SQL statement can be embedded in an SQR program."
  },
  "452": {
    "label": "SR",
    "wikipedia_pageid": 485875,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**SR** (short for **Synchronizing Resources**) is a programming language designed for concurrent programming. _Resources_ encapsulate processes and the variables they share, and can be separately compiled. _Operations_ provide the primary mechanism for process interaction. SR provides a novel integration of the mechanisms for invoking and servicing operations. Consequently, it supports local and remote procedure call, rendezvous, message passing, dynamic process creation, multicast, semaphores and shared memory. Version 2.2 has been ported to the Apollo, DECstation, Data General AViiON, HP 9000 Series 300, Multimax, NeXT, PA-RISC, RS/6000, Sequent Symmetry, SGI IRIS, Sun-3, Sun-4 and others."
  },
  "453": {
    "label": "SYMPL",
    "wikipedia_pageid": 5029025,
    "inception": null,
    "paradigm": [2, 3, 36],
    "typing": [],
    "description": "**SYMPL** is an obsolete programming language developed by the Control Data Corporation (CDC) for use on the CDC 6000 series computer systems in the 1970s and 1980s. It was based on a subset of CDCs version of JOVIAL, as an alternative to assembly language. A number of important CDC software products were implemented in SYMPL, including compilers, libraries, a full-screen editor, and major subsystems. SYMPL is a compiled, imperative, and procedural language. Compared to the Fortran of the day, SYMPL supports:   * Stronger data typing - All variables must be declared prior to use,   * Data structures - Including \"based\" dynamically allocated structures,   * Structured programming constructs,   * Nested procedures,   * In-fix \"bead\" (bit) and character manipulation   * A simple macro facility Simplifications compared to JOVIAL include: fewer built-in data types, no recursive calls to procedures, and no `COMPOOL` concept."
  },
  "454": {
    "label": "SabreTalk",
    "wikipedia_pageid": 531030,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**SabreTalk** is a discontinued dialect of PL/I for the S/360 IBM mainframes running the TPF platform. SabreTalk was developed jointly by American Airlines, Eastern Air Lines and IBM. SabreTalk is known as PL/TPF (Programming Language for TPF). SabreTalk programs still run in the British Airways Flight Operations system (FICO) under ALCS, using a commercially available automatic converter to translate SabreTalk programs to C programs. Both the Reservations and Operations Support System (OSS) of Delta Air Lines were developed using both SabreTalk and IBM 360 Assembler. Although development is currently restricted to C++, the majority of Delta's programming platform remained in Sabretalk until recently in the 2010s. Because of the availability of translators from SabreTalk to C and because it is no longer supported by the original developers, several companies are beginning the move away from SabreTalk to purely C-based programs. Code Sample:"
  },
  "455": {
    "label": "Sather",
    "wikipedia_pageid": 28763,
    "inception": { "time": "+1990-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 21],
    "typing": [1, 11],
    "description": "_For people with the surname, see Sather (surname)._ **Sather** is an object-oriented programming language. It originated circa 1990 at the International Computer Science Institute (ICSI) at the University of California, Berkeley, developed by an international team led by Steve Omohundro. It supports garbage collection and generics by subtypes. Originally, it was based on Eiffel, but it has diverged, and now includes several functional programming features. The name is inspired by Eiffel; the Sather Tower is a recognizable landmark at Berkeley, named after Jane Krom Sather, the widow of Peder Sather, who donated large sums to the foundation of the university. Sather also takes inspiration from other programming languages and paradigms: iterators, design by contract, abstract classes, multiple inheritance, anonymous functions, operator overloading, contravariant type system. The original Berkeley implementation (last stable version 1.1 was released in 1995, no longer maintained) has been adopted by the Free Software Foundation therefore becoming GNU Sather. Last stable GNU version (1.2.3) was released in July 2007 and the software is currently not maintained. There were several other variants: Sather-K from the University of Karlsruhe; Sather-W from the University of Waikato (implementation of Sather version 1.3); Peter Naulls' port of ICSI Sather 1.1 to RISC OS; and pSather, a parallel version of ICSI Sather addressing non-uniform memory access multiprocessor architectures but presenting a shared memory model to the programmer. The former ICSI Sather compiler (now GNU Sather) is implemented as a compiler to C, i.e., the compiler does not output object or machine code, but takes Sather source code and generates C source code as an intermediate language. Optimizing is left to the C compiler. The GNU Sather compiler, written in Sather itself, is dual licensed under the GNU GPL & LGPL."
  },
  "456": {
    "label": "Sawzall",
    "wikipedia_pageid": 12640293,
    "inception": { "time": "+2003-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2],
    "typing": [],
    "description": "**Sawzall** is a procedural domain-specific programming language, used by Google to process large numbers of individual log records. Sawzall was first described in 2003, and the szl runtime was open-sourced in August 2010. However, since the MapReduce table aggregators have not been released, the open-sourced runtime is not useful for large-scale data analysis of multiple log files off the shelf. Sawzall has been replaced by Lingo (logs in Go) for most purposes within Google."
  },
  "457": {
    "label": "Scala",
    "wikipedia_pageid": 3254510,
    "inception": { "time": "+2004-01-20T00:00:00Z", "precision": 11 },
    "paradigm": [6, 3, 16, 21],
    "typing": [1, 12, 6, 11],
    "description": "**Scala** (_SKAH -lah_) is a strong statically typed general-purpose programming language which supports both object-oriented programming and functional programming. Designed to be concise, many of Scala's design decisions are aimed to address criticisms of Java. Scala source code can be compiled to Java bytecode and run on a Java virtual machine (JVM). Scala provides language interoperability with Java so that libraries written in either language may be referenced directly in Scala or Java code. Like Java, Scala is object-oriented, and uses a syntax termed _curly-brace_ which is similar to the language C. Since Scala 3, there is also an option to use the off-side rule (indenting) to structure blocks, and its use is advised. Martin Odersky has said that this turned out to be the most productive change introduced in Scala 3. Unlike Java, Scala has many features of functional programming languages like Scheme, Standard ML, and Haskell, including currying, immutability, lazy evaluation, and pattern matching. It also has an advanced type system supporting algebraic data types, covariance and contravariance, higher-order types (but not higher-rank types), and anonymous types. Other features of Scala not present in Java include operator overloading, optional parameters, named parameters, and raw strings. Conversely, a feature of Java not in Scala is checked exceptions, which has proved controversial. The name Scala is a blend of _scalable_ and _language_, signifying that it is designed to grow with the demands of its users."
  },
  "458": {
    "label": "Scheme",
    "wikipedia_pageid": 28119,
    "inception": { "time": "+1975-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [25, 2, 3, 21],
    "typing": [10, 1],
    "description": "**Scheme** is a minimalist dialect of the Lisp family of programming languages. Scheme consists of a small standard core with several tools for language extension. Scheme was created during the 1970s at the MIT AI Lab and released by its developers, Guy L. Steele and Gerald Jay Sussman, via a series of memos now known as the Lambda Papers. It was the first dialect of Lisp to choose lexical scope and the first to require implementations to perform tail-call optimization, giving stronger support for functional programming and associated techniques such as recursive algorithms. It was also one of the first programming languages to support first-class continuations. It had a significant influence on the effort that led to the development of Common Lisp. The Scheme language is standardized in the official IEEE standard and a _de facto_ standard called the _Revised n Report on the Algorithmic Language Scheme_ (R _n_ RS). The most widely implemented standard is R5RS (1998). The most recent standard, R7RS, provides \"small\" and \"large\" versions of the Scheme language; the \"small\" language standard was ratified in 2013. Scheme has a diverse user base due to its compactness and elegance, but its minimalist philosophy has also caused wide divergence between practical implementations, so much that the Scheme Steering Committee calls it \"the world's most unportable programming language\" and \"a _family_ of dialects\" rather than a single language."
  },
  "459": {
    "label": "Scilab",
    "wikipedia_pageid": 153563,
    "inception": null,
    "paradigm": [20],
    "typing": [10],
    "description": "**Scilab** is a free and open-source, cross-platform numerical computational package and a high-level, numerically oriented programming language. It can be used for signal processing, statistical analysis, image enhancement, fluid dynamics simulations, numerical optimization, and modeling, simulation of explicit and implicit dynamical systems and (if the corresponding toolbox is installed) symbolic manipulations. Scilab is one of the two major open-source alternatives to MATLAB, the other one being GNU Octave. Scilab puts less emphasis on syntactic compatibility with MATLAB than Octave does, but it is similar enough that some authors suggest that it is easy to transfer skills between the two systems."
  },
  "460": {
    "label": "Scratch",
    "wikipedia_pageid": 9236158,
    "inception": { "time": "+2003-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [12, 10],
    "typing": [],
    "description": "**Scratch** is a high-level block-based visual programming language and website targeted primarily at children 8-16 as an educational tool for coding. Users of the site can create projects on the web using a block-like interface. The service is developed by the MIT Media Lab, has been translated into 70+ languages, and is used in most parts of the world. Scratch is taught and used in after-school centers, schools, and colleges, as well as other public knowledge institutions. As of May 2021, community statistics on the language's official website show more than 79 million projects shared by over 72 million users, and almost 38 million monthly website visits. Scratch takes its name from a technique used by disk jockeys called \"scratching\", where vinyl records are clipped together and manipulated on a turntable to produce different sound effects and music. Like scratching, the website lets users mix together different media (including graphics, sound, and other programs) in creative ways by creating and remixing projects, like video games, animations, and simulations."
  },
  "461": {
    "label": "Script.NET",
    "wikipedia_pageid": 13819923,
    "inception": null,
    "paradigm": [25, 3],
    "typing": [10],
    "description": "**Script.NET** or **S#** is a metaprogramming language that provides scripting functionality in Microsoft .NET applications, allowing runtime execution of custom functionality, similar to VBA in Microsoft Office applications. The syntax of Script.NET is similar to JavaScript. It is designed to be simple and efficient scripting language allowing to customize .NET applications. The language has a true runtime interpreter, and it is executed without generating additional in-memory assemblies. Script.NET is an open-source project."
  },
  "462": {
    "label": "scripting language",
    "wikipedia_pageid": 21490336,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "A **scripting language** or **script language** is a programming language for a runtime system that automates the execution of tasks that would otherwise be performed individually by a human operator. Scripting languages are usually interpreted at runtime rather than compiled. A scripting language's primitives are usually elementary tasks or API calls, and the scripting language allows them to be combined into more programs. Environments that can be automated through scripting include application softwares, text editors, web pages, operating system shells, embedded systems, and computer games. A scripting language can be viewed as a domain-specific language for a particular environment; in the case of scripting an application, it is also known as an **extension language**. Scripting languages are also sometimes referred to as very high-level programming languages, as they sometimes operate at a high level of abstraction, or as **control languages**, particularly for job control languages on mainframes. The term \"scripting language\" is also used loosely to refer to dynamic high- level general-purpose interpreted languages, such as Perl, PowerShell, Python, and Tcl, with the term \"script\" often used for small programs (up to a few thousand lines of code) in such languages, or in domain-specific languages such as the text-processing languages sed and AWK. Some of these languages were originally developed for use within a particular environment, and later developed into portable domain-specific or general-purpose languages. Conversely, many general-purpose languages have dialects that are used as scripting languages. This article discusses scripting languages in the narrow sense of languages for a specific environment. The spectrum of scripting languages ranges from very small and highly domain- specific languages to general-purpose programming languages used for scripting. Standard examples of scripting languages for specific environments include: Bash, for the Unix or Unix-like operating systems; ECMAScript (JavaScript), for web browsers; and Visual Basic for Applications, for Microsoft Office applications. Lua is a language designed and widely used as an extension language. Perl is a general-purpose language that is also commonly used as an extension language, while ECMAScript is still primarily a scripting language for web browsers, but is also used as a general-purpose language. The Emacs Lisp dialect of Lisp (for the Emacs editor) and the Visual Basic for Applications dialect of Visual Basic are examples of scripting language dialects of general-purpose languages. Some game systems, notably the Second Life virtual world and the Trainz franchise of Railroad simulators have been extensively extended in functionality by scripting extensions (Linden Scripting Language and TrainzScript). In other games like Wesnoth, the variety of actual games played by players are scripts written by other users."
  },
  "463": {
    "label": "Secure Operations Language",
    "wikipedia_pageid": 4536722,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "The **Secure Operations Language** (**SOL**) was developed jointly by the United States Naval Research Laboratory and Utah State University in the United States. SOL is a domain-specific synchronous programming language for developing distributed applications and is based on software engineering principles developed in the Software Cost Reduction project at the Naval Research Laboratory in the late 1970s and early 1980s. SOL is intended to be a domain-specific language for developing service-based systems. Concurrently, a domain-specific extension of Java (SOLj) is being developed (FTDCS 2007) Application domains include sensor networks, defense and space systems, healthcare delivery, power control, etc. The investigators of the project are Dr. Ramesh Bharadwaj from the Naval Research Laboratory and Dr. Supratik Mukhopadhyay from Utah State University."
  },
  "464": {
    "label": "sed",
    "wikipedia_pageid": 27163,
    "inception": { "time": "+1974-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [1],
    "typing": [],
    "description": "**sed** (\"stream editor\") is a Unix utility that parses and transforms text, using a simple, compact programming language. sed was developed from 1973 to 1974 by Lee E. McMahon of Bell Labs, and is available today for most operating systems. sed was based on the scripting features of the interactive editor ed (\"editor\", 1971) and the earlier qed (\"quick editor\", 1965–66). sed was one of the earliest tools to support regular expressions, and remains in use for text processing, most notably with the substitution command. Popular alternative tools for plaintext string manipulation and \"stream editing\" include AWK and Perl."
  },
  "465": {
    "label": "Seed7",
    "wikipedia_pageid": 36346048,
    "inception": { "time": "+2005-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3, 6, 26, 9, 36],
    "typing": [1, 14, 4, 11],
    "description": "**Seed7** is an extensible general-purpose programming language designed by Thomas Mertes. It is syntactically similar to Pascal and Ada. Along with many other features, it provides an extension mechanism. Seed7 supports introducing new syntax elements and their semantics into the language, and allows new language constructs to be defined and written in Seed7. For example, programmers can introduce syntax and semantics of new statements and user defined operator symbols. The implementation of Seed7 differs significantly from that of languages with hard-coded syntax and semantics."
  },
  "466": {
    "label": "Self",
    "wikipedia_pageid": 60265,
    "inception": { "time": "+1987-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 14],
    "typing": [10, 1],
    "description": "**Self** is an object-oriented programming language based on the concept of _prototypes_. Self began as a dialect of Smalltalk, being dynamically typed and using just-in-time compilation (JIT) as well as the prototype-based approach to objects: it was first used as an experimental test system for language design in the 1980s and 1990s. In 2006, Self was still being developed as part of the Klein project, which was a Self virtual machine written fully in Self. The latest version is 2017.1 released in May 2017. Several just-in-time compilation techniques were pioneered and improved in Self research as they were required to allow a very high level object oriented language to perform at up to half the speed of optimized C. Much of the development of Self took place at Sun Microsystems, and the techniques they developed were later deployed for Java's HotSpot virtual machine. At one point a version of Smalltalk was implemented in Self. Because it was able to use the JIT, this also gave extremely good performance."
  },
  "467": {
    "label": "SenseTalk",
    "wikipedia_pageid": 9096092,
    "inception": { "time": "+1992-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [13],
    "description": "**SenseTalk** is a high-level English-like scripting language in the XTalk family, that supports both procedural and object-oriented paradigms. SenseTalk scripts are intended to be largely readable by ordinary people, including those with little to no training in programming. To this end, SenseTalk includes a number of language elements that provide functionality oriented towards human tasks rather than the underlying machine behavior. For example, to check whether a quantity is divisible by 3, the script could use the expression “`if quantity is divisible by 3 …`” or “`if quantity is a multiple of 3 …`”, with the emphasis being on readability and a focus on the human concept of divisibility. Compare this to more traditional programming languages (C, Java, Python, etc.) where the same test would typically be written as “`if (quantity % 3) == 0 …`” , with the focus being on the machine operations needed to determine the result. This shift in focus away from the underlying machine computation, towards an English-like description of the behavior in human terms leads to the description of SenseTalk as a “People Oriented Programming language”."
  },
  "468": {
    "label": "SequenceL",
    "wikipedia_pageid": 37895661,
    "inception": { "time": "+1989-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [29, 20, 13, 7],
    "typing": [6, 11],
    "description": "**SequenceL** is a general purpose functional programming language and auto- parallelizing (Parallel computing) compiler and tool set, whose primary design objectives are performance on multi-core processor hardware, ease of programming, platform portability/optimization, and code clarity and readability. Its main advantage is that it can be used to write straightforward code that automatically takes full advantage of all the processing power available, without programmers needing to be concerned with identifying parallelisms, specifying vectorization, avoiding race conditions, and other challenges of manual directive-based programming approaches such as OpenMP. Programs written in SequenceL can be compiled to multithreaded code that runs in parallel, with no explicit indications from a programmer of how or what to parallelize. As of 2015, versions of the SequenceL compiler generate parallel code in C++ and OpenCL, which allows it to work with most popular programming languages, including C, C++, C#, Fortran, Java, and Python. A platform- specific runtime manages the threads safely, automatically providing parallel performance according to the number of cores available, currently supporting x86, POWER8, and ARM platforms."
  },
  "469": {
    "label": "shell script",
    "wikipedia_pageid": 28938,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "A **shell script** is a computer program designed to be run by the Unix shell, a command-line interpreter. The various dialects of shell scripts are considered to be scripting languages. Typical operations performed by shell scripts include file manipulation, program execution, and printing text. A script which sets up the environment, runs the program, and does any necessary cleanup, logging, etc. is called a **wrapper**. The term is also used more generally to mean the automated mode of running an operating system shell; in specific operating systems they are called other things such as batch files (MSDos-Win95 stream, OS/2), command procedures (VMS), and shell scripts (Windows NT stream and third-party derivatives like 4NT—article is at cmd.exe), and mainframe operating systems are associated with a number of terms. The typical Unix/Linux/POSIX-compliant installation includes the KornShell (`ksh`) in several possible versions such as ksh88, Korn Shell '93 and others. The oldest shell still in common use is the Bourne shell (`sh`); Unix systems invariably also include the C shell (`csh`), Bash (`bash`), a Remote Shell (`rsh`), a Secure Shell (`ssh`) for SSL telnet connections, and a shell which is a main component of the Tcl/Tk installation usually called `tclsh`; wish is a GUI-based Tcl/Tk shell. The C and Tcl shells have syntax quite similar to that of said programming languages, and the Korn shells and Bash are developments of the Bourne shell, which is based on the ALGOL language with elements of a number of others added as well. On the other hand, the various shells plus tools like awk, sed, grep, and BASIC, Lisp, C and so forth contributed to the Perl programming language. Other shells available on a machine or available for download and/or purchase include Almquist shell (`ash`), PowerShell (`msh`), Z shell (`zsh`, a particularly common enhanced KornShell), the Tenex C Shell (`tcsh`), and a Perl-like shell (`psh`). Related programs such as shells based on Python, Ruby, C, Java, Perl, Pascal, Rexx etc. in various forms are also widely available. Another somewhat common shell is Old shell (`osh`), whose manual page states it \"is an enhanced, backward-compatible port of the standard command interpreter from Sixth Edition UNIX.\" Windows-Unix interoperability software such as the MKS Toolkit, Cygwin, UWIN, Interix and others make the above shells and Unix programming available on Windows systems, providing functionality all the way down to signals and other inter-process communication, system calls and APIs. The Hamilton C shell is a Windows shell that is very similar to the Unix C Shell. Microsoft distributed Windows Services for UNIX for use with its NT-based operating systems in particular, which have a POSIX environmental subsystem."
  },
  "470": {
    "label": "Short Code",
    "wikipedia_pageid": 5276950,
    "inception": { "time": "+1950-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2],
    "typing": [],
    "description": "**Short Code** was one of the first higher-level languages ever developed for an electronic computer. Unlike machine code, Short Code statements represented mathematic expressions rather than a machine instruction. Also known as an automatic programming, the source code was not compiled but executed through an interpreter to simplify the programming process; the execution time was much slower though."
  },
  "471": {
    "label": "SiMPLE",
    "wikipedia_pageid": 39282074,
    "inception": { "time": "+1995-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**SiMPLE** (a recursive acronym for SiMPLE Modular Programming Language & Environment) is a programming development system that was created to provide easy programming capabilities for everybody, especially non-professionals. Following the death of SiMPLE creator Bob Bishop, the SiMPLE Codeworks website and forums are now offline, however they can be accessed via the internet archive archive.org."
  },
  "472": {
    "label": "Simula",
    "wikipedia_pageid": 29513,
    "inception": { "time": "+1962-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 2, 3, 36],
    "typing": [4, 11],
    "description": "**Simula** is the name of two simulation programming languages, Simula I and Simula 67, developed in the 1960s at the Norwegian Computing Center in Oslo, by Ole-Johan Dahl and Kristen Nygaard. Syntactically, it is a fairly faithful superset of ALGOL 60, also influenced by the design of Simscript. Simula 67 introduced objects, classes, inheritance and subclasses, virtual procedures, coroutines, and discrete event simulation, and features garbage collection. Also other forms of subtyping (besides inheriting subclasses) were introduced in Simula derivatives. Simula is considered the first object-oriented programming language. As its name suggests, the first Simula version by 1962 was designed for doing simulations; Simula 67 though was designed to be a general-purpose programming language and provided the framework for many of the features of object- oriented languages today. Simula has been used in a wide range of applications such as simulating very- large-scale integration (VLSI) designs, process modeling, communication protocols, algorithms, and other applications such as typesetting, computer graphics, and education. The influence of Simula is often understated, and Simula-type objects are reimplemented in C++, Object Pascal, Java, C#, and many other languages. Computer scientists such as Bjarne Stroustrup, creator of C++, and James Gosling, creator of Java, have acknowledged Simula as a major influence."
  },
  "473": {
    "label": "Simulink",
    "wikipedia_pageid": 562695,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**Simulink** is a MATLAB-based graphical programming environment for modeling, simulating and analyzing multidomain dynamical systems. Its primary interface is a graphical block diagramming tool and a customizable set of block libraries. It offers tight integration with the rest of the MATLAB environment and can either drive MATLAB or be scripted from it. Simulink is widely used in automatic control and digital signal processing for multidomain simulation and model-based design."
  },
  "474": {
    "label": "Smalltalk",
    "wikipedia_pageid": 28319,
    "inception": { "time": "+1972-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 0],
    "typing": [10, 1],
    "description": "**Smalltalk** is an object-oriented, dynamically typed reflective programming language. Smalltalk was created as the language underpinning the \"new world\" of computing exemplified by \"human–computer symbiosis\". It was designed and created in part for educational use, specifically for constructionist learning, at the Learning Research Group (LRG) of Xerox PARC by Alan Kay, Dan Ingalls, Adele Goldberg, Ted Kaehler, Diana Merry, Scott Wallace, and others during the 1970s. The language was first generally released as Smalltalk-80. Smalltalk-like languages are in active development and have gathered loyal communities of users around them. ANSI Smalltalk was ratified in 1998 and represents the standard version of Smalltalk. Smalltalk took second place for \"most loved programming language\" in the Stack Overflow Developer Survey in 2017, but it was not among the 26 most loved programming languages of the 2018 survey."
  },
  "475": {
    "label": "Snap!",
    "wikipedia_pageid": 34236881,
    "inception": { "time": "+2011-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 12],
    "typing": [10],
    "description": "**Snap _!_** (formerly Build Your Own Blocks or BYOB) is a free, block-based educational graphical programming language and online community aimed at students to explore, create and re-mix interactive animations, games, stories, and more, while learning about mathematical and computational ideas. While inspired by Scratch, Snap _!_ has many advanced features. The Snap _!_ editor, and programs created in it, are web applications that run in the browser (like Scratch 2 and 3) without requiring installation."
  },
  "476": {
    "label": "Snowball",
    "wikipedia_pageid": 919808,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**Snowball** is a small string processing programming language designed for creating stemming algorithms for use in information retrieval. The Snowball compiler translates a Snowball script (a .sbl file) into program in thread-safe ANSI C, Java, Ada, C#, Go, Javascript, Object Pascal, Python or Rust. For ANSI C, each Snowball script produces a program file and corresponding header file (with .c and .h extensions). The Snowball compiler checks the consistency of its script, and this check was used to discover a typo in a seminal academic paper by Lovins which had remained undetected for 30 years. The basic datatypes handled by Snowball are strings of characters, signed integers, and boolean truth values, or more simply strings, integers and booleans. Snowball's characters are either 8-bit wide, or 16-bit, depending on the mode of use. In particular, both ASCII and 16-bit Unicode are supported. Like the SNOBOL programming language, the flow of control in Snowball is arranged by the implicit use of signals (each statement returns a true or false value), rather than the explicit use of constructs such as if, then, and break found in C and many other programming languages. The name Snowball was chosen as a tribute to the SNOBOL programming language, with which it shares the concept of string patterns delivering signals that are used to control the flow of the program. The creator of Snowball, Dr. Martin Porter, \"toyed with the idea of calling it 'strippergram' \", because it \"effectively provides a 'suffix STRIPPER GRAMmar' \"."
  },
  "477": {
    "label": "solidity",
    "wikipedia_pageid": 6817996,
    "inception": { "time": "+2014-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [11],
    "description": "**Solidity** is an object-oriented programming language for writing smart contracts. It is used for implementing smart contracts on various blockchain platforms, most notably, Ethereum. It was developed by Christian Reitwiessner, Alex Beregszaszi, and several former Ethereum core contributors to enable writing smart contracts on blockchain platforms such as Ethereum. The programs compiled by the Solidity are intended to be run on Ethereum Virtual Machine."
  },
  "478": {
    "label": "Source",
    "wikipedia_pageid": 62661728,
    "inception": { "time": "+2017-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 21],
    "typing": [13, 10],
    "description": "**Source** is a family of sublanguages of JavaScript, developed for the textbook Structure and Interpretation of Computer Programs, JavaScript Adaptation (SICP JS). The JavaScript sublanguages Source §1, Source §2, Source §3 and Source §4 are designed to be just expressive enough to support all examples of the respective chapter of the textbook."
  },
  "479": {
    "label": "Speakeasy",
    "wikipedia_pageid": 24641580,
    "inception": { "time": "+1964-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3],
    "typing": [10],
    "description": "**Speakeasy** was a numerical computing interactive environment also featuring an interpreted programming language. It was initially developed for internal use at the Physics Division of Argonne National Laboratory by the theoretical physicist Stanley Cohen. He eventually founded Speakeasy Computing Corporation to make the program available commercially. Speakeasy is a very long-lasting numerical package. In fact, the original version of the environment was built around a core dynamic data repository called \"Named storage\" developed in the early 1960s, while the most recent version has been released in 2006. Speakeasy was aimed to make the computational work of the physicists at the Argonne National Laboratory easier. It was initially conceived to work on mainframes (the only kind of computers at that time), and was subsequently ported to new platforms (minicomputers, personal computers) as they became available. The porting of the same code on different platforms was made easier by using Mortran metalanguage macros to face systems dependencies and compilers deficiencies and differences. Speakeasy is currently available on several platforms: PCs running Windows, macOS, Linux, departmental computers and workstations running several flavors of Linux, AIX or Solaris. Speakeasy was also among the first interactive numerical computing environments, having been implemented in such a way on a CDC 3600 system, and later on IBM TSO machines as one was in beta-testing at the Argonne National Laboratory at the time. Almost since the beginning (as the dynamic linking functionality was made available in the operating systems) Speakeasy features the capability of expanding its operational vocabulary using separated modules, dynamically linked to the core processor as they are needed. For that reason such modules were called \"linkules\" (LINKable-modULES). They are functions with a generalized interface, which can be written in FORTRAN or in C. The independence of each of the new modules from the others and from the main processor is of great help in improving the system, especially it was in the old days. This easy way of expanding the functionalities of the main processor was often exploited by the users to develop their own specialized packages. Besides the programs, functions and subroutines the user can write in the Speakeasy's own interpreted language, linkules add functionalities carried out with the typical performances of compiled programs. Among the packages developed by the users, one of the most important is \"Modeleasy\", originally developed as \"FEDeasy\" in the early 1970s at the research department of the Federal Reserve Board of Governors in Washington D.C.. Modeleasy implements special objects and functions for large econometric models estimation and simulation. Its evolution led eventually to its distribution as an independent product."
  },
  "480": {
    "label": "Speedcoding",
    "wikipedia_pageid": 6616312,
    "inception": { "time": "+1953-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 2, 26, 36],
    "typing": [1, 14, 11],
    "description": "**Speedcoding** or **Speedcode** was the first high-level programming language created for an IBM computer. The language was developed by John Backus in 1953 for the IBM 701 to support computation with floating point numbers. The idea arose from the difficulty of programming the IBM SSEC machine when Backus was hired to calculate astronomical positions in early 1950. The speedcoding system was an interpreter and focused on ease of use at the expense of system resources. It provided pseudo-instructions for common mathematical functions: logarithms, exponentiation, and trigonometric operations. The resident software analyzed pseudo-instructions one by one and called the appropriate subroutine. Speedcoding was also the first implementation of decimal input/output operations. Although it substantially reduced the effort of writing many jobs, the running time of a program that was written with the help of Speedcoding was usually ten to twenty times that of machine code. The interpreter took 310 memory words, about 30% of the memory available on a 701."
  },
  "481": {
    "label": "Squeak",
    "wikipedia_pageid": 37426,
    "inception": { "time": "+1996-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [10],
    "description": "**Squeak** is an object-oriented, class-based, and reflective programming language. It was derived from Smalltalk-80 by a group that included some of Smalltalk-80's original developers, initially at Apple Computer, then at Walt Disney Imagineering, where it was intended for use in internal Disney projects. The group would later go on to be supported by HP labs, SAP, and most recently, Y Combinator. Squeak runs on a virtual machine (VM), allowing for a high degree of portability. The Squeak system includes code for generating a new version of the VM on which it runs, along with a VM simulator written in Squeak."
  },
  "482": {
    "label": "Squirrel",
    "wikipedia_pageid": 2819069,
    "inception": { "time": "+2003-09-06T00:00:00Z", "precision": 11 },
    "paradigm": [6, 2, 3, 0],
    "typing": [10],
    "description": "**Squirrel** is a high level imperative, object-oriented programming language, designed to be a lightweight scripting language that fits in the size, memory bandwidth, and real-time requirements of applications like video games and embedded systems. MirthKit, a simple toolkit for making and distributing open source, cross- platform 2D games, uses Squirrel for its platform. It is used extensively by Code::Blocks for scripting and was also used in _Final Fantasy Crystal Chronicles: My Life as a King_. It is also used in _Left 4 Dead 2_,_Portal 2_ and _Thimbleweed Park_ for scripted events and in NewDark, an unofficial Thief 2: The Metal Age engine update, to facilitate additional, simplified means of scripting mission events, aside of the regular C scripting."
  },
  "483": {
    "label": "Standard ML",
    "wikipedia_pageid": 100337,
    "inception": { "time": "+1983-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 21, 18],
    "typing": [1, 6, 11],
    "description": "**Standard ML** (**SML**) is a general-purpose modular functional programming language with compile-time type checking and type inference. It is popular among compiler writers and programming language researchers, as well as in the development of theorem provers. Standard ML is a modern dialect of ML, the language used in the Logic for Computable Functions (LCF) theorem-proving project. It is distinctive among widely used languages in that it has a formal specification, given as typing rules and operational semantics in _The Definition of Standard ML_."
  },
  "484": {
    "label": "StarLogo",
    "wikipedia_pageid": 746828,
    "inception": { "time": "+2001-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [19, 2],
    "typing": [13, 1, 10],
    "description": "**StarLogo** is an agent-based simulation language developed by Mitchel Resnick, Eric Klopfer, and others at the Massachusetts Institute of Technology (MIT) Media Lab and Scheller Teacher Education Program in Massachusetts. It is an extension of the Logo programming language, a dialect of Lisp. Designed for education, StarLogo can be used by students to model or simulate the behavior of decentralized systems. The first StarLogo ran on a Connection Machine 2 parallel computer. A subsequent version ran on Macintosh computers. It was later renamed MacStarLogo, and now is named MacStarLogo Classic. The current StarLogo is written in the language Java and works on most computers. StarLogo is also available in a version named _OpenStarLogo_. Its source code is available online, but the license under which it is released is not an open-source license according to The Open Source Definition, because of restrictions on the commercial use of the code."
  },
  "485": {
    "label": "Strand",
    "wikipedia_pageid": 7837169,
    "inception": { "time": "+1989-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [7],
    "typing": [],
    "description": "**Strand** is a high-level symbolic language for parallel computing, similar in syntax to Prolog. Artificial Intelligence Ltd were awarded the British Computer Society Award for Technical Innovation 1989 for Strand88. The language was created by computer scientists Ian Foster and Stephen Taylor."
  },
  "486": {
    "label": "Strongtalk",
    "wikipedia_pageid": 1569550,
    "inception": { "time": "+2002-07-01T00:00:00Z", "precision": 11 },
    "paradigm": [6],
    "typing": [10, 11],
    "description": "**Strongtalk** is a Smalltalk environment with optional static typing support. Strongtalk can make some compile time checks, and offer _stronger_ type safety guarantees; this is the source of its name. It is non-commercial, though it was originally a commercial project developed by a small startup company named _LongView Technologies_ (trading as _Animorphic Systems_)."
  },
  "487": {
    "label": "Subtext",
    "wikipedia_pageid": 2199610,
    "inception": { "time": "+2004-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [10],
    "typing": [],
    "description": "**Subtext** is a moderately visual programming language and environment, for writing application software. It is an experimental, research attempt to develop a new programming model, called Example Centric Programming, by treating copied blocks as first class prototypes, for program structure. It uses live text, similar to what occurs in spreadsheets as users update cells, for frequent feedback. It is intended to eventually be developed enough to become a practical language for daily use. It is planned to be open software; the license is not yet determined. Subtext was created by Jonathan Edwards who submitted a paper on the language to OOPSLA. It was accepted as part of the 2005 conference."
  },
  "488": {
    "label": "SuperCollider",
    "wikipedia_pageid": 346978,
    "inception": { "time": "+1996-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 21],
    "typing": [10],
    "description": "**SuperCollider** is an environment and programming language originally released in 1996 by James McCartney for real-time audio synthesis and algorithmic composition. Since then it has been evolving into a system used and further developed by both scientists and artists working with sound. It is an efficient and expressive dynamic programming language providing a framework for acoustic research, algorithmic music, interactive programming and live coding. Originally released under the terms of the GPL-2.0-or-later in 2002, and from version 3.4 under GPL-3.0-or-later, SuperCollider is free and open-source software."
  },
  "489": {
    "label": "SuperTalk",
    "wikipedia_pageid": 5235763,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**SuperTalk** is the scripting language used in SuperCard. SuperTalk is a descendant of HyperTalk."
  },
  "490": {
    "label": "Superplan",
    "wikipedia_pageid": 62017767,
    "inception": { "time": "+1951-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2],
    "typing": [],
    "description": "**Superplan** was a high-level programming language developed between 1949 and 1951 by Heinz Rutishauser, the name being a reference to \"Rechenplan\" (i.e. computation plan), in Konrad Zuse's terminology designating a single Plankalkül program. The language was described in Rutishauser's 1951 publication _Über automatische Rechenplanfertigung bei programmgesteuerten Rechenmaschinen_ (i.e. _Automatically created Computation Plans for Program-Controlled Computing Machines_). Superplan introduced the keyword \"for\" resp. the German **für** with its for loop, which had the following form ( a i {\\displaystyle a_{i}} being an array):               **Für** i= _base_ (_increment_) _limit_ :                                                        a                                i                                                         {\\displaystyle a_{i}}        + _addend_ =                                                        a                                i                                                         {\\displaystyle a_{i}}"
  },
  "491": {
    "label": "Swift",
    "wikipedia_pageid": 42946796,
    "inception": { "time": "+2007-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [22, 16],
    "typing": [],
    "description": "**Swift** is an implicitly parallel programming language that allows writing scripts that distribute program execution across distributed computing resources, including clusters, clouds, grids, and supercomputers. Swift implementations are open-source software under the Apache License, version 2.0."
  },
  "492": {
    "label": "Swift",
    "wikipedia_pageid": 42946389,
    "inception": { "time": "+2014-06-02T00:00:00Z", "precision": 11 },
    "paradigm": [6, 3, 13, 21],
    "typing": [6, 1, 11],
    "description": "**Swift** is a general-purpose, multi-paradigm, compiled programming language developed by Apple Inc. and the open-source community. First released in 2014, Swift was developed as a replacement for Apple's earlier programming language Objective-C, as Objective-C had been largely unchanged since the early 1980s and lacked modern language features. Swift works with Apple's Cocoa and Cocoa Touch frameworks, and a key aspect of Swift's design was the ability to interoperate with the huge body of existing Objective-C code developed for Apple products over the previous decades. It is built with the open source LLVM compiler framework and has been included in Xcode since version 6, released in 2014. On Apple platforms, it uses the Objective-C runtime library which allows C, Objective-C, C++ and Swift code to run within one program. Apple intended Swift to support many core concepts associated with Objective-C, notably dynamic dispatch, widespread late binding, extensible programming and similar features, but in a \"safer\" way, making it easier to catch software bugs; Swift has features addressing some common programming errors like null pointer dereferencing and provides syntactic sugar to help avoid the pyramid of doom. Swift supports the concept of protocol extensibility, an extensibility system that can be applied to types, structs and classes, which Apple promotes as a real change in programming paradigms they term \"protocol-oriented programming\" (similar to traits). Swift was introduced at Apple's 2014 Worldwide Developers Conference (WWDC). It underwent an upgrade to version 1.2 during 2014 and a major upgrade to Swift 2 at WWDC 2015. Initially a proprietary language, version 2.2 was made open-source software under the Apache License 2.0 on December 3, 2015, for Apple's platforms and Linux. Through version 3.0 the syntax of Swift went through significant evolution, with the core team making source stability a focus in later versions. In the first quarter of 2018 Swift surpassed Objective-C in measured popularity. Swift 4.0, released in 2017, introduced several changes to some built-in classes and structures. Code written with previous versions of Swift can be updated using the migration functionality built into Xcode. Swift 5, released in March 2019, introduced a stable binary interface on Apple platforms, allowing the Swift runtime to be incorporated into Apple operating systems. It is source compatible with Swift 4. Swift 5.1 was officially released in September 2019. Swift 5.1 builds on the previous version of Swift 5 by extending the stable features of the language to compile-time with the introduction of module stability. The introduction of module stability makes it possible to create and share binary frameworks that will work with future releases of Swift. Swift 5.5, officially announced by Apple at the 2021 WWDC, significantly expands language support for concurrency and asynchronous code, notably introducing a unique version of the actor model."
  },
  "493": {
    "label": "SystemVerilog",
    "wikipedia_pageid": 2540686,
    "inception": { "time": "+2002-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 36],
    "typing": [11, 2],
    "description": "**SystemVerilog**, standardized as **IEEE 1800**, is a hardware description and hardware verification language used to model, design, simulate, test and implement electronic systems. SystemVerilog is based on Verilog and some extensions, and since 2008 Verilog is now part of the same IEEE standard. It is commonly used in the semiconductor and electronic design industry as an evolution of Verilog."
  },
  "494": {
    "label": "T",
    "wikipedia_pageid": 875484,
    "inception": { "time": "+1982-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 3, 25, 21],
    "typing": [10, 1],
    "description": "The programming language **T** is a dialect of the language Scheme developed in the early 1980s by Jonathan A. Rees, Kent M. Pitman, and Norman I. Adams of Yale University as an experiment in language design and implementation."
  },
  "495": {
    "label": "TACL",
    "wikipedia_pageid": 1558785,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**TACL** (the **Tandem Advanced Command Language**) is the scripting programming language used in Tandem Computers. TACL is the shell."
  },
  "496": {
    "label": "TACPOL",
    "wikipedia_pageid": 1719114,
    "inception": null,
    "paradigm": [36],
    "typing": [],
    "description": "**TACPOL** (Tactical Procedure Oriented Language) is a block structured programming language developed by the United States Army for the TACFIRE Tactical Fire Direction command and control application. TACPOL is similar to PL/I."
  },
  "497": {
    "label": "TADS",
    "wikipedia_pageid": 227991,
    "inception": { "time": "+1988-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [14],
    "typing": [1, 6],
    "description": "**Text Adventure Development System** (**TADS**) is a prototype-based domain-specific programming language and set of standard libraries for creating interactive fiction (IF) games."
  },
  "498": {
    "label": "TELCOMP",
    "wikipedia_pageid": 991259,
    "inception": { "time": "+1965-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**TELCOMP** was a programming language developed at Bolt, Beranek and Newman (BBN) in about 1964 and in use until at least 1974. BBN offered TELCOMP as a paid service, with first revenue in October 1965. The service was sold to a company called On-Line Systems in 1972. In the United Kingdom, TELCOMP was offered by Time Sharing, Ltd, a partnership between BBN and an entrepreneur named Richard Evans. It was an interactive, conversational language based on JOSS, developed by BBN after Cliff Shaw from RAND visited the labs in 1964 as part of the NIH survey. It was first implemented on the PDP-1 and was used to provide a commercial time sharing service by BBN in the Boston area and later by Time Sharing Ltd. in the United Kingdom. In 1996, Leo Beranek said \"We even developed a programming language called TELCOMP that to this day, some say was better than the programming language that the industry adopted, namely BASIC.\" There were at least three versions: TELCOMP I, TELCOMP II, and TELCOMP III. TELCOMP I was implemented on the PDP-1, TELCOMP II on the PDP-7 and TELCOMP III on the PDP-10, running on DEC 's TOPS-10 operating system or on BBN's own TENEX operating system. TELCOMP programs were normally input via a paper tape reader on a Teletype Model 33, which would be connected to a PDP via a modem and acoustic telephone line. Data could be read from the paper tape reader or from the Teletype keyboard. Output was either printed to the Teletype or sent to the paper tape punch. Early versions had no facility for on-line storage of programs or data. During data input using a Teletype, the user would type a response to a printed prompt. If, instead of hitting `Return`, the user hit `Tab ↹`, another, possibly computed, prompt would be printed on the same line. This process could be repeated for the full width of the line. This unusual feature allowed very compact data entry, comparable to full-screen CRT data entry. It saved paper, and the input section of the form became part of the program's printed output. A later derivative of TELCOMP called STRINGCOMP was oriented towards string handling. Another BBN JOSS-derivative called FILECOMP was developed for the GE MEDINET system, which was cancelled. The implicit file handling system it contained was influential on the MUMPS global database system. The initial research for LOGO was carried out in TELCOMP, but only the JOSS- style errors and interaction made it through to the actual language."
  },
  "499": {
    "label": "TMG",
    "wikipedia_pageid": 38020020,
    "inception": { "time": "+1963-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**TMG** (TransMoGrifier) is a recursive descent compiler-compiler created by Robert M. McClure and presented in 1965. TMG ran on systems like OS/360 and early Unix. It was used to build EPL, an early version of PL/I. Douglas McIlroy ported TMG to an early version of Unix. According to Ken Thompson, McIlroy wrote TMG in TMG on a piece of paper and \"decided to give his piece of paper his piece of paper,\" hand-compiling assembly language that he entered and assembled on Thompson's Unix system running on PDP-7. Thompson used TMG in 1970 as a tool to offer Fortran, but due to memory limitations of PDP-7 ended up creating the B programming language which was much influenced by BCPL. Recursive descent algorithm of TMG was studied formally by Alexander Birman and Jeffrey Ullman. Formal description of the algorithms was named _TMG recognition scheme_ (or simply _TS_)."
  },
  "500": {
    "label": "TRAC",
    "wikipedia_pageid": 352419,
    "inception": { "time": "+1964-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**TRAC** (for **T** ext **R** eckoning **A** nd **C** ompiling) **Language** is a programming language developed between 1959-1964 by Calvin Mooers and first implemented on the PDP-1 in 1964 by L. Peter Deutsch. It was one of three \"first languages\" recommended by Ted Nelson in _Computer Lib_. TRAC T64 was used until at least 1984, when Mooers updated it to TRAC T84."
  },
  "501": {
    "label": "TTCN",
    "wikipedia_pageid": 780024,
    "inception": { "time": "+1992-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**TTCN** is a programming language used for testing of communication protocols and web services. A TTCN test suite consists of many test cases written in the TTCN programming language. Until version 2 the language was written in tables and called _**Tree and Tabular Combined Notation**_. Reading and editing this language required special TTCN editors. Beginning with version 3 TTCN was renamed to _**Testing and Test Control Notation**_. It is now closer to current programming languages and can be edited with traditional editors. TTCN-3 is more flexible than TTCN-2 in that it can be used for protocol testing as well as testing traditional software. All versions of TTCN need dedicated compilers or interpreters for execution. TTCN is widely used, for example; ETSI, ITU for the testing of telecommunication protocols. Conformance test cases of ETSI standards like ISDN, DECT, GSM, EDGE, 3G, DSRC have also been written in TTCN. Recently it has also been used for testing various protocol standards e.g. Bluetooth, IP. Execution of those test cases against products (e.g. phones, mobile phones, service enablers or network elements) is used to verify that the protocol implementation in those products meet the requirements defined by telecommunication standards. TTCN is often combined with ASN.1."
  },
  "502": {
    "label": "TTM",
    "wikipedia_pageid": 37939929,
    "inception": { "time": "+1968-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**TTM** is a string oriented, general purpose macro processing programming language developed in 1968 by Steven Caine and E. Kent Gordon at the California Institute of Technology."
  },
  "503": {
    "label": "TUTOR",
    "wikipedia_pageid": 3281107,
    "inception": { "time": "+1969-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3],
    "typing": [],
    "description": "**TUTOR**, also known as **PLATO Author Language**, is a programming language developed for use on the PLATO system at the University of Illinois at Urbana-Champaign beginning in roughly 1965. TUTOR was initially designed by Paul Tenczar for use in computer assisted instruction (CAI) and computer managed instruction (CMI) (in computer programs called \"lessons\") and has many features for that purpose. For example, TUTOR has powerful answer-parsing and answer-judging commands, graphics, and features to simplify handling student records and statistics by instructors. TUTOR's flexibility, in combination with PLATO's computational power (running on what was considered a supercomputer in 1972), also made it suitable for the creation of games — including flight simulators, war games, dungeon style multiplayer role-playing games, card games, word games, and medical lesson games such as _Bugs and Drugs_ (_BND_). TUTOR lives on today as the programming language for the Cyber1 PLATO System, which runs most of the source code from 1980s PLATO and has roughly 5000 users as of June 2020."
  },
  "504": {
    "label": "TXL",
    "wikipedia_pageid": 7025179,
    "inception": null,
    "paradigm": [21],
    "typing": [],
    "description": "**TXL** is a special-purpose programming language originally designed by Charles Halpern-Hamu and James Cordy at the University of Toronto in 1985. The acronym \"TXL\" originally stood for \"Turing eXtender Language\" after the language's original purpose, the specification and rapid prototyping of variants and extensions of the Turing programming language, but no longer has any meaningful interpretation. Modern TXL is specifically designed for creating, manipulating and rapidly prototyping language-based descriptions, tools and applications using source transformation. It is a hybrid functional / rule-based language using first order functional programming at the higher level and term rewriting at the lower level. The formal semantics and implementation of TXL are based on formal term rewriting, but the term structures are largely hidden from the user due to the example-like style of pattern specification. Each TXL program has two components: a description of the source structures to be transformed, specified as a (possibly ambiguous) context-free grammar using an extended Backus–Naur Form; and a set of tree transformation rules, specified using pattern / replacement pairs combined using first order functional programming. TXL is designed to allow explicit programmer control over the interpretation, application, order and backtracking of both parsing and rewriting rules, allowing for expression of a wide range of grammar-based techniques such as agile parsing. The first component parses the input expression into a tree using pattern- matching. The second component uses Term-rewriting in a manner similar to Yacc to produce the transformed output. TXL is most commonly used in software analysis and reengineering tasks such as design recovery, and in rapid prototyping of new programming languages and dialects."
  },
  "505": {
    "label": "Tool Command Language",
    "wikipedia_pageid": 39880682,
    "inception": { "time": "+1988-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [12, 2, 3, 21, 6],
    "typing": [10],
    "description": "**Tcl** (pronounced \"tickle\" or as an initialism) is a high-level, general- purpose, interpreted, dynamic programming language. It was designed with the goal of being very simple but powerful. Tcl casts everything into the mold of a command, even programming constructs like variable assignment and procedure definition. Tcl supports multiple programming paradigms, including object- oriented, imperative and functional programming or procedural styles. It is commonly used embedded into C applications, for rapid prototyping, scripted applications, GUIs, and testing. Tcl interpreters are available for many operating systems, allowing Tcl code to run on a wide variety of systems. Because Tcl is a very compact language, it is used on embedded systems platforms, both in its full form and in several other small-footprint versions. The popular combination of Tcl with the Tk extension is referred to as **Tcl/Tk**, and enables building a graphical user interface (GUI) natively in Tcl. Tcl/Tk is included in the standard Python installation in the form of Tkinter."
  },
  "506": {
    "label": "Tea",
    "wikipedia_pageid": 3431871,
    "inception": { "time": "+1997-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 21],
    "typing": [],
    "description": "**Tea** is a high-level scripting language for the Java environment. It combines features of Scheme, Tcl, and Java."
  },
  "507": {
    "label": "Tensilica Instruction Extension",
    "wikipedia_pageid": 15500092,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**Tensilica Instruction Extension** refers to the proprietary language that is used to customize Tensilica's Xtensa processor core architecture. By using TIE, the user can customize the Xtensa architecture by adding custom instructions and register files, instantiating TIE Ports and Queues for multiprocessor communication, and adding pre-configured extensions (such as Tensilica's DSP). Software applications can greatly benefit from properly targeted user-defined instructions, while TIE ports and TIE queues facilitate multiprocessor communication by adding separate input and output interfaces to the processor core. Using the TIE language and Xtensa Xplorer toolkit, the generation and verification of the instructions used to extend the processor ISA are automated. Such automation helps to reduce the hardware verification time that typically consumes a large percentage of the project duration of a typical hardware developed for the same functionality."
  },
  "508": {
    "label": "TECO",
    "wikipedia_pageid": 30449,
    "inception": { "time": "+1962-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**TECO** (Tee'koh / ), Text Editor & Corrector is both a character-oriented text editor and a programming language, that was developed in 1962 for use on Digital Equipment Corporation computers, and has since become available on PCs and Unix. Dan Murphy developed TECO while a student at the Massachusetts Institute of Technology (MIT). According to Murphy, the initial acronym was \"Tape Editor and Corrector\" because \"punched paper tape was the only medium for the storage of program source on our PDP-1. There was no hard disk, floppy disk, magnetic tape (magtape), or network.\" By the time TECO was made available for general use, the name had become \"Text Editor and Corrector,\" since even the PDP-1 version by then supported other media. It was subsequently modified by many other people and is a direct ancestor of Emacs, which was originally implemented in TECO macros."
  },
  "509": {
    "label": "Text Executive Programming Language",
    "wikipedia_pageid": 13852549,
    "inception": { "time": "+1979-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "In 1979, Honeywell Information Systems announced a new programming language for their time-sharing service named **TEX**, an acronym for the **Text Executive** text processing system. **TEX** was a first generation scripting language, developed around the time of AWK and used by Honeywell initially as an in-house system test automation tool. **TEX** extended the **Honeywell Time-Sharing service (TSS)** line editor with programmable capabilities which allowed the user greater latitude in developing ease-of-use editing extensions as well as write scripts to automate many other time-sharing tasks formerly done by more complex TSS FORTRAN programs."
  },
  "510": {
    "label": "Text Processing Utility",
    "wikipedia_pageid": 479903,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**DEC Text Processing Utility** (or **DECTPU**) was a language developed by Digital Equipment Corporation (DEC) for developing text editors. In 1986, DEC developed a new version of EDT written in TPU, having released EVE (Extensible Versatile Editor), also a TPU-based editor, by mid-1985. TPU is distributed with OpenVMS. It is designed to be used on a terminal or console, so that it is not necessary to have DECwindows installed to use it. Among other things, the Language-Sensitive Editor and EVE are implemented using DECTPU. TPU provides text buffer management APIs in concert with window management APIs which were targeted for the VT-XXX line of terminals. This allowed split- screen windows with scrolling and hence multiple views of the same buffer content. There were also key mapping APIs provided, allowing a wide range of functionality for editing text. A version of the vi editor was created by Gregg Wonderly at Oklahoma State University called TPUVI or VITPU. VITPU is still available via the DECUS archives online."
  },
  "511": {
    "label": "Toi",
    "wikipedia_pageid": 52078022,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**Toi** is an imperative, type-sensitive language that provides the basic functionality of a programming language. The language was designed and developed from the ground-up by Paul Longtine. Written in C, Toi was created with the intent to be an educational experience and serves as a learning tool (or toy, hence the name) for those looking to familiarize themselves with the inner-workings of a programming language."
  },
  "512": {
    "label": "Tom",
    "wikipedia_pageid": 11090262,
    "inception": { "time": "+2001-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**Tom** is a programming language particularly well-suited for programming various transformations on tree structures and XML based documents. Tom is a language extension which adds new matching primitives to C and Java as well as support for rewrite rules systems. The rules can be controlled using a strategy language. Tom is good for:   * programming by pattern matching   * developing compilers and DSL   * transforming XML documents   * implementing rule based systems   * describing algebraic transformations"
  },
  "513": {
    "label": "Transact-SQL",
    "wikipedia_pageid": 295710,
    "inception": null,
    "paradigm": [2],
    "typing": [],
    "description": "**Transact-SQL** (**T-SQL**) is Microsoft's and Sybase's proprietary extension to the SQL (Structured Query Language) used to interact with relational databases. T-SQL expands on the SQL standard to include procedural programming, local variables, various support functions for string processing, date processing, mathematics, etc. and changes to the DELETE and UPDATE statements. Transact-SQL is central to using Microsoft SQL Server. All applications that communicate with an instance of SQL Server do so by sending Transact-SQL statements to the server, regardless of the user interface of the application. Stored procedures in SQL Server are executable server-side routines. The advantage of stored procedures is the ability to pass parameters."
  },
  "514": {
    "label": "Transaction Application Language",
    "wikipedia_pageid": 1558864,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**Transaction Application Language** or **TAL** (originally \"Tandem Application Language\") is a block-structured, procedural language optimized for use on Tandem hardware. TAL resembles a cross between C and Pascal. It was the original system programming language for the Tandem CISC machines, which had no assembler. The design concept of TAL, an evolution of Hewlett Packard's SPL, was intimately associated and optimized with a microprogrammed CISC instruction set. Each TAL statement could easily compile into a sequence of instructions that manipulated data on a transient floating register stack. The register stack itself floated at the crest of the program's memory allocation and call stack. The language itself has the appearance of ALGOL or Pascal, with BEGIN and END statements. However, its semantics are far more like C. It does not permit indefinite levels of procedure nesting, it does not pass complex structured arguments by value, and it does not strictly type most variable references. Programming techniques are much like C using pointers to structures, occasional overlays, deliberate string handling and casts when appropriate. Available datatypes include 8 bit, 16 bit, 32 bit and (introduced later) 64 bit integers. Microcode level support was available for null terminated character strings. However, this is not commonly used. Originally the Tandem NonStop operating system was written in TAL. Recently much of it has been rewritten in C and TAL has been deprecated for new development. In the migration from CISC to RISC TAL was updated/replaced with pTAL - compilers allowed TAL to be accelerated/re-compiled into Native RISC Applications. In the current migration from RISC to Intel Itanium 2 TAL and pTAL has been replaced with epTAL, again - compilers allow TAL and pTAL code to be accelerated/re-compiled into native Itanium Applications. This article is based on material taken from the _Free On-line Dictionary of Computing_ prior to 1 November 2008 and incorporated under the \"relicensing\" terms of the GFDL, version 1.3 or later."
  },
  "515": {
    "label": "LiveCode",
    "wikipedia_pageid": 30890362,
    "inception": { "time": "+2001-07-11T00:00:00Z", "precision": 11 },
    "paradigm": [6],
    "typing": [],
    "description": "**LiveCode** (formerly Revolution and MetaCard) is a cross-platform rapid application development runtime system inspired by HyperCard. It features the _LiveCode Script_ (formerly MetaTalk) programming language which belongs to the family of xTalk scripting languages like HyperCard's HyperTalk. The environment was introduced in 2001. The \"Revolution\" development system was based on the MetaCard engine technology which Runtime Revolution later acquired from MetaCard Corporation in 2003. The platform won the Macworld Annual Editor's Choice Award for \"Best Development Software\" in 2004. \"Revolution\" was renamed \"LiveCode\" in the fall of 2010. \"LiveCode\" is developed and sold by Runtime Revolution Ltd., based in Edinburgh, Scotland. In March, 2015, the company was renamed \"LiveCode Ltd.\", to unify the company name with the product. In April 2013 a free/open source version 'LiveCode Community Edition 6.0' was published after a successful crowdfunding campaign at Kickstarter. The code base was re-licensed and made available as free and open source software with a version in April 2013. LiveCode runs on iOS, Android, OS X, Windows 95 through Windows 10, Raspberry Pi and several variations of Unix, including Linux, Solaris, and BSD. It can be used for mobile, desktop and server/CGI applications. The iOS (iPhone and iPad) version was released in December 2010. The first version to deploy to the Web was released in 2009. It is the most widely used HyperCard/HyperTalk clone, and the only one that runs on all major operating systems. A developer release of v.8 was announced in New York on March 12, 2015. This major enhancement to the product includes a new, separate development language, known as \"LiveCode Builder\", which is capable of creating new object classes called \"widgets\". In earlier versions, the set of object classes was fixed, and could be enhanced only via the use of ordinary procedural languages such as C. The new language, which runs in its own IDE, is a departure from the transitional x-talk paradigm in that it permits typing of variables. But the two environments are fully integrated, and apart from the ability to create new objects, development in LiveCode proceeds in the normal way, within the established IDE. A second crowdfunding campaign to Bring HTML5 to LiveCode reached funding goals of nearly $400,000 USD on July 31, 2014. LiveCode developer release 8.0 DP4 (August 31, 2015) was the first to include a standalone deployment option to HTML5."
  },
  "516": {
    "label": "Turing",
    "wikipedia_pageid": 31105,
    "inception": { "time": "+1982-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 2],
    "typing": [14, 11],
    "description": "**Turing** is a Pascal-like programming language developed in 1982 by Ric Holt and James Cordy, then of University of Toronto, in Toronto, Ontario, Canada. Turing is a descendant of Euclid, Pascal and SP/k that features a clean syntax and precise machine-independent semantics. Turing 4.1.0 is the latest stable version of Turing. Turing 4.1.1 and Turing 4.1.2 do not allow for stand alone .EXE files to be created and versions before Turing 4.1.0 have outdated syntax and outdated functions."
  },
  "517": {
    "label": "Tynker",
    "wikipedia_pageid": 45530923,
    "inception": { "time": "+2012-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [10],
    "typing": [],
    "description": "**Tynker** is an educational programming platform aimed at teaching children aged between 5-18 to learn how to develop coding skills. Instead of typing the source code, you visually drag blocks of code and snap them together. Its an educational solution to teach kids to code which includes game design, web design, animation and robotics. It makes it easier for kids to learn 60+ courses which includes courses in Minecraft Modding, Minecraft Game Design, Creative Coding, Python, CSS, etc. Tynker is based on HTML5 and JavaScript, and can be used in the browser without plugins, as well as on tablets and smartphones. Tynker has content that is interactive with video tutorials and hours of content and they teach all common text coding and block coding. Over 90,000 schools use Tynker’s comprehensive programming and STEM curriculum with 3,700+ fun coding activities and has over 600 hours of grade-specific, Common Core- and NGSS-aligned lessons to take students from block coding to advanced text coding as well as AP accredited CSS course."
  },
  "518": {
    "label": "TypeScript",
    "wikipedia_pageid": 8157205,
    "inception": { "time": "+2012-10-01T00:00:00Z", "precision": 11 },
    "paradigm": [6, 26, 3, 21],
    "typing": [12, 13, 5],
    "description": "**TypeScript** is a programming language developed and maintained by Microsoft. It is a strict syntactical superset of JavaScript and adds optional static typing to the language. TypeScript is designed for the development of large applications and transcompiles to JavaScript. As TypeScript is a superset of JavaScript, existing JavaScript programs are also valid TypeScript programs. TypeScript may be used to develop JavaScript applications for both client-side and server-side execution (as with Node.js or Deno). There are multiple options available for transcompilation. Either the default TypeScript Checker can be used, or the Babel compiler can be invoked to convert TypeScript to JavaScript. TypeScript supports definition files that can contain type information of existing JavaScript libraries, much like C++ header files can describe the structure of existing object files. This enables other programs to use the values defined in the files as if they were statically typed TypeScript entities. There are third-party header files for popular libraries such as jQuery, MongoDB, and D3.js. TypeScript headers for the Node.js basic modules are also available, allowing development of Node.js programs within TypeScript. The TypeScript compiler is itself written in TypeScript and compiled to JavaScript. It is licensed under the Apache License 2.0. TypeScript is included as a first-class programming language in Microsoft Visual Studio 2013 Update 2 and later, alongside C# and other Microsoft languages. An official extension allows Visual Studio 2012 to support TypeScript as well. Anders Hejlsberg, lead architect of C# and creator of Delphi and Turbo Pascal, has worked on the development of TypeScript."
  },
  "519": {
    "label": "UNITY",
    "wikipedia_pageid": 3092830,
    "inception": { "time": "+1988-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**UNITY** is a programming language constructed by K. Mani Chandy and Jayadev Misra for their book _Parallel Program Design: A Foundation_. It is a theoretical language which focuses on _what_, instead of _where_,_when_ or _how_. The language contains no method of flow control, and program statements run in a nondeterministic way until statements cease to cause changes during execution. This allows for programs to run indefinitely, such as auto-pilot or power plant safety systems, as well as programs that would normally terminate (which here converge to a fixed point)."
  },
  "520": {
    "label": "Ubercode",
    "wikipedia_pageid": 4269756,
    "inception": { "time": "+2005-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [],
    "description": "**Ubercode** is a high level programming language designed by Ubercode Software and released in 2005 for Microsoft Windows. Ubercode is influenced by Eiffel and BASIC. It is proprietary software and can be tried out for free for 30 days. Ubercode has the following design goals:   1. _Compilable language_ —compiled into Windows EXE files.   2. _Automatic memory management_ —memory is allocated / freed automatically, and the language has no memory management primitives.   3. _Pre and post conditions_ —these are run-time assertions which are attached to function declarations, as in Eiffel.   4. _High-level data types_ —resizable arrays, lists and tables may contain arbitrary components.   5. _Integrated file handling_ —primitives for transparent handling of text, binary, CSV, XML and dBase files.   6. _Ease of use_ —language structure is relatively simple, making the language accessible to beginners."
  },
  "521": {
    "label": "Umple",
    "wikipedia_pageid": 39874090,
    "inception": { "time": "+2008-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [11],
    "description": "**Umple** is a language for both object-oriented programming and modelling with class diagrams and state diagrams. The name Umple is a portmanteau of \"UML\", \"ample\" and \"Simple\", indicating that it is designed to provide ample features to extend programming languages with UML capabilities."
  },
  "522": {
    "label": "Unicon",
    "wikipedia_pageid": 902180,
    "inception": null,
    "paradigm": [6, 2],
    "typing": [],
    "description": "**Unicon** is a programming language designed by American computer scientist Clint Jeffery with collaborators including Shamim Mohamed, Jafar Al Gharaibeh, Robert Parlett and others. Unicon descended from Icon and a preprocessor for Icon called IDOL. Compared with Icon, Unicon offers better access to the operating system as well as support for object-oriented programming. Unicon began life as a merger of three popular Icon extensions: an OO preprocessor named Idol, a POSIX filesystem and networking interface, and an ODBC facility. The name is shorthand for \"Unified Extended Dialect of Icon.\""
  },
  "523": {
    "label": "Unreal Engine",
    "wikipedia_pageid": 417152,
    "inception": null,
    "paradigm": [6],
    "typing": [],
    "description": "**Unreal Engine** is a game engine developed by Epic Games, first showcased in the 1998 first-person shooter game _Unreal_. Initially developed for PC first- person shooters, it has since been used in a variety of genres of three- dimensional (3D) games and has seen adoption by other industries, most notably the film and television industry. Written in C++, the Unreal Engine features a high degree of portability, supporting a wide range of desktop, mobile, console and virtual reality platforms. The latest generation is Unreal Engine 4, which was launched in 2014 under a subscription model. Since 2015, it can be downloaded for free, with its source code available on a GitHub private repository. Epic allows for its use in commercial products based on a royalty model, typically asking developers for 5% of revenues from sales, though with the success of _Fortnite_, which has become a testbed for Unreal Engine for Epic, Epic waives this fee for developers that publish their games through the Epic Games Store. On May 13, 2020, Epic announced that their portion of royalties for games developed in Unreal Engine are waived until developers have earned their first US$1 million in revenue, retroactively applying to January 1, 2020. Unreal Engine 5 is scheduled for full release in early 2022. It is popular among PC and console games with high graphics capabilities and is used for games such as _PlayerUnknown's Battlegrounds_, the _Gears of War_ series,_Final Fantasy VII Remake_,_Valorant_ and _Yoshi’s Crafted World_, as well as Epic's own games."
  },
  "524": {
    "label": "VHDL",
    "wikipedia_pageid": 43410,
    "inception": { "time": "+1983-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [22, 15, 16],
    "typing": [1],
    "description": "The **VHSIC Hardware Description Language** (**VHDL**) is a hardware description language (HDL) that can model the behavior and structure of digital systems at multiple levels of abstraction, ranging from the system level down to that of logic gates, for design entry, documentation, and verification purposes. Since 1987, VHDL has been standardized by the Institute of Electrical and Electronics Engineers (IEEE) as **IEEE Std 1076** ; the latest version (as of April 2020) of which is **IEEE Std 1076-2019**. To model analog and mixed-signal systems, an IEEE-standardized HDL based on VHDL called VHDL-AMS (officially IEEE 1076.1) has been developed. VHDL is named after the United States Department of Defense program that created it, the Very High-Speed Integrated Circuits Program (VHSIC). In the early 1980s, the VHSIC Program sought a new HDL for use in the design of the integrated circuits it aimed to develop. The product of this effort was VHDL Version 7.2, released in 1985. The effort to standardize it as an IEEE standard began in the following year."
  },
  "525": {
    "label": "Vala",
    "wikipedia_pageid": 12655903,
    "inception": { "time": "+2006-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 3, 36],
    "typing": [12, 6, 1, 11],
    "description": "**Vala** is an object-oriented programming language with a self-hosting compiler that generates C code and uses the GObject system. Vala is syntactically similar to C# and includes notable features such as anonymous functions, signals, properties, generics, assisted memory management, exception handling, type inference, and foreach statements. Its developers, Jürg Billeter and Raffaele Sandrini, wanted to bring these features to the plain C runtime with little overhead and no special runtime support by targeting the GObject object system. Rather than compiling directly to machine code or assembly language, it compiles to a lower-level intermediate language. It source-to-source compiles to C, which is then compiled with a C compiler for a given platform, such as GCC or Clang. Using functionality from native code libraries requires writing vapi files, defining the library interfaces. Writing these interface definitions is well- documented for C libraries, especially when based on GObject. Bindings are already available for a large number of libraries, including for C libraries that are not based on GObject, such as the multimedia library SDL, OpenGL, etc."
  },
  "526": {
    "label": "Verilog",
    "wikipedia_pageid": 63863,
    "inception": { "time": "+1984-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [36],
    "typing": [11, 2],
    "description": "**Verilog**, standardized as **IEEE 1364**, is a hardware description language (HDL) used to model electronic systems. It is most commonly used in the design and verification of digital circuits at the register-transfer level of abstraction. It is also used in the verification of analog circuits and mixed-signal circuits, as well as in the design of genetic circuits. In 2009, the Verilog standard (IEEE 1364-2005) was merged into the SystemVerilog standard, creating IEEE Standard 1800-2009. Since then, Verilog is officially part of the SystemVerilog language. The current version is IEEE standard 1800-2017."
  },
  "527": {
    "label": "Vim",
    "wikipedia_pageid": 32478,
    "inception": { "time": "+1991-11-02T00:00:00Z", "precision": 11 },
    "paradigm": [],
    "typing": [],
    "description": "**Vim** (; a contraction of **Vi IMproved**) is a clone, with additions, of Bill Joy's vi text editor program for Unix. Vim's author, Bram Moolenaar, based it on the source code for a port of the Stevie editor to the Amiga and released a version to the public in 1991. Vim is designed for use both from a command-line interface and as a standalone application in a graphical user interface. Vim is free and open-source software and is released under the Vim license that includes some charityware clauses, encouraging users who enjoy the software to consider donating to children in Uganda. The Vim license is compatible with the GNU General Public License through a special clause allowing distribution of modified copies under the GNU GPL-2.0-or-later license. Since its release for the Amiga, cross-platform development has made it available on many other systems. In 2006, it was voted the most popular editor amongst _Linux Journal_ readers; in 2015 the Stack Overflow developer survey found it to be the third most popular text editor, and in 2019 the fifth most popular development environment."
  },
  "528": {
    "label": "DataFlex",
    "wikipedia_pageid": 742526,
    "inception": { "time": "+1982-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 3, 36],
    "typing": [],
    "description": "**DataFlex** is an object-oriented high-level programming language and a fourth generation visual tool 4GL for developing Windows, web and mobile software applications on one framework-based platform. It was introduced and developed by _Data Access Corporation_ beginning in 1982."
  },
  "529": {
    "label": "Visual DialogScript",
    "wikipedia_pageid": 45738,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**Visual DialogScript** (VDS) is an interpreted programming language for Microsoft Windows. It can be used to create small, fast programs. VDS has a large number of dialog and graphical elements available to create professional looking programs. VDS programs have access to the Windows API; therefore, it is possible to write applications that can perform the same advanced tasks as other programming languages such as Visual Basic, C++, or Delphi."
  },
  "530": {
    "label": "Visual FoxPro",
    "wikipedia_pageid": 23952547,
    "inception": { "time": "+1984-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 2],
    "typing": [],
    "description": "**Visual FoxPro** was a Microsoft data-centric procedural programming language that subsequently became object-oriented. It was derived from FoxPro (originally known as FoxBASE) which was developed by Fox Software beginning in 1984. Fox Technologies merged with Microsoft in 1992, after which the software acquired further features and the prefix \"Visual\". FoxPro 2.6 worked on Mac OS, DOS, Windows, and Unix. Visual FoxPro 3.0, the first \"Visual\" version, reduced platform support to only Mac and Windows, and later versions 5, 6, 7, 8 and 9 were Windows-only. The current version of Visual FoxPro is COM-based and Microsoft has stated that they do not intend to create a Microsoft .NET version. Version 9.0, released in December 2004 and updated in October 2007 with the SP2 patch, was the final version of the product."
  },
  "531": {
    "label": "Visual J++",
    "wikipedia_pageid": 1962467,
    "inception": { "time": "+1996-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**Visual J++** _(pronounced \"Jay Plus Plus\")_ is Microsoft's discontinued implementation of Java. Syntax, keywords, and grammatical conventions were the same as Java's. It was introduced in 1996 and discontinued in January 2004, replaced to a certain extent by J# and C#."
  },
  "532": {
    "label": "Visual Objects",
    "wikipedia_pageid": 837643,
    "inception": null,
    "paradigm": [6],
    "typing": [],
    "description": "**Visual Objects** is an object-oriented computer programming language that is used to create computer programs that operate primarily under Windows. Although it can be used as a general-purpose programming tool, it is almost exclusively used to create database programs. The original Visual Objects project (code-named **Aspen**) was started as part of Nantucket's attempts to bring the Clipper language to Windows, and move from the procedural to the object-oriented style. It also converted Clipper from a p-code system to being a true native compiler and introduced more elements of the C language (such as typed variables), while including Windows extensions (such as COM, ODBC, and later ADO). With its symbol datatype, it offers the ability to form name-based linkages, which may be used to connect menu events to object methods or form direct linkages between server columns and controls. The Windows version was finally brought to market by Computer Associates. Unfortunately it was released before it was market-ready and in almost head- to-head competition with the first release of Borland's Delphi product. The language is still in use however the last release by GrafX Software was in 2012 of version 2.8 sp4 (version number 2838). GrafX announced that after this no new versions would be released. The next incarnation of the Visual Objects language is Vulcan.NET, written by GrafX from scratch to be both Visual Objects compatible and be a true CLS compliant .NET language, taking full advantage of the .NET framework."
  },
  "533": {
    "label": "Visual Prolog",
    "wikipedia_pageid": 1741668,
    "inception": null,
    "paradigm": [28, 6, 3, 21],
    "typing": [1, 6, 11],
    "description": "**Visual Prolog**, formerly known as **PDC Prolog** and **Turbo Prolog**, is a strongly typed object-oriented extension of Prolog. As Turbo Prolog, it was marketed by Borland but it is now developed and marketed by the Danish firm Prolog Development Center (PDC) that originally developed it. Visual Prolog can build Microsoft Windows GUI-applications, console applications, DLLs (dynamic link libraries), and CGI-programs. It can also link to COM components and to databases by means of ODBC. Logic languages are traditionally interpreted, but Visual Prolog is compiled. This provides the important improvement of converting traditional Prolog- typical run-time errors to compiler warnings, which ensures a better robustness of the finished applications. The core of Visual Prolog are Horn clauses, algebraic datatypes, pattern matching and controlled non-determinism like in traditional Prolog, but unlike traditional Prolog, Visual Prolog has always been strongly and statically typed."
  },
  "534": {
    "label": "WATFIV",
    "wikipedia_pageid": 1135659,
    "inception": { "time": "+1968-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**WATFIV**, or **WAT** erloo **F** ORTRAN **IV**, developed at the University of Waterloo, Canada is an implementation of the Fortran computer programming language. It is the successor of **WATFOR**. WATFIV was used from the late 1960s into the mid-1980s. WATFIV was in turn succeeded by later versions of WATFOR. Because it could complete the three usual steps (\"compile-link-go\") in just one pass, the system became popular for teaching students computer programming."
  },
  "535": {
    "label": "WebAssembly",
    "wikipedia_pageid": 47013794,
    "inception": { "time": "+2015-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3, 33, 36],
    "typing": [],
    "description": "**WebAssembly** (sometimes abbreviated **Wasm**) is an open standard that defines a portable binary-code format for executable programs, and a corresponding textual assembly language, as well as interfaces for facilitating interactions between such programs and their host environment. The main goal of WebAssembly is to enable high-performance applications on web pages, but the format is designed to be executed and integrated in other environments as well, including standalone ones. WebAssembly (i.e. WebAssembly Core Specification (then version 1.0, 1.1 is in draft) and WebAssembly JavaScript Interface) became a World Wide Web Consortium recommendation on 5 December 2019, alongside HTML, CSS, and JavaScript. WebAssembly can support (at least in theory) any language (e.g. compiled or interpreted) on any operating system (with help of appropriate tools), and in practice all of the most popular languages already have at least some level of support. The Emscripten SDK can compile any LLVM-supported languages (such as C, C++ or Rust, among others) source code into a binary file which runs in the same sandbox as JavaScript code. Emscripten provides bindings for several commonly used environment interfaces like WebGL. There is no direct Document Object Model (DOM) access; however, it is possible to create proxy functions for this, for example through stdweb, web_sys, and js_sys when using the Rust language. WebAssembly implementations usually use either ahead-of-time (AOT) or just-in- time (JIT) compilation, but may also use an interpreter. While the first implementations have landed in web browsers, there are also non-browser implementations for general-purpose use, including Wasmer, Wasmtime or WAMR, wasm3, WAVM, and many others. The WebAssembly website has a page comparing popular engines and their implemented features. The World Wide Web Consortium (W3C) maintains the standard with contributions from Mozilla, Microsoft, Google, Apple, Fastly, Intel, and Red Hat."
  },
  "536": {
    "label": "WebDNA",
    "wikipedia_pageid": 24964854,
    "inception": { "time": "+1995-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**WebDNA** is a server-side scripting, interpreted language with an embedded database system, specifically designed for the World Wide Web. Its primary use is in creating database-driven dynamic web page applications. Released in 1995, the name was registered as a trademark in 1998. WebDNA is currently maintained by WebDNA Software Corporation."
  },
  "537": {
    "label": "Whiley",
    "wikipedia_pageid": 48747326,
    "inception": { "time": "+2010-06-00T00:00:00Z", "precision": 10 },
    "paradigm": [3, 21],
    "typing": [12, 1],
    "description": "**Whiley** is an experimental programming language that combines features from the functional and imperative paradigms, and supports formal specification through function preconditions, postconditions and loop invariants. The language uses flow-sensitive typing also known as \"flow typing.\" The Whiley project began in 2009 in response to the \"Verifying Compiler Grand Challenge\" put forward by Tony Hoare in 2003. The first public release of Whiley was in June, 2010. Primarily developed by David Pearce, Whiley is an open source project with contributions from a small community. The system has been used for student research projects and in teaching undergraduate classes. It was supported between 2012 and 2014 by the Royal Society of New Zealand's Marsden Fund. The Whiley compiler generates code for the Java virtual machine and can inter- operate with Java and other JVM based languages."
  },
  "539": {
    "label": "Wolfram Language",
    "wikipedia_pageid": 40205956,
    "inception": { "time": "+1988-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3, 20, 13, 21, 6],
    "typing": [10, 1],
    "description": "The **Wolfram Language** (_WUUL -frəm_) is a general multi-paradigm programming language developed by Wolfram Research. It emphasizes symbolic computation, functional programming, and rule-based programming and can employ arbitrary structures and data. It is the programming language of the mathematical symbolic computation program Mathematica."
  },
  "540": {
    "label": "Wyvern",
    "wikipedia_pageid": 43528524,
    "inception": { "time": "+2013-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [12],
    "description": "**Wyvern** is a computer programming language created by Jonathan Aldrich and Alex Potanin for the development of web and mobile applications with security and assurance being number one priority. Wyvern supports object capabilities, it is structurally typed, and aims to make secure way of programming _easier_ than insecure - as described in the Wyvern Manifesto. One of the early available features that make Wyvern special is a way to safely use multiple programming languages within the same program so programmers can use the language most appropriate for each function while at the same time increasing the program's security. It is currently in a prototype stage and distributed under a GPLv2 license."
  },
  "541": {
    "label": "X10",
    "wikipedia_pageid": 1932246,
    "inception": { "time": "+2004-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 20, 16],
    "typing": [1, 11],
    "description": "**X10** is a programming language being developed by IBM at the Thomas J. Watson Research Center as part of the Productive, Easy-to-use, Reliable Computing System (PERCS) project funded by DARPA's High Productivity Computing Systems (HPCS) program. Its primary authors are Saravanan Arumugam (Aswath), Kemal Ebcioğlu, Vijay Saraswat, and Vivek Sarkar. X10 is designed specifically for parallel computing using the partitioned global address space (PGAS) model. A computation is divided among a set of _places_, each of which holds some data and hosts one or more _activities_ that operate on those data. It has a constrained type system for object- oriented programming, a form of dependent types. Other features include user- defined primitive _struct_ types; globally distributed _arrays_, and structured and unstructured parallelism. X10 uses the concept of parent and child relationships for activities to prevent the lock stalemate that can occur when two or more processes wait for each other to finish before they can complete. An activity may spawn one or more child activities, which may themselves have children. Children cannot wait for a parent to finish, but a parent can wait for a child using the _finish_ command."
  },
  "542": {
    "label": "XBase++",
    "wikipedia_pageid": 2924800,
    "inception": { "time": "+1997-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [],
    "description": "**Xbase++** is an object oriented programming language which has multiple inheritance and polymorphism. It is based on the XBase language dialect and conventions. It is 100% Clipper compatible language supporting multiple inheritance, polymorphism, object oriented programming. It supports the xBase data types, including Codeblocks. With Xbase++ it is possible to generate applications for Windows NT, 95, 98, Me, 2000, XP, VISTA and Windows 7, 8, 10."
  },
  "543": {
    "label": "xHarbour",
    "wikipedia_pageid": 1615369,
    "inception": { "time": "+2001-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2],
    "typing": [],
    "description": "**xHarbour** is a free multi-platform extended Clipper compiler, offering multiple graphic terminals (GTs), including console drivers, GUIs, and hybrid console/GUIs. xHarbour is backward-compatible with Clipper and supports many language syntax extensions, greatly extended run-time libraries, and extensive third party support. Like most dynamic languages, xHarbour is also available as a scripting language (standalone application, linkable library, MS ActiveScript engine [Windows Script Host, HTML, ASP]) utilizing an interpreter written in the xHarbour language. The xHarbour Usenet newsgroup comp.lang.xharbour is an active community for discussing xHarbour related questions."
  },
  "544": {
    "label": "XL",
    "wikipedia_pageid": 2855241,
    "inception": { "time": "+2000-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [3, 21],
    "typing": [1],
    "description": "**XL** (\"eXtensible Language\") is the first computer programming language designed to support concept programming. XL features programmer-reconfigurable syntax and semantics. Compiler _plug- ins_ can be used to add new features to the language. A base set of plug-ins implements a relatively standard imperative language. Programmers can write their own plug-ins to implement application-specific notations, such as symbolic differentiation, which can then be used as readily as built-in language features."
  },
  "545": {
    "label": "XOD",
    "wikipedia_pageid": 57408699,
    "inception": { "time": "+2016-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [22, 10, 24, 13],
    "typing": [],
    "description": "**XOD** is a visual programming language for microcontrollers, started in 2016. As a supported platform, XOD started with Arduino boards compatibility and Raspberry Pi. It is free and open-source software released under the GNU Affero General Public License, version 3.0."
  },
  "546": {
    "label": "XOTcl",
    "wikipedia_pageid": 551037,
    "inception": { "time": "+2000-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 3, 12, 21],
    "typing": [10],
    "description": "**XOTcl** is an object-oriented extension for the Tool Command Language created by Gustaf Neumann and Uwe Zdun. It is a derivative of MIT OTcl. XOTcl is based on a dynamic object system with metaclasses which as influenced by CLOS. Class and method definitions are completely dynamic. XOTcl provides language support for design patterns via filters and decorator mixins."
  },
  "547": {
    "label": "XPL",
    "wikipedia_pageid": 902082,
    "inception": { "time": "+1967-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 36],
    "typing": [],
    "description": "**XPL** is a programming language based on PL/I, a portable one-pass compiler written in its own language, and a parser generator tool for easily implementing similar compilers for other languages. XPL was designed in 1967 as a way to teach compiler design principles and as starting point for students to build compilers for their own languages. XPL was designed and implemented by William M. McKeeman, David B. Wortman, James J. Horning and others at Stanford University. XPL was first announced at the 1968 Fall Joint Computer Conference. The methods and compiler are described in detail in the 1971 textbook _A Compiler Generator_. They called the combined work a 'compiler generator'. But that implies little or no language- or target-specific programming is required to build a compiler for a new language or new target. A better label for XPL is a translator writing system. It helps to write a compiler with less new or changed programming code."
  },
  "548": {
    "label": "XPL0",
    "wikipedia_pageid": 18528411,
    "inception": { "time": "+1976-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2],
    "typing": [],
    "description": "**XPL0** is a computer programming language that is essentially a cross between Pascal and C. It looks somewhat like Pascal but works more like C. It was created in 1976 by Peter J. R. Boyle who wanted a high-level language for his microcomputer and wanted something more sophisticated than BASIC, which was the dominant language for personal computers at the time. XPL0 is based on PL/0, an example compiler in the book _Algorithms + Data Structures = Programs_ by Niklaus Wirth. The first XPL0 compiler was written in ALGOL. It generated instructions for a pseudo-machine that was implemented as an interpreter on a Digital Group computer based on the 6502 microprocessor. The compiler was converted from ALGOL to XPL0 and was then able to compile itself and run on a microcomputer. XPL0 soon proved its worth in a variety of products based on the 6502. These embedded systems would otherwise have had their code written in assembly language, which is much more tedious to do. Boyle used XPL0 to write a disk operating system called Apex. Beginning in 1980 this was sold, along with XPL0, as an alternative to Apple DOS for the Apple II computer, which was based on the 6502. Since those early years XPL0 has been implemented on a dozen processors, and many features have been added. There are now optimizing native code compilers with 32-bit integers in place of the original 16-bit versions. Open source compilers for Windows and MS-DOS on PCs and Linux on the Raspberry Pi are available from the link below."
  },
  "549": {
    "label": "XQuery",
    "wikipedia_pageid": 23742879,
    "inception": { "time": "+2007-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [18, 13, 21],
    "typing": [10, 1, 11],
    "description": "**XQuery** (**XML Query**) is a query and functional programming language that queries and transforms collections of structured and unstructured data, usually in the form of XML, text and with vendor-specific extensions for other data formats (JSON, binary, etc.). The language is developed by the XML Query working group of the W3C. The work is closely coordinated with the development of XSLT by the XSL Working Group; the two groups share responsibility for XPath, which is a subset of XQuery. **XQuery 1.0** became a W3C Recommendation on January 23, 2007.  **XQuery 3.0** became a W3C Recommendation on April 8, 2014.  **XQuery 3.1** became a W3C Recommendation on March 21, 2017. > \"The mission of the XML Query project is to provide flexible query > facilities to extract data from real and virtual documents on the World Wide > Web, therefore finally providing the needed interaction between the Web > world and the database world. Ultimately, collections of XML files will be > accessed like databases.\""
  },
  "550": {
    "label": "XSB",
    "wikipedia_pageid": 4723102,
    "inception": null,
    "paradigm": [28],
    "typing": [],
    "description": "**XSB** is the name of a dialect of the Prolog programming language and its implementation developed at Stony Brook University in collaboration with the Katholieke Universiteit Leuven, the New University of Lisbon, Uppsala University and software vendor XSB, Inc. XSB extends Prolog with tabled resolution and HiLog (a standard extension of Prolog permitting limited higher-order logic programming). The open source XSB implementation includes an interface to the Java programming language."
  },
  "551": {
    "label": "X#",
    "wikipedia_pageid": 50274716,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**X#**, pronounced **X sharp** and often written **XSharp**, is an xBase- compatible programming language for the Microsoft .NET platform. X# has been built on top of Roslyn, the open source architecture behind the current Microsoft C# and Visual Basic .NET compilers. The X# compiler is intended to support multiple dialects in the xBase programming language family. It supports Core, Visual Objects, Vulcan.NET, xBase++, Harbour, Foxpro and more. The project is intended as an opensource community effort, but is at the moment still partly closed source."
  },
  "552": {
    "label": "Xojo",
    "wikipedia_pageid": 39624220,
    "inception": { "time": "+1996-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [],
    "description": "The **Xojo** programming environment and programming language is developed and commercially marketed by Xojo, Inc. of Austin, Texas for software development targeting macOS, Microsoft Windows, Linux, iOS, the Web and Raspberry Pi. Xojo uses a proprietary object-oriented language."
  },
  "553": {
    "label": "Xtend",
    "wikipedia_pageid": 36462606,
    "inception": { "time": "+2011-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 3, 21],
    "typing": [1, 6, 11],
    "description": "**Xtend** is a general-purpose high-level programming language for the Java Virtual Machine. Syntactically and semantically Xtend has its roots in the Java programming language but focuses on a more concise syntax and some additional functionality such as type inference, extension methods, and operator overloading. Being primarily an object-oriented language, it also integrates features known from functional programming, e.g. lambda expressions. Xtend is statically typed and uses Java's type system without modifications. It is compiled to Java code and thereby seamlessly integrates with all existing Java libraries. The language Xtend and its IDE is developed as a project at Eclipse.org and participates in the annual Eclipse release train. The code is open source under the Eclipse Public License. Yet, the language can be compiled and run independently of the Eclipse platform."
  },
  "554": {
    "label": "Yahoo! Query Language",
    "wikipedia_pageid": 22672444,
    "inception": null,
    "paradigm": [],
    "typing": [],
    "description": "**Yahoo! Query Language** (**YQL**) is an SQL-like query language created by Yahoo! as part of their Developer Network. YQL is designed to retrieve and manipulate data from APIs through a single Web interface, thus allowing mashups that enable developers to create their own applications. Initially launched in October 2008 with access to Yahoo APIs, February 2009 saw the addition of open data tables from third parties such as Google Reader, the _Guardian_, and _The New York Times_. Some of these APIs still require an API key to access them. On April 29 of 2009, Yahoo introduced the capability to execute the tables of data built through YQL using JavaScript run on the company's servers for free. On January 3, 2019 Yahoo retired the YQL API service."
  },
  "555": {
    "label": "Yoix",
    "wikipedia_pageid": 2248859,
    "inception": { "time": "+2000-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6, 2],
    "typing": [10, 2],
    "description": "In computer programming,**Yoix** is a high-level, general-purpose, interpreted, dynamic programming language. The Yoix interpreter is implemented using standard Java technology without any add-on packages and requires only a Sun-compliant JVM to operate. Initially developed by AT&T Labs researchers for internal use, it has been available as free and open source software since late 2000."
  },
  "556": {
    "label": "Yorick",
    "wikipedia_pageid": 175271,
    "inception": { "time": "+1996-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [20],
    "typing": [],
    "description": "**Yorick** is an interpreted programming language designed for numerics, graph plotting, and steering large scientific simulation codes. It is quite fast due to array syntax, and extensible via C or Fortran routines. It was created in 1996 by David H. Munro of Lawrence Livermore National Laboratory."
  },
  "557": {
    "label": "Z++",
    "wikipedia_pageid": 140589,
    "inception": null,
    "paradigm": [6],
    "typing": [],
    "description": "**Z++** (pronounced _zed plus plus_) is an object-oriented extension to the Z specification language. Z++ allows for the definition of classes, and the relation of classes through inheritance, association, or aggregation. The primary construct of Z++ is a class. A Z++ class consists of a number of clauses which are optional."
  },
  "558": {
    "label": "ZOPL",
    "wikipedia_pageid": 4426247,
    "inception": { "time": "+1970-01-01T00:00:00Z", "precision": 8 },
    "paradigm": [2],
    "typing": [],
    "description": "**ZOPL** is a programming language created by Geac Computer Corporation in the early 1970s for use on their mainframe computer systems used in libraries and banking institutions. It had similarities to C and Pascal. ZOPL stood for \"Version Z, Our Programming Language\". ZOPL is still in use at CGI Group (formerly known as RealTime Datapro), who ported it to VAX/VMS and Unix in the 1980s, and to Windows in 1998. by 2010 it had been ported to run on Windows XP/2000/2003 and Red Hat Linux. The RTM (formerly ZUG) language compiler and runtime framework are written in ZOPL. Outside of CGI, ZOPL has not been in general use since the late 1980s, although there is still one known working system where it is found embedded in programs written in the KARL programming language."
  },
  "559": {
    "label": "ZPL",
    "wikipedia_pageid": 890761,
    "inception": { "time": "+1993-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [20],
    "typing": [],
    "description": "**ZPL** (short for _Z-level Programming Language_) is an array programming language designed to replace C and C++ programming languages in engineering and scientific applications. Because its design goal was to obtain cross- platform high performance, ZPL programs run fast on both sequential and parallel computers. Highly-parallel ZPL programs are simple and easy to write because it exclusively uses implicit parallelism. Originally called **Orca C**, ZPL was designed and implemented during 1993–1995 by the Orca Project of the Computer Science and Engineering Department at the University of Washington."
  },
  "560": {
    "label": "Zebra",
    "wikipedia_pageid": 31495398,
    "inception": { "time": "+1989-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**Zebra Programming Language** (**ZPL**) is a page description language from Zebra Technologies, used primarily for labeling applications. The original language was superseded by **ZPL II**, but it is not fully compatible with the older version. Meanwhile, ZPL II is emulated by many label printers of various producers. Later, the **Zebra BASIC Interpreter** (**ZBI**) was integrated into printer software, which is seen as an advancement to ZPL II by the producer and is ANSI BASIC oriented. Primarily, it is intended to avoid a refactoring of code when changing the printer, if the old printer software was written by a label printer of a competitor. A possible use of ZBI could be for when the Zebra printer receives a foreign label format, which it would then convert to ZPL II on the fly so it can be printed."
  },
  "561": {
    "label": "Zeno",
    "wikipedia_pageid": 928636,
    "inception": null,
    "paradigm": [2, 3],
    "typing": [],
    "description": "**Zeno** (after pre-Socratic Greek philosopher Zeno of Elea) is an imperative procedural programming language designed to be easy to learn and user friendly. Zeno is generic in the sense that it contains most of the essential elements used in other languages to develop real applications. The Zeno Interpreter was designed for use in Windows 95 and later Microsoft operating systems. The interpreter comes with built-in debugging tools, a source code text editor, and an on-line language reference. Zeno was created by Stephen R. Schmitt and is maintained by Abecedarical Systems."
  },
  "562": {
    "label": "Lisp Machine Lisp",
    "wikipedia_pageid": 47775,
    "inception": { "time": "+1976-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [6],
    "typing": [],
    "description": "**Lisp Machine Lisp** is a programming language, a dialect of the language Lisp. A direct descendant of Maclisp, it was initially developed in the mid to late 1970s as the system programming language for the Massachusetts Institute of Technology (MIT) Lisp machines. Lisp Machine Lisp was also the Lisp dialect with the most influence on the design of Common Lisp. Lisp Machine Lisp branched into three dialects. Symbolics named their variant ZetaLisp. Lisp Machines, Inc. and later Texas Instruments (with the TI Explorer) would share a common code base, but their dialect of Lisp Machine Lisp would differ from the version maintained at the MIT AI Lab by Richard Stallman and others."
  },
  "563": {
    "label": "Zig",
    "wikipedia_pageid": 61049743,
    "inception": { "time": "+2015-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [2, 3, 21, 26, 16],
    "typing": [12, 6, 1, 11],
    "description": "**Zig** is an imperative, general-purpose, statically typed, compiled system programming language designed by Andrew Kelley. The language is designed for \"robustness, optimality and maintainability\" , supporting compile-time generics and reflection, cross-compilation and manual memory management. A major goal of the language is to improve upon the C language, while also taking inspiration from Rust, among others. Zig has many features for low-level programming, notably: packed structs (structs without padding between fields), arbitrary width integers and multiple pointer types. The stage 1 compiler is written in Zig and C++, using LLVM 11 as a back-end, supporting many of its native targets. The compiler is free and open source software under the MIT License. The Zig compiler exposes the ability to compile C and C++ similarly to Clang with the commands \"zig cc\" and \"zig c++\", providing many headers including libc and libcxx for many different platforms, allowing Zig's cc and c++ sub- commands to act as cross compilers out of the box. Zig development is funded by the Zig Software Foundation (ZSF), a non-profit corporation with Andrew Kelley as president, which takes in donations and hires multiple full-time employees."
  },
  "564": {
    "label": "Analitik",
    "wikipedia_pageid": 56213481,
    "inception": { "time": "+1968-01-01T00:00:00Z", "precision": 9 },
    "paradigm": [],
    "typing": [],
    "description": "**Analitik** (Russian: Аналитик) is a programming language, developed in 1968 at the Institute of Cybernetics of the Academy of Sciences of the Ukrainian SSR in the USSR. It is a development on the ALMIR-65 language, keeping compatibility with it. Distinctive features of the language are abstract data types, calculations in arbitrary algebras, and analytic transformations. It was implemented on MIR-2 machines. Later, a version of Analitik-74 was developed, implemented on MIR-3 machines. At the moment, the language exists as a computer algebra system, Analitik-2010, which is being developed jointly by the Institute of Mathematical Machines and Systems of the National Academy of Sciences of Ukraine and the Poltava National Technical University."
  }
}
